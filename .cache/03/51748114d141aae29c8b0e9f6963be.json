{"id":"game-objects/Pacman.js","dependencies":[{"name":"C:\\Users\\דור\\Desktop\\pmm\\package.json","includedInParent":true,"mtime":1560952935180},{"name":"phaser","loc":{"line":1,"column":19},"parent":"C:\\Users\\דור\\Desktop\\pmm\\client\\src\\game-objects\\Pacman.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\phaser.js"},{"name":"../constants","loc":{"line":2,"column":48},"parent":"C:\\Users\\דור\\Desktop\\pmm\\client\\src\\game-objects\\Pacman.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\client\\src\\constants.js"}],"generated":{"js":"\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Pacman = void 0;\n\nvar _phaser = _interopRequireDefault(require(\"phaser\"));\n\nvar _constants = require(\"../constants\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction _typeof(obj) { if (typeof Symbol === \"function\" && typeof Symbol.iterator === \"symbol\") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === \"function\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \"symbol\" : typeof obj; }; } return _typeof(obj); }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError(\"Cannot call a class as a function\"); } }\n\nfunction _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if (\"value\" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }\n\nfunction _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }\n\nfunction _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === \"object\" || typeof call === \"function\")) { return call; } return _assertThisInitialized(self); }\n\nfunction _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }\n\nfunction _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError(\"this hasn't been initialised - super() hasn't been called\"); } return self; }\n\nfunction _inherits(subClass, superClass) { if (typeof superClass !== \"function\" && superClass !== null) { throw new TypeError(\"Super expression must either be null or a function\"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }\n\nfunction _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }\n\nvar Pacman =\n/*#__PURE__*/\nfunction (_Phaser$GameObjects$S) {\n  _inherits(Pacman, _Phaser$GameObjects$S);\n\n  function Pacman(scene, inputs, player) {\n    var _this;\n\n    var x = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 48;\n    var y = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : 48;\n\n    _classCallCheck(this, Pacman);\n\n    _this = _possibleConstructorReturn(this, _getPrototypeOf(Pacman).call(this, scene, x, y, _constants.SPRITES.PACMAN, 3));\n\n    _this.scene.add.existing(_assertThisInitialized(_this)); // add our sprite to the scene\n\n\n    _this.scene.physics.world.enable(_assertThisInitialized(_this)); // add physics to our sprite\n\n\n    _this.index = Pacman.Count++;\n    _this.lives = 3;\n    _this.points = 0;\n    _this.player = player;\n    _this.inputs = inputs;\n\n    _this.body.setVelocity(0, 0);\n\n    _this.animation = scene.anims.create({\n      key: \"\".concat(_constants.ANIMATIONS.PACMAN, \"_\").concat(Pacman.Count) + _this.player.toString() + _this.player.toString(),\n      frames: scene.anims.generateFrameNumbers(_constants.SPRITES.PACMAN, {\n        frames: [0 + _this.player * 3, 1 + _this.player * 3, 2 + _this.player * 3, 1 + _this.player * 3]\n      }),\n      frameRate: 12,\n      yoyo: false,\n      repeat: -1\n    });\n\n    if (_this.player == 1) {\n      _this.text_x = 1080;\n      _this.text_y = 50;\n    } else {\n      _this.text_x = 1080;\n      _this.text_y = 20;\n    }\n\n    _this.livesText = _this.scene.add.text(_this.text_x, _this.text_y, 'Player ' + (_this.player + 1).toString() + ' lives: ' + _this.lives + ' | Points: ' + _this.points, {\n      font: '20px monospace',\n      fill: '#000000'\n    });\n\n    _this.livesText.setOrigin(0.5, 0.5);\n\n    _this.scene.add.existing(_this.livesText);\n\n    _this.anims.play(_this.animation);\n\n    return _this;\n  }\n\n  _createClass(Pacman, [{\n    key: \"TouchDot\",\n    value: function TouchDot() {\n      this.points++;\n      this.livesText.setText('Player ' + this.player.toString() + ' lives: ' + this.lives + ' | Points: ' + this.points);\n    }\n  }, {\n    key: \"TouchGhost\",\n    value: function TouchGhost() {\n      this.lives--;\n      this.x = 48;\n      this.y = 48;\n      this.livesText.setText('Player ' + this.player.toString() + ' lives: ' + this.lives + ' | Points: ' + this.points);\n    }\n  }, {\n    key: \"move\",\n    value: function move(walls) {\n      var _neighbors;\n\n      // get the current tiles and its neighbors ( true means it will return an empty tile instead of null)\n      var current = walls.getTileAtWorldXY(this.x, this.y, true); // if there's no current tile ( which means we are moving through the screen) dont do anything\n\n      if (!current) {\n        return;\n      } // get the neighbor tiles\n\n\n      var _this$inputs = this.inputs,\n          up = _this$inputs.up,\n          down = _this$inputs.down,\n          right = _this$inputs.right,\n          left = _this$inputs.left;\n      var neighbors = (_neighbors = {}, _defineProperty(_neighbors, _constants.DIRECTIONS.UP, walls.getTileAt(current.x, current.y - 1)), _defineProperty(_neighbors, _constants.DIRECTIONS.DOWN, walls.getTileAt(current.x, current.y + 1)), _defineProperty(_neighbors, _constants.DIRECTIONS.RIGHT, walls.getTileAt(current.x + 1, current.y)), _defineProperty(_neighbors, _constants.DIRECTIONS.LEFT, walls.getTileAt(current.x - 1, current.y)), _neighbors); // check if a key is down and the tile in that direction is not a wall\n\n      if (up.isDown && neighbors[_constants.DIRECTIONS.UP] == null) {\n        this.turn(_constants.DIRECTIONS.UP, current, neighbors.up);\n        this.animation.resume();\n      } else if (down.isDown && neighbors[_constants.DIRECTIONS.DOWN] == null) {\n        this.turn(_constants.DIRECTIONS.DOWN, current, neighbors.down);\n        this.animation.resume();\n      } else if (left.isDown && neighbors[_constants.DIRECTIONS.LEFT] == null) {\n        this.turn(_constants.DIRECTIONS.LEFT, current, neighbors.left);\n        this.animation.resume();\n      } else if (right.isDown && neighbors[_constants.DIRECTIONS.RIGHT] == null) {\n        this.turn(_constants.DIRECTIONS.RIGHT, current, neighbors.right);\n        this.animation.resume();\n      } // if we try to move forward and there's a wall in front stop stop the animation\n\n\n      if (this.body.onFloor() || this.body.onCeiling() || this.body.onWall()) {\n        this.animation.pause();\n      }\n\n      this.scene.physics.velocityFromAngle(this.angle, -128, this.body.velocity);\n    }\n    /**\r\n     * Turns pacman to the given direction\r\n     * @param {Number} direction  The angle direction we want to turn\r\n     * @param {Phaser.Tilemaps.Tile} current The current Tile we are on \r\n     * @param {Phaser.Tilemaps.Tile} neighbor The Tile we are going to turn to\r\n     */\n\n  }, {\n    key: \"turn\",\n    value: function turn(direction, current, neighbor) {\n      // if we are moving towards the same direction or if there's a neighbor wall we can't turn \n      if (this.angle == direction || neighbor) {\n        return;\n      } // if we are turning to the opposite direction we can turn\n\n\n      if (_phaser.default.Math.Angle.WrapDegrees(direction + 180) == this.angle) {\n        this.setAngle(direction);\n        return;\n      } // if we're not close enough to the turning point don't turn\n\n\n      if (!_phaser.default.Math.Fuzzy.Equal(this.y, current.getCenterY(), 2) || !_phaser.default.Math.Fuzzy.Equal(this.x, current.getCenterX(), 2)) {\n        return;\n      } // position pacman perfectly on the turn point\n\n\n      this.body.stop();\n      this.setPosition(current.getCenterX(), current.getCenterY());\n      this.body.prev.copy(this.body.position); // \n\n      this.setAngle(direction);\n      return true;\n    }\n  }]);\n\n  return Pacman;\n}(_phaser.default.GameObjects.Sprite);\n\nexports.Pacman = Pacman;\nPacman.Count = 0;"},"sourceMaps":null,"error":null,"hash":"4febb2ccda9856277d0d0e3d92f50034","cacheData":{"env":{}}}