{"id":"../../node_modules/phaser/src/textures/Frame.js","dependencies":[{"name":"C:\\Users\\Admin\\Desktop\\pmm\\package.json","includedInParent":true,"mtime":1560952935180},{"name":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\package.json","includedInParent":true,"mtime":1561134727120},{"name":"../utils/Class","loc":{"line":7,"column":20},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\textures\\Frame.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\Class.js"},{"name":"../math/Clamp","loc":{"line":8,"column":20},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\textures\\Frame.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\math\\Clamp.js"},{"name":"../utils/object/Extend","loc":{"line":9,"column":21},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\textures\\Frame.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\object\\Extend.js"}],"generated":{"js":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar Clamp = require('../math/Clamp');\r\nvar Extend = require('../utils/object/Extend');\r\n\r\n/**\r\n * @classdesc\r\n * A Frame is a section of a Texture.\r\n *\r\n * @class Frame\r\n * @memberof Phaser.Textures\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Textures.Texture} texture - The Texture this Frame is a part of.\r\n * @param {(integer|string)} name - The name of this Frame. The name is unique within the Texture.\r\n * @param {integer} sourceIndex - The index of the TextureSource that this Frame is a part of.\r\n * @param {number} x - The x coordinate of the top-left of this Frame.\r\n * @param {number} y - The y coordinate of the top-left of this Frame.\r\n * @param {number} width - The width of this Frame.\r\n * @param {number} height - The height of this Frame.\r\n */\r\nvar Frame = new Class({\r\n\r\n    initialize:\r\n\r\n    function Frame (texture, name, sourceIndex, x, y, width, height)\r\n    {\r\n        /**\r\n         * The Texture this Frame is a part of.\r\n         *\r\n         * @name Phaser.Textures.Frame#texture\r\n         * @type {Phaser.Textures.Texture}\r\n         * @since 3.0.0\r\n         */\r\n        this.texture = texture;\r\n\r\n        /**\r\n         * The name of this Frame.\r\n         * The name is unique within the Texture.\r\n         *\r\n         * @name Phaser.Textures.Frame#name\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.name = name;\r\n\r\n        /**\r\n         * The TextureSource this Frame is part of.\r\n         *\r\n         * @name Phaser.Textures.Frame#source\r\n         * @type {Phaser.Textures.TextureSource}\r\n         * @since 3.0.0\r\n         */\r\n        this.source = texture.source[sourceIndex];\r\n\r\n        /**\r\n         * The index of the TextureSource in the Texture sources array.\r\n         *\r\n         * @name Phaser.Textures.Frame#sourceIndex\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.sourceIndex = sourceIndex;\r\n\r\n        /**\r\n         * A reference to the Texture Source WebGL Texture that this Frame is using.\r\n         *\r\n         * @name Phaser.Textures.Frame#glTexture\r\n         * @type {?WebGLTexture}\r\n         * @default null\r\n         * @since 3.11.0\r\n         */\r\n        this.glTexture = this.source.glTexture;\r\n\r\n        /**\r\n         * X position within the source image to cut from.\r\n         *\r\n         * @name Phaser.Textures.Frame#cutX\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.cutX;\r\n\r\n        /**\r\n         * Y position within the source image to cut from.\r\n         *\r\n         * @name Phaser.Textures.Frame#cutY\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.cutY;\r\n\r\n        /**\r\n         * The width of the area in the source image to cut.\r\n         *\r\n         * @name Phaser.Textures.Frame#cutWidth\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.cutWidth;\r\n\r\n        /**\r\n         * The height of the area in the source image to cut.\r\n         *\r\n         * @name Phaser.Textures.Frame#cutHeight\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.cutHeight;\r\n\r\n        /**\r\n         * The X rendering offset of this Frame, taking trim into account.\r\n         *\r\n         * @name Phaser.Textures.Frame#x\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.x = 0;\r\n\r\n        /**\r\n         * The Y rendering offset of this Frame, taking trim into account.\r\n         *\r\n         * @name Phaser.Textures.Frame#y\r\n         * @type {integer}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.y = 0;\r\n\r\n        /**\r\n         * The rendering width of this Frame, taking trim into account.\r\n         *\r\n         * @name Phaser.Textures.Frame#width\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.width;\r\n\r\n        /**\r\n         * The rendering height of this Frame, taking trim into account.\r\n         *\r\n         * @name Phaser.Textures.Frame#height\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.height;\r\n\r\n        /**\r\n         * Half the width, floored.\r\n         * Precalculated for the renderer.\r\n         *\r\n         * @name Phaser.Textures.Frame#halfWidth\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.halfWidth;\r\n\r\n        /**\r\n         * Half the height, floored.\r\n         * Precalculated for the renderer.\r\n         *\r\n         * @name Phaser.Textures.Frame#halfHeight\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.halfHeight;\r\n\r\n        /**\r\n         * The x center of this frame, floored.\r\n         *\r\n         * @name Phaser.Textures.Frame#centerX\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.centerX;\r\n\r\n        /**\r\n         * The y center of this frame, floored.\r\n         *\r\n         * @name Phaser.Textures.Frame#centerY\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.centerY;\r\n\r\n        /**\r\n         * The horizontal pivot point of this Frame.\r\n         *\r\n         * @name Phaser.Textures.Frame#pivotX\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.pivotX = 0;\r\n\r\n        /**\r\n         * The vertical pivot point of this Frame.\r\n         *\r\n         * @name Phaser.Textures.Frame#pivotY\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.pivotY = 0;\r\n\r\n        /**\r\n         * Does this Frame have a custom pivot point?\r\n         *\r\n         * @name Phaser.Textures.Frame#customPivot\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.customPivot = false;\r\n\r\n        /**\r\n         * **CURRENTLY UNSUPPORTED**\r\n         *\r\n         * Is this frame is rotated or not in the Texture?\r\n         * Rotation allows you to use rotated frames in texture atlas packing.\r\n         * It has nothing to do with Sprite rotation.\r\n         *\r\n         * @name Phaser.Textures.Frame#rotated\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.rotated = false;\r\n\r\n        /**\r\n         * Over-rides the Renderer setting.\r\n         * -1 = use Renderer Setting\r\n         * 0 = No rounding\r\n         * 1 = Round\r\n         *\r\n         * @name Phaser.Textures.Frame#autoRound\r\n         * @type {integer}\r\n         * @default -1\r\n         * @since 3.0.0\r\n         */\r\n        this.autoRound = -1;\r\n\r\n        /**\r\n         * Any Frame specific custom data can be stored here.\r\n         *\r\n         * @name Phaser.Textures.Frame#customData\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.customData = {};\r\n\r\n        /**\r\n         * WebGL UV u0 value.\r\n         *\r\n         * @name Phaser.Textures.Frame#u0\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.11.0\r\n         */\r\n        this.u0 = 0;\r\n\r\n        /**\r\n         * WebGL UV v0 value.\r\n         *\r\n         * @name Phaser.Textures.Frame#v0\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.11.0\r\n         */\r\n        this.v0 = 0;\r\n\r\n        /**\r\n         * WebGL UV u1 value.\r\n         *\r\n         * @name Phaser.Textures.Frame#u1\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.11.0\r\n         */\r\n        this.u1 = 0;\r\n\r\n        /**\r\n         * WebGL UV v1 value.\r\n         *\r\n         * @name Phaser.Textures.Frame#v1\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.11.0\r\n         */\r\n        this.v1 = 0;\r\n\r\n        /**\r\n         * The un-modified source frame, trim and UV data.\r\n         *\r\n         * @name Phaser.Textures.Frame#data\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this.data = {\r\n            cut: {\r\n                x: 0,\r\n                y: 0,\r\n                w: 0,\r\n                h: 0,\r\n                r: 0,\r\n                b: 0\r\n            },\r\n            trim: false,\r\n            sourceSize: {\r\n                w: 0,\r\n                h: 0\r\n            },\r\n            spriteSourceSize: {\r\n                x: 0,\r\n                y: 0,\r\n                w: 0,\r\n                h: 0,\r\n                r: 0,\r\n                b: 0\r\n            },\r\n            radius: 0,\r\n            drawImage: {\r\n                x: 0,\r\n                y: 0,\r\n                width: 0,\r\n                height: 0\r\n            }\r\n        };\r\n\r\n        this.setSize(width, height, x, y);\r\n    },\r\n\r\n    /**\r\n     * Sets the width, height, x and y of this Frame.\r\n     * \r\n     * This is called automatically by the constructor\r\n     * and should rarely be changed on-the-fly.\r\n     *\r\n     * @method Phaser.Textures.Frame#setSize\r\n     * @since 3.7.0\r\n     *\r\n     * @param {integer} width - The width of the frame before being trimmed.\r\n     * @param {integer} height - The height of the frame before being trimmed.\r\n     * @param {integer} [x=0] - The x coordinate of the top-left of this Frame.\r\n     * @param {integer} [y=0] - The y coordinate of the top-left of this Frame.\r\n     *\r\n     * @return {Phaser.Textures.Frame} This Frame object.\r\n     */\r\n    setSize: function (width, height, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        this.cutX = x;\r\n        this.cutY = y;\r\n        this.cutWidth = width;\r\n        this.cutHeight = height;\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        this.halfWidth = Math.floor(width * 0.5);\r\n        this.halfHeight = Math.floor(height * 0.5);\r\n\r\n        this.centerX = Math.floor(width / 2);\r\n        this.centerY = Math.floor(height / 2);\r\n\r\n        var data = this.data;\r\n        var cut = data.cut;\r\n\r\n        cut.x = x;\r\n        cut.y = y;\r\n        cut.w = width;\r\n        cut.h = height;\r\n        cut.r = x + width;\r\n        cut.b = y + height;\r\n\r\n        data.sourceSize.w = width;\r\n        data.sourceSize.h = height;\r\n\r\n        data.spriteSourceSize.w = width;\r\n        data.spriteSourceSize.h = height;\r\n\r\n        data.radius = 0.5 * Math.sqrt(width * width + height * height);\r\n\r\n        var drawImage = data.drawImage;\r\n\r\n        drawImage.x = x;\r\n        drawImage.y = y;\r\n        drawImage.width = width;\r\n        drawImage.height = height;\r\n\r\n        return this.updateUVs();\r\n    },\r\n\r\n    /**\r\n     * If the frame was trimmed when added to the Texture Atlas, this records the trim and source data.\r\n     *\r\n     * @method Phaser.Textures.Frame#setTrim\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} actualWidth - The width of the frame before being trimmed.\r\n     * @param {number} actualHeight - The height of the frame before being trimmed.\r\n     * @param {number} destX - The destination X position of the trimmed frame for display.\r\n     * @param {number} destY - The destination Y position of the trimmed frame for display.\r\n     * @param {number} destWidth - The destination width of the trimmed frame for display.\r\n     * @param {number} destHeight - The destination height of the trimmed frame for display.\r\n     *\r\n     * @return {Phaser.Textures.Frame} This Frame object.\r\n     */\r\n    setTrim: function (actualWidth, actualHeight, destX, destY, destWidth, destHeight)\r\n    {\r\n        var data = this.data;\r\n        var ss = data.spriteSourceSize;\r\n\r\n        //  Store actual values\r\n\r\n        data.trim = true;\r\n\r\n        data.sourceSize.w = actualWidth;\r\n        data.sourceSize.h = actualHeight;\r\n\r\n        ss.x = destX;\r\n        ss.y = destY;\r\n        ss.w = destWidth;\r\n        ss.h = destHeight;\r\n        ss.r = destX + destWidth;\r\n        ss.b = destY + destHeight;\r\n\r\n        //  Adjust properties\r\n        this.x = destX;\r\n        this.y = destY;\r\n\r\n        this.width = destWidth;\r\n        this.height = destHeight;\r\n\r\n        this.halfWidth = destWidth * 0.5;\r\n        this.halfHeight = destHeight * 0.5;\r\n\r\n        this.centerX = Math.floor(destWidth / 2);\r\n        this.centerY = Math.floor(destHeight / 2);\r\n\r\n        return this.updateUVs();\r\n    },\r\n\r\n    /**\r\n     * Takes a crop data object and, based on the rectangular region given, calculates the\r\n     * required UV coordinates in order to crop this Frame for WebGL and Canvas rendering.\r\n     * \r\n     * This is called directly by the Game Object Texture Components `setCrop` method.\r\n     * Please use that method to crop a Game Object.\r\n     *\r\n     * @method Phaser.Textures.Frame#setCropUVs\r\n     * @since 3.11.0\r\n     * \r\n     * @param {object} crop - The crop data object. This is the `GameObject._crop` property.\r\n     * @param {number} x - The x coordinate to start the crop from. Cannot be negative or exceed the Frame width.\r\n     * @param {number} y - The y coordinate to start the crop from. Cannot be negative or exceed the Frame height.\r\n     * @param {number} width - The width of the crop rectangle. Cannot exceed the Frame width.\r\n     * @param {number} height - The height of the crop rectangle. Cannot exceed the Frame height.\r\n     * @param {boolean} flipX - Does the parent Game Object have flipX set?\r\n     * @param {boolean} flipY - Does the parent Game Object have flipY set?\r\n     *\r\n     * @return {object} The updated crop data object.\r\n     */\r\n    setCropUVs: function (crop, x, y, width, height, flipX, flipY)\r\n    {\r\n        //  Clamp the input values\r\n\r\n        var cx = this.cutX;\r\n        var cy = this.cutY;\r\n        var cw = this.cutWidth;\r\n        var ch = this.cutHeight;\r\n        var rw = this.realWidth;\r\n        var rh = this.realHeight;\r\n\r\n        x = Clamp(x, 0, rw);\r\n        y = Clamp(y, 0, rh);\r\n\r\n        width = Clamp(width, 0, rw - x);\r\n        height = Clamp(height, 0, rh - y);\r\n\r\n        var ox = cx + x;\r\n        var oy = cy + y;\r\n        var ow = width;\r\n        var oh = height;\r\n\r\n        var data = this.data;\r\n\r\n        if (data.trim)\r\n        {\r\n            var ss = data.spriteSourceSize;\r\n\r\n            //  Need to check for intersection between the cut area and the crop area\r\n            //  If there is none, we set UV to be empty, otherwise set it to be the intersection area\r\n\r\n            width = Clamp(width, 0, cw - x);\r\n            height = Clamp(height, 0, ch - y);\r\n    \r\n            var cropRight = x + width;\r\n            var cropBottom = y + height;\r\n\r\n            var intersects = !(ss.r < x || ss.b < y || ss.x > cropRight || ss.y > cropBottom);\r\n\r\n            if (intersects)\r\n            {\r\n                var ix = Math.max(ss.x, x);\r\n                var iy = Math.max(ss.y, y);\r\n                var iw = Math.min(ss.r, cropRight) - ix;\r\n                var ih = Math.min(ss.b, cropBottom) - iy;\r\n\r\n                ow = iw;\r\n                oh = ih;\r\n    \r\n                if (flipX)\r\n                {\r\n                    ox = cx + (cw - (ix - ss.x) - iw);\r\n                }\r\n                else\r\n                {\r\n                    ox = cx + (ix - ss.x);\r\n                }\r\n        \r\n                if (flipY)\r\n                {\r\n                    oy = cy + (ch - (iy - ss.y) - ih);\r\n                }\r\n                else\r\n                {\r\n                    oy = cy + (iy - ss.y);\r\n                }\r\n\r\n                x = ix;\r\n                y = iy;\r\n\r\n                width = iw;\r\n                height = ih;\r\n            }\r\n            else\r\n            {\r\n                ox = 0;\r\n                oy = 0;\r\n                ow = 0;\r\n                oh = 0;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if (flipX)\r\n            {\r\n                ox = cx + (cw - x - width);\r\n            }\r\n    \r\n            if (flipY)\r\n            {\r\n                oy = cy + (ch - y - height);\r\n            }\r\n        }\r\n\r\n        var tw = this.source.width;\r\n        var th = this.source.height;\r\n\r\n        //  Map the given coordinates into UV space, clamping to the 0-1 range.\r\n\r\n        crop.u0 = Math.max(0, ox / tw);\r\n        crop.v0 = Math.max(0, oy / th);\r\n        crop.u1 = Math.min(1, (ox + ow) / tw);\r\n        crop.v1 = Math.min(1, (oy + oh) / th);\r\n\r\n        crop.x = x;\r\n        crop.y = y;\r\n\r\n        crop.cx = ox;\r\n        crop.cy = oy;\r\n        crop.cw = ow;\r\n        crop.ch = oh;\r\n\r\n        crop.width = width;\r\n        crop.height = height;\r\n\r\n        crop.flipX = flipX;\r\n        crop.flipY = flipY;\r\n\r\n        return crop;\r\n    },\r\n\r\n    /**\r\n     * Takes a crop data object and recalculates the UVs based on the dimensions inside the crop object.\r\n     * Called automatically by `setFrame`.\r\n     *\r\n     * @method Phaser.Textures.Frame#updateCropUVs\r\n     * @since 3.11.0\r\n     * \r\n     * @param {object} crop - The crop data object. This is the `GameObject._crop` property.\r\n     * @param {boolean} flipX - Does the parent Game Object have flipX set?\r\n     * @param {boolean} flipY - Does the parent Game Object have flipY set?\r\n     *\r\n     * @return {object} The updated crop data object.\r\n     */\r\n    updateCropUVs: function (crop, flipX, flipY)\r\n    {\r\n        return this.setCropUVs(crop, crop.x, crop.y, crop.width, crop.height, flipX, flipY);\r\n    },\r\n\r\n    /**\r\n     * Updates the internal WebGL UV cache and the drawImage cache.\r\n     *\r\n     * @method Phaser.Textures.Frame#updateUVs\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Textures.Frame} This Frame object.\r\n     */\r\n    updateUVs: function ()\r\n    {\r\n        var cx = this.cutX;\r\n        var cy = this.cutY;\r\n        var cw = this.cutWidth;\r\n        var ch = this.cutHeight;\r\n\r\n        //  Canvas data\r\n\r\n        var cd = this.data.drawImage;\r\n\r\n        cd.width = cw;\r\n        cd.height = ch;\r\n\r\n        //  WebGL data\r\n\r\n        var tw = this.source.width;\r\n        var th = this.source.height;\r\n\r\n        this.u0 = cx / tw;\r\n        this.v0 = cy / th;\r\n\r\n        this.u1 = (cx + cw) / tw;\r\n        this.v1 = (cy + ch) / th;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Updates the internal WebGL UV cache.\r\n     *\r\n     * @method Phaser.Textures.Frame#updateUVsInverted\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Textures.Frame} This Frame object.\r\n     */\r\n    updateUVsInverted: function ()\r\n    {\r\n        var tw = this.source.width;\r\n        var th = this.source.height;\r\n\r\n        this.u0 = (this.cutX + this.cutHeight) / tw;\r\n        this.v0 = this.cutY / th;\r\n\r\n        this.u1 = this.cutX / tw;\r\n        this.v1 = (this.cutY + this.cutWidth) / th;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Clones this Frame into a new Frame object.\r\n     *\r\n     * @method Phaser.Textures.Frame#clone\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Textures.Frame} A clone of this Frame.\r\n     */\r\n    clone: function ()\r\n    {\r\n        var clone = new Frame(this.texture, this.name, this.sourceIndex);\r\n\r\n        clone.cutX = this.cutX;\r\n        clone.cutY = this.cutY;\r\n        clone.cutWidth = this.cutWidth;\r\n        clone.cutHeight = this.cutHeight;\r\n\r\n        clone.x = this.x;\r\n        clone.y = this.y;\r\n\r\n        clone.width = this.width;\r\n        clone.height = this.height;\r\n\r\n        clone.halfWidth = this.halfWidth;\r\n        clone.halfHeight = this.halfHeight;\r\n\r\n        clone.centerX = this.centerX;\r\n        clone.centerY = this.centerY;\r\n\r\n        clone.rotated = this.rotated;\r\n\r\n        clone.data = Extend(true, clone.data, this.data);\r\n\r\n        clone.updateUVs();\r\n\r\n        return clone;\r\n    },\r\n\r\n    /**\r\n     * Destroys this Frames references.\r\n     *\r\n     * @method Phaser.Textures.Frame#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.texture = null;\r\n\r\n        this.source = null;\r\n    },\r\n\r\n    /**\r\n     * The width of the Frame in its un-trimmed, un-padded state, as prepared in the art package,\r\n     * before being packed.\r\n     *\r\n     * @name Phaser.Textures.Frame#realWidth\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    realWidth: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.data.sourceSize.w;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The height of the Frame in its un-trimmed, un-padded state, as prepared in the art package,\r\n     * before being packed.\r\n     *\r\n     * @name Phaser.Textures.Frame#realHeight\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    realHeight: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.data.sourceSize.h;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The radius of the Frame (derived from sqrt(w * w + h * h) / 2)\r\n     *\r\n     * @name Phaser.Textures.Frame#radius\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    radius: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.data.radius;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * Is the Frame trimmed or not?\r\n     *\r\n     * @name Phaser.Textures.Frame#trimmed\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    trimmed: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.data.trim;\r\n        }\r\n\r\n    },\r\n\r\n    /**\r\n     * The Canvas drawImage data object.\r\n     *\r\n     * @name Phaser.Textures.Frame#canvasData\r\n     * @type {object}\r\n     * @readonly\r\n     * @since 3.0.0\r\n     */\r\n    canvasData: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.data.drawImage;\r\n        }\r\n\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Frame;\r\n"},"sourceMaps":null,"error":null,"hash":"4cedcbc4ca9082a228fa9b6200e8fbfa","cacheData":{"env":{}}}