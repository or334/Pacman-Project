{"id":"../../node_modules/phaser/src/physics/arcade/GetOverlapX.js","dependencies":[{"name":"C:\\Users\\דור\\Desktop\\pmm\\package.json","includedInParent":true,"mtime":1560952935180},{"name":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\package.json","includedInParent":true,"mtime":1561396619369},{"name":"./const","loc":{"line":7,"column":20},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\GetOverlapX.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\const.js"}],"generated":{"js":"/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar CONST = require('./const');\n\n/**\n * Calculates and returns the horizontal overlap between two arcade physics bodies and sets their properties\n * accordingly, including: `touching.left`, `touching.right`, `touching.none` and `overlapX'.\n *\n * @function Phaser.Physics.Arcade.GetOverlapX\n * @since 3.0.0\n *\n * @param {Phaser.Physics.Arcade.Body} body1 - The first Body to separate.\n * @param {Phaser.Physics.Arcade.Body} body2 - The second Body to separate.\n * @param {boolean} overlapOnly - Is this an overlap only check, or part of separation?\n * @param {number} bias - A value added to the delta values during collision checks. Increase it to prevent sprite tunneling(sprites passing through another instead of colliding).\n *\n * @return {number} The amount of overlap.\n */\nvar GetOverlapX = function (body1, body2, overlapOnly, bias)\n{\n    var overlap = 0;\n    var maxOverlap = body1.deltaAbsX() + body2.deltaAbsX() + bias;\n\n    if (body1._dx === 0 && body2._dx === 0)\n    {\n        //  They overlap but neither of them are moving\n        body1.embedded = true;\n        body2.embedded = true;\n    }\n    else if (body1._dx > body2._dx)\n    {\n        //  Body1 is moving right and / or Body2 is moving left\n        overlap = body1.right - body2.x;\n\n        if ((overlap > maxOverlap && !overlapOnly) || body1.checkCollision.right === false || body2.checkCollision.left === false)\n        {\n            overlap = 0;\n        }\n        else\n        {\n            body1.touching.none = false;\n            body1.touching.right = true;\n\n            body2.touching.none = false;\n            body2.touching.left = true;\n\n            if (body2.physicsType === CONST.STATIC_BODY)\n            {\n                body1.blocked.none = false;\n                body1.blocked.right = true;\n            }\n\n            if (body1.physicsType === CONST.STATIC_BODY)\n            {\n                body2.blocked.none = false;\n                body2.blocked.left = true;\n            }\n        }\n    }\n    else if (body1._dx < body2._dx)\n    {\n        //  Body1 is moving left and/or Body2 is moving right\n        overlap = body1.x - body2.width - body2.x;\n\n        if ((-overlap > maxOverlap && !overlapOnly) || body1.checkCollision.left === false || body2.checkCollision.right === false)\n        {\n            overlap = 0;\n        }\n        else\n        {\n            body1.touching.none = false;\n            body1.touching.left = true;\n\n            body2.touching.none = false;\n            body2.touching.right = true;\n\n            if (body2.physicsType === CONST.STATIC_BODY)\n            {\n                body1.blocked.none = false;\n                body1.blocked.left = true;\n            }\n\n            if (body1.physicsType === CONST.STATIC_BODY)\n            {\n                body2.blocked.none = false;\n                body2.blocked.right = true;\n            }\n        }\n    }\n\n    //  Resets the overlapX to zero if there is no overlap, or to the actual pixel value if there is\n    body1.overlapX = overlap;\n    body2.overlapX = overlap;\n\n    return overlap;\n};\n\nmodule.exports = GetOverlapX;\n"},"sourceMaps":null,"error":null,"hash":"247aa7cd93502a2b88b617cfe3d30756","cacheData":{"env":{}}}