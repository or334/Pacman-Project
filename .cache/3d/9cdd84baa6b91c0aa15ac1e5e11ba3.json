{"id":"../../node_modules/phaser/src/curves/Curve.js","dependencies":[{"name":"C:\\Users\\Admin\\Desktop\\pmm\\package.json","includedInParent":true,"mtime":1560952935180},{"name":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\package.json","includedInParent":true,"mtime":1561134727120},{"name":"../utils/Class","loc":{"line":7,"column":20},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\curves\\Curve.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\Class.js"},{"name":"../geom/rectangle/FromPoints","loc":{"line":8,"column":25},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\curves\\Curve.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\geom\\rectangle\\FromPoints.js"},{"name":"../geom/rectangle/Rectangle","loc":{"line":9,"column":24},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\curves\\Curve.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\geom\\rectangle\\Rectangle.js"},{"name":"../math/Vector2","loc":{"line":10,"column":22},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\curves\\Curve.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\math\\Vector2.js"}],"generated":{"js":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar FromPoints = require('../geom/rectangle/FromPoints');\r\nvar Rectangle = require('../geom/rectangle/Rectangle');\r\nvar Vector2 = require('../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * A Base Curve class, which all other curve types extend.\r\n *\r\n * Based on the three.js Curve classes created by [zz85](http://www.lab4games.net/zz85/blog)\r\n *\r\n * @class Curve\r\n * @memberof Phaser.Curves\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {string} type - [description]\r\n */\r\nvar Curve = new Class({\r\n\r\n    initialize:\r\n\r\n    function Curve (type)\r\n    {\r\n        /**\r\n         * String based identifier for the type of curve.\r\n         *\r\n         * @name Phaser.Curves.Curve#type\r\n         * @type {string}\r\n         * @since 3.0.0\r\n         */\r\n        this.type = type;\r\n\r\n        /**\r\n         * The default number of divisions within the curve.\r\n         *\r\n         * @name Phaser.Curves.Curve#defaultDivisions\r\n         * @type {integer}\r\n         * @default 5\r\n         * @since 3.0.0\r\n         */\r\n        this.defaultDivisions = 5;\r\n\r\n        /**\r\n         * The quantity of arc length divisions within the curve.\r\n         *\r\n         * @name Phaser.Curves.Curve#arcLengthDivisions\r\n         * @type {integer}\r\n         * @default 100\r\n         * @since 3.0.0\r\n         */\r\n        this.arcLengthDivisions = 100;\r\n\r\n        /**\r\n         * An array of cached arc length values.\r\n         *\r\n         * @name Phaser.Curves.Curve#cacheArcLengths\r\n         * @type {number[]}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.cacheArcLengths = [];\r\n\r\n        /**\r\n         * Does the data of this curve need updating?\r\n         *\r\n         * @name Phaser.Curves.Curve#needsUpdate\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.needsUpdate = true;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Curves.Curve#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.active = true;\r\n\r\n        /**\r\n         * A temporary calculation Vector.\r\n         *\r\n         * @name Phaser.Curves.Curve#_tmpVec2A\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._tmpVec2A = new Vector2();\r\n\r\n        /**\r\n         * A temporary calculation Vector.\r\n         *\r\n         * @name Phaser.Curves.Curve#_tmpVec2B\r\n         * @type {Phaser.Math.Vector2}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._tmpVec2B = new Vector2();\r\n    },\r\n\r\n    /**\r\n     * Draws this curve on the given Graphics object.\r\n     *\r\n     * The curve is drawn using `Graphics.strokePoints` so will be drawn at whatever the present Graphics stroke color is.\r\n     * The Graphics object is not cleared before the draw, so the curve will appear on-top of anything else already rendered to it.\r\n     *\r\n     * @method Phaser.Curves.Curve#draw\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.GameObjects.Graphics} G - [graphics,$return]\r\n     *\r\n     * @param {Phaser.GameObjects.Graphics} graphics - The Graphics instance onto which this curve will be drawn.\r\n     * @param {integer} [pointsTotal=32] - The resolution of the curve. The higher the value the smoother it will render, at the cost of rendering performance.\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} The Graphics object to which the curve was drawn.\r\n     */\r\n    draw: function (graphics, pointsTotal)\r\n    {\r\n        if (pointsTotal === undefined) { pointsTotal = 32; }\r\n\r\n        //  So you can chain graphics calls\r\n        return graphics.strokePoints(this.getPoints(pointsTotal));\r\n    },\r\n    \r\n    /**\r\n     * Returns a Rectangle where the position and dimensions match the bounds of this Curve.\r\n     *\r\n     * You can control the accuracy of the bounds. The value given is used to work out how many points\r\n     * to plot across the curve. Higher values are more accurate at the cost of calculation speed.\r\n     *\r\n     * @method Phaser.Curves.Curve#getBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Geom.Rectangle} [out] - The Rectangle to store the bounds in. If falsey a new object will be created.\r\n     * @param {integer} [accuracy=16] - The accuracy of the bounds calculations.\r\n     *\r\n     * @return {Phaser.Geom.Rectangle} A Rectangle object holding the bounds of this curve. If `out` was given it will be this object.\r\n     */\r\n    getBounds: function (out, accuracy)\r\n    {\r\n        if (!out) { out = new Rectangle(); }\r\n        if (accuracy === undefined) { accuracy = 16; }\r\n\r\n        var len = this.getLength();\r\n\r\n        if (accuracy > len)\r\n        {\r\n            accuracy = len / 2;\r\n        }\r\n\r\n        //  The length of the curve in pixels\r\n        //  So we'll have 1 spaced point per 'accuracy' pixels\r\n\r\n        var spaced = Math.max(1, Math.round(len / accuracy));\r\n\r\n        return FromPoints(this.getSpacedPoints(spaced), out);\r\n    },\r\n\r\n    /**\r\n     * Returns an array of points, spaced out X distance pixels apart.\r\n     * The smaller the distance, the larger the array will be.\r\n     *\r\n     * @method Phaser.Curves.Curve#getDistancePoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} distance - The distance, in pixels, between each point along the curve.\r\n     *\r\n     * @return {Phaser.Geom.Point[]} An Array of Point objects.\r\n     */\r\n    getDistancePoints: function (distance)\r\n    {\r\n        var len = this.getLength();\r\n\r\n        var spaced = Math.max(1, len / distance);\r\n\r\n        return this.getSpacedPoints(spaced);\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getEndPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - Optional Vector object to store the result in.\r\n     *\r\n     * @return {Phaser.Math.Vector2} Vector2 containing the coordinates of the curves end point.\r\n     */\r\n    getEndPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        return this.getPointAt(1, out);\r\n    },\r\n\r\n    // Get total curve arc length\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getLength\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} [description]\r\n     */\r\n    getLength: function ()\r\n    {\r\n        var lengths = this.getLengths();\r\n\r\n        return lengths[lengths.length - 1];\r\n    },\r\n\r\n    // Get list of cumulative segment lengths\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getLengths\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [divisions] - [description]\r\n     *\r\n     * @return {number[]} [description]\r\n     */\r\n    getLengths: function (divisions)\r\n    {\r\n        if (divisions === undefined) { divisions = this.arcLengthDivisions; }\r\n\r\n        if ((this.cacheArcLengths.length === divisions + 1) && !this.needsUpdate)\r\n        {\r\n            return this.cacheArcLengths;\r\n        }\r\n\r\n        this.needsUpdate = false;\r\n\r\n        var cache = [];\r\n        var current;\r\n        var last = this.getPoint(0, this._tmpVec2A);\r\n        var sum = 0;\r\n\r\n        cache.push(0);\r\n\r\n        for (var p = 1; p <= divisions; p++)\r\n        {\r\n            current = this.getPoint(p / divisions, this._tmpVec2B);\r\n\r\n            sum += current.distance(last);\r\n\r\n            cache.push(sum);\r\n\r\n            last.copy(current);\r\n        }\r\n\r\n        this.cacheArcLengths = cache;\r\n\r\n        return cache; // { sums: cache, sum:sum }; Sum is in the last element.\r\n    },\r\n\r\n    // Get point at relative position in curve according to arc length\r\n\r\n    // - u [0 .. 1]\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getPointAt\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} u - [description]\r\n     * @param {Phaser.Math.Vector2} [out] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */\r\n    getPointAt: function (u, out)\r\n    {\r\n        var t = this.getUtoTmapping(u);\r\n\r\n        return this.getPoint(t, out);\r\n    },\r\n\r\n    // Get sequence of points using getPoint( t )\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [divisions] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2[]} [description]\r\n     */\r\n    getPoints: function (divisions)\r\n    {\r\n        if (divisions === undefined) { divisions = this.defaultDivisions; }\r\n\r\n        var points = [];\r\n\r\n        for (var d = 0; d <= divisions; d++)\r\n        {\r\n            points.push(this.getPoint(d / divisions));\r\n        }\r\n\r\n        return points;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getRandomPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */\r\n    getRandomPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        return this.getPoint(Math.random(), out);\r\n    },\r\n\r\n    // Get sequence of points using getPointAt( u )\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getSpacedPoints\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} [divisions] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2[]} [description]\r\n     */\r\n    getSpacedPoints: function (divisions)\r\n    {\r\n        if (divisions === undefined) { divisions = this.defaultDivisions; }\r\n\r\n        var points = [];\r\n\r\n        for (var d = 0; d <= divisions; d++)\r\n        {\r\n            var t = this.getUtoTmapping(d / divisions, null, divisions);\r\n\r\n            points.push(this.getPoint(t));\r\n        }\r\n\r\n        return points;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getStartPoint\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {Phaser.Math.Vector2} [out] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */\r\n    getStartPoint: function (out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        return this.getPointAt(0, out);\r\n    },\r\n\r\n    // Returns a unit vector tangent at t\r\n    // In case any sub curve does not implement its tangent derivation,\r\n    // 2 points a small delta apart will be used to find its gradient\r\n    // which seems to give a reasonable approximation\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getTangent\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} t - [description]\r\n     * @param {Phaser.Math.Vector2} [out] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} Vector approximating the tangent line at the point t (delta +/- 0.0001)\r\n     */\r\n    getTangent: function (t, out)\r\n    {\r\n        if (out === undefined) { out = new Vector2(); }\r\n\r\n        var delta = 0.0001;\r\n        var t1 = t - delta;\r\n        var t2 = t + delta;\r\n\r\n        // Capping in case of danger\r\n\r\n        if (t1 < 0)\r\n        {\r\n            t1 = 0;\r\n        }\r\n\r\n        if (t2 > 1)\r\n        {\r\n            t2 = 1;\r\n        }\r\n\r\n        this.getPoint(t1, this._tmpVec2A);\r\n        this.getPoint(t2, out);\r\n\r\n        return out.subtract(this._tmpVec2A).normalize();\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getTangentAt\r\n     * @since 3.0.0\r\n     *\r\n     * @generic {Phaser.Math.Vector2} O - [out,$return]\r\n     *\r\n     * @param {number} u - [description]\r\n     * @param {Phaser.Math.Vector2} [out] - [description]\r\n     *\r\n     * @return {Phaser.Math.Vector2} [description]\r\n     */\r\n    getTangentAt: function (u, out)\r\n    {\r\n        var t = this.getUtoTmapping(u);\r\n\r\n        return this.getTangent(t, out);\r\n    },\r\n\r\n    //  Given a distance in pixels, get a t to find p.\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getTFromDistance\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} distance - [description]\r\n     * @param {integer} [divisions] - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */\r\n    getTFromDistance: function (distance, divisions)\r\n    {\r\n        if (distance <= 0)\r\n        {\r\n            return 0;\r\n        }\r\n\r\n        return this.getUtoTmapping(0, distance, divisions);\r\n    },\r\n\r\n    // Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#getUtoTmapping\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} u - [description]\r\n     * @param {integer} distance - [description]\r\n     * @param {integer} [divisions] - [description]\r\n     *\r\n     * @return {number} [description]\r\n     */\r\n    getUtoTmapping: function (u, distance, divisions)\r\n    {\r\n        var arcLengths = this.getLengths(divisions);\r\n\r\n        var i = 0;\r\n        var il = arcLengths.length;\r\n\r\n        var targetArcLength; // The targeted u distance value to get\r\n\r\n        if (distance)\r\n        {\r\n            //  Cannot overshoot the curve\r\n            targetArcLength = Math.min(distance, arcLengths[il - 1]);\r\n        }\r\n        else\r\n        {\r\n            targetArcLength = u * arcLengths[il - 1];\r\n        }\r\n\r\n        // binary search for the index with largest value smaller than target u distance\r\n\r\n        var low = 0;\r\n        var high = il - 1;\r\n        var comparison;\r\n\r\n        while (low <= high)\r\n        {\r\n            i = Math.floor(low + (high - low) / 2); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats\r\n\r\n            comparison = arcLengths[i] - targetArcLength;\r\n\r\n            if (comparison < 0)\r\n            {\r\n                low = i + 1;\r\n            }\r\n            else if (comparison > 0)\r\n            {\r\n                high = i - 1;\r\n            }\r\n            else\r\n            {\r\n                high = i;\r\n                break;\r\n            }\r\n        }\r\n\r\n        i = high;\r\n\r\n        if (arcLengths[i] === targetArcLength)\r\n        {\r\n            return i / (il - 1);\r\n        }\r\n\r\n        // we could get finer grain at lengths, or use simple interpolation between two points\r\n\r\n        var lengthBefore = arcLengths[i];\r\n        var lengthAfter = arcLengths[i + 1];\r\n\r\n        var segmentLength = lengthAfter - lengthBefore;\r\n\r\n        // determine where we are between the 'before' and 'after' points\r\n\r\n        var segmentFraction = (targetArcLength - lengthBefore) / segmentLength;\r\n\r\n        // add that fractional amount to t\r\n\r\n        return (i + segmentFraction) / (il - 1);\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Curves.Curve#updateArcLengths\r\n     * @since 3.0.0\r\n     */\r\n    updateArcLengths: function ()\r\n    {\r\n        this.needsUpdate = true;\r\n\r\n        this.getLengths();\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Curve;\r\n"},"sourceMaps":null,"error":null,"hash":"85a66f3716e67613c878f0c5404a35e0","cacheData":{"env":{}}}