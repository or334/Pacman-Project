{"id":"../../node_modules/phaser/src/renderer/webgl/WebGLRenderer.js","dependencies":[{"name":"C:\\Users\\דור\\Desktop\\pmm\\package.json","includedInParent":true,"mtime":1560952935180},{"name":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\package.json","includedInParent":true,"mtime":1561396619369},{"name":"../../cameras/2d/BaseCamera","loc":{"line":8,"column":25},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\webgl\\WebGLRenderer.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\cameras\\2d\\BaseCamera.js"},{"name":"../../cameras/2d/events","loc":{"line":9,"column":27},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\webgl\\WebGLRenderer.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\cameras\\2d\\events\\index.js"},{"name":"../../utils/Class","loc":{"line":10,"column":20},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\webgl\\WebGLRenderer.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\Class.js"},{"name":"../../const","loc":{"line":11,"column":20},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\webgl\\WebGLRenderer.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\const.js"},{"name":"../../math/pow2/IsSizePowerOfTwo","loc":{"line":12,"column":31},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\webgl\\WebGLRenderer.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\math\\pow2\\IsSizePowerOfTwo.js"},{"name":"../../utils/array/SpliceOne","loc":{"line":13,"column":24},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\webgl\\WebGLRenderer.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\array\\SpliceOne.js"},{"name":"../../textures/events","loc":{"line":14,"column":28},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\webgl\\WebGLRenderer.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\textures\\events\\index.js"},{"name":"../../gameobjects/components/TransformMatrix","loc":{"line":15,"column":30},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\webgl\\WebGLRenderer.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\components\\TransformMatrix.js"},{"name":"./Utils","loc":{"line":16,"column":20},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\webgl\\WebGLRenderer.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\webgl\\Utils.js"},{"name":"../snapshot/WebGLSnapshot","loc":{"line":17,"column":28},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\webgl\\WebGLRenderer.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\snapshot\\WebGLSnapshot.js"},{"name":"./pipelines/BitmapMaskPipeline","loc":{"line":20,"column":33},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\webgl\\WebGLRenderer.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\webgl\\pipelines\\BitmapMaskPipeline.js"},{"name":"./pipelines/ForwardDiffuseLightPipeline","loc":{"line":21,"column":42},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\webgl\\WebGLRenderer.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\webgl\\pipelines\\ForwardDiffuseLightPipeline.js"},{"name":"./pipelines/TextureTintPipeline","loc":{"line":22,"column":34},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\webgl\\WebGLRenderer.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\webgl\\pipelines\\TextureTintPipeline.js"}],"generated":{"js":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BaseCamera = require('../../cameras/2d/BaseCamera');\r\nvar CameraEvents = require('../../cameras/2d/events');\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../../const');\r\nvar IsSizePowerOfTwo = require('../../math/pow2/IsSizePowerOfTwo');\r\nvar SpliceOne = require('../../utils/array/SpliceOne');\r\nvar TextureEvents = require('../../textures/events');\r\nvar TransformMatrix = require('../../gameobjects/components/TransformMatrix');\r\nvar Utils = require('./Utils');\r\nvar WebGLSnapshot = require('../snapshot/WebGLSnapshot');\r\n\r\n//  Default Pipelines\r\nvar BitmapMaskPipeline = require('./pipelines/BitmapMaskPipeline');\r\nvar ForwardDiffuseLightPipeline = require('./pipelines/ForwardDiffuseLightPipeline');\r\nvar TextureTintPipeline = require('./pipelines/TextureTintPipeline');\r\n\r\n/**\r\n * @callback WebGLContextCallback\r\n *\r\n * @param {Phaser.Renderer.WebGL.WebGLRenderer} renderer - The WebGL Renderer which owns the context.\r\n */\r\n\r\n/**\r\n * @classdesc\r\n * WebGLRenderer is a class that contains the needed functionality to keep the\r\n * WebGLRenderingContext state clean. The main idea of the WebGLRenderer is to keep track of\r\n * any context change that happens for WebGL rendering inside of Phaser. This means\r\n * if raw webgl functions are called outside the WebGLRenderer of the Phaser WebGL\r\n * rendering ecosystem they might pollute the current WebGLRenderingContext state producing\r\n * unexpected behavior. It's recommended that WebGL interaction is done through\r\n * WebGLRenderer and/or WebGLPipeline.\r\n *\r\n * @class WebGLRenderer\r\n * @memberof Phaser.Renderer.WebGL\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Game instance which owns this WebGL Renderer.\r\n */\r\nvar WebGLRenderer = new Class({\r\n\r\n    initialize:\r\n\r\n    function WebGLRenderer (game)\r\n    {\r\n        // eslint-disable-next-line consistent-this\r\n        var renderer = this;\r\n\r\n        var gameConfig = game.config;\r\n\r\n        var contextCreationConfig = {\r\n            alpha: gameConfig.transparent,\r\n            depth: false,\r\n            antialias: gameConfig.antialias,\r\n            premultipliedAlpha: gameConfig.premultipliedAlpha,\r\n            stencil: true,\r\n            failIfMajorPerformanceCaveat: gameConfig.failIfMajorPerformanceCaveat,\r\n            powerPreference: gameConfig.powerPreference\r\n        };\r\n\r\n        /**\r\n         * The local configuration settings of this WebGL Renderer.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#config\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.config = {\r\n            clearBeforeRender: gameConfig.clearBeforeRender,\r\n            antialias: gameConfig.antialias,\r\n            backgroundColor: gameConfig.backgroundColor,\r\n            contextCreation: contextCreationConfig,\r\n            resolution: gameConfig.resolution,\r\n            roundPixels: gameConfig.roundPixels,\r\n            maxTextures: gameConfig.maxTextures,\r\n            maxTextureSize: gameConfig.maxTextureSize,\r\n            batchSize: gameConfig.batchSize,\r\n            maxLights: gameConfig.maxLights\r\n        };\r\n\r\n        /**\r\n         * The Game instance which owns this WebGL Renderer.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */\r\n        this.game = game;\r\n\r\n        /**\r\n         * A constant which allows the renderer to be easily identified as a WebGL Renderer.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#type\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.type = CONST.WEBGL;\r\n\r\n        /**\r\n         * The width of the canvas being rendered to.\r\n         * This is populated in the onResize event handler.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#width\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = 0;\r\n\r\n        /**\r\n         * The height of the canvas being rendered to.\r\n         * This is populated in the onResize event handler.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#height\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = 0;\r\n\r\n        /**\r\n         * The canvas which this WebGL Renderer draws to.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#canvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.0.0\r\n         */\r\n        this.canvas = game.canvas;\r\n\r\n        /**\r\n         * An array of functions to invoke if the WebGL context is lost.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#lostContextCallbacks\r\n         * @type {WebGLContextCallback[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.lostContextCallbacks = [];\r\n\r\n        /**\r\n         * An array of functions to invoke if the WebGL context is restored.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#restoredContextCallbacks\r\n         * @type {WebGLContextCallback[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.restoredContextCallbacks = [];\r\n\r\n        /**\r\n         * An array of blend modes supported by the WebGL Renderer.\r\n         * \r\n         * This array includes the default blend modes as well as any custom blend modes added through {@link #addBlendMode}.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#blendModes\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.blendModes = [];\r\n\r\n        /**\r\n         * Keeps track of any WebGLTexture created with the current WebGLRenderingContext\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#nativeTextures\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.nativeTextures = [];\r\n\r\n        /**\r\n         * Set to `true` if the WebGL context of the renderer is lost.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#contextLost\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.contextLost = false;\r\n\r\n        /**\r\n         * This object will store all pipelines created through addPipeline\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#pipelines\r\n         * @type {object}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.pipelines = null;\r\n\r\n        /**\r\n         * Details about the currently scheduled snapshot.\r\n         * \r\n         * If a non-null `callback` is set in this object, a snapshot of the canvas will be taken after the current frame is fully rendered.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#snapshotState\r\n         * @type {Phaser.Types.Renderer.Snapshot.SnapshotState}\r\n         * @since 3.0.0\r\n         */\r\n        this.snapshotState = {\r\n            x: 0,\r\n            y: 0,\r\n            width: 1,\r\n            height: 1,\r\n            getPixel: false,\r\n            callback: null,\r\n            type: 'image/png',\r\n            encoder: 0.92\r\n        };\r\n\r\n        // Internal Renderer State (Textures, Framebuffers, Pipelines, Buffers, etc)\r\n\r\n        /**\r\n         * Cached value for the last texture unit that was used\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentActiveTextureUnit\r\n         * @type {integer}\r\n         * @since 3.1.0\r\n         */\r\n        this.currentActiveTextureUnit = 0;\r\n\r\n        /**\r\n         * An array of the last texture handles that were bound to the WebGLRenderingContext\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentTextures\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.currentTextures = new Array(16);\r\n\r\n        /**\r\n         * Current framebuffer in use\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentFramebuffer\r\n         * @type {WebGLFramebuffer}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.currentFramebuffer = null;\r\n\r\n        /**\r\n         * Current WebGLPipeline in use\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentPipeline\r\n         * @type {Phaser.Renderer.WebGL.WebGLPipeline}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.currentPipeline = null;\r\n\r\n        /**\r\n         * Current WebGLProgram in use\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentProgram\r\n         * @type {WebGLProgram}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.currentProgram = null;\r\n\r\n        /**\r\n         * Current WebGLBuffer (Vertex buffer) in use\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentVertexBuffer\r\n         * @type {WebGLBuffer}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.currentVertexBuffer = null;\r\n\r\n        /**\r\n         * Current WebGLBuffer (Index buffer) in use\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentIndexBuffer\r\n         * @type {WebGLBuffer}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.currentIndexBuffer = null;\r\n\r\n        /**\r\n         * Current blend mode in use\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentBlendMode\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.currentBlendMode = Infinity;\r\n\r\n        /**\r\n         * Indicates if the the scissor state is enabled in WebGLRenderingContext\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentScissorEnabled\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.currentScissorEnabled = false;\r\n\r\n        /**\r\n         * Stores the current scissor data\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentScissor\r\n         * @type {Uint32Array}\r\n         * @since 3.0.0\r\n         */\r\n        // this.currentScissor = new Uint32Array([ 0, 0, this.width, this.height ]);\r\n        this.currentScissor = null;\r\n\r\n        /**\r\n         * Stack of scissor data\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#scissorStack\r\n         * @type {Uint32Array}\r\n         * @since 3.0.0\r\n         */\r\n        this.scissorStack = [];\r\n\r\n        // Setup context lost and restore event listeners\r\n\r\n        this.canvas.addEventListener('webglcontextlost', function (event)\r\n        {\r\n            renderer.contextLost = true;\r\n            event.preventDefault();\r\n\r\n            for (var index = 0; index < renderer.lostContextCallbacks.length; ++index)\r\n            {\r\n                var callback = renderer.lostContextCallbacks[index];\r\n                callback[0].call(callback[1], renderer);\r\n            }\r\n        }, false);\r\n\r\n        this.canvas.addEventListener('webglcontextrestored', function ()\r\n        {\r\n            renderer.contextLost = false;\r\n            renderer.init(renderer.config);\r\n            for (var index = 0; index < renderer.restoredContextCallbacks.length; ++index)\r\n            {\r\n                var callback = renderer.restoredContextCallbacks[index];\r\n                callback[0].call(callback[1], renderer);\r\n            }\r\n        }, false);\r\n\r\n        // These are initialized post context creation\r\n\r\n        /**\r\n         * The underlying WebGL context of the renderer.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#gl\r\n         * @type {WebGLRenderingContext}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.gl = null;\r\n\r\n        /**\r\n         * Array of strings that indicate which WebGL extensions are supported by the browser\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#supportedExtensions\r\n         * @type {object}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.supportedExtensions = null;\r\n\r\n        /**\r\n         * Extensions loaded into the current context\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#extensions\r\n         * @type {object}\r\n         * @default {}\r\n         * @since 3.0.0\r\n         */\r\n        this.extensions = {};\r\n\r\n        /**\r\n         * Stores the current WebGL component formats for further use\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#glFormats\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.2.0\r\n         */\r\n        this.glFormats = [];\r\n\r\n        /**\r\n         * Stores the supported WebGL texture compression formats.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#compression\r\n         * @type {array}\r\n         * @since 3.8.0\r\n         */\r\n        this.compression = {\r\n            ETC1: false,\r\n            PVRTC: false,\r\n            S3TC: false\r\n        };\r\n\r\n        /**\r\n         * Cached drawing buffer height to reduce gl calls.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#drawingBufferHeight\r\n         * @type {number}\r\n         * @readonly\r\n         * @since 3.11.0\r\n         */\r\n        this.drawingBufferHeight = 0;\r\n\r\n        /**\r\n         * A blank 32x32 transparent texture, as used by the Graphics system where needed.\r\n         * This is set in the `boot` method.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#blankTexture\r\n         * @type {WebGLTexture}\r\n         * @readonly\r\n         * @since 3.12.0\r\n         */\r\n        this.blankTexture = null;\r\n\r\n        /**\r\n         * A default Camera used in calls when no other camera has been provided.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#defaultCamera\r\n         * @type {Phaser.Cameras.Scene2D.BaseCamera}\r\n         * @since 3.12.0\r\n         */\r\n        this.defaultCamera = new BaseCamera(0, 0, 0, 0);\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#_tempMatrix1\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.12.0\r\n         */\r\n        this._tempMatrix1 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#_tempMatrix2\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.12.0\r\n         */\r\n        this._tempMatrix2 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#_tempMatrix3\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.12.0\r\n         */\r\n        this._tempMatrix3 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#_tempMatrix4\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.12.0\r\n         */\r\n        this._tempMatrix4 = new TransformMatrix();\r\n\r\n        /**\r\n         * The total number of masks currently stacked.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#maskCount\r\n         * @type {integer}\r\n         * @since 3.17.0\r\n         */\r\n        this.maskCount = 0;\r\n\r\n        /**\r\n         * The mask stack.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#maskStack\r\n         * @type {Phaser.Display.Masks.GeometryMask[]}\r\n         * @since 3.17.0\r\n         */\r\n        this.maskStack = [];\r\n\r\n        /**\r\n         * Internal property that tracks the currently set mask.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentMask\r\n         * @type {any}\r\n         * @since 3.17.0\r\n         */\r\n        this.currentMask = { mask: null, camera: null };\r\n\r\n        /**\r\n         * Internal property that tracks the currently set camera mask.\r\n         *\r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#currentCameraMask\r\n         * @type {any}\r\n         * @since 3.17.0\r\n         */\r\n        this.currentCameraMask = { mask: null, camera: null };\r\n\r\n        /**\r\n         * Internal gl function mapping for uniform look-up.\r\n         * https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/uniform\r\n         * \r\n         * @name Phaser.Renderer.WebGL.WebGLRenderer#glFuncMap\r\n         * @type {any}\r\n         * @since 3.17.0\r\n         */\r\n        this.glFuncMap = null;\r\n\r\n        this.init(this.config);\r\n    },\r\n\r\n    /**\r\n     * Creates a new WebGLRenderingContext and initializes all internal state.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#init\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} config - The configuration object for the renderer.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    init: function (config)\r\n    {\r\n        var gl;\r\n        var game = this.game;\r\n        var canvas = this.canvas;\r\n        var clearColor = config.backgroundColor;\r\n\r\n        //  Did they provide their own context?\r\n        if (game.config.context)\r\n        {\r\n            gl = game.config.context;\r\n        }\r\n        else\r\n        {\r\n            gl = canvas.getContext('webgl', config.contextCreation) || canvas.getContext('experimental-webgl', config.contextCreation);\r\n        }\r\n\r\n        if (!gl || gl.isContextLost())\r\n        {\r\n            this.contextLost = true;\r\n\r\n            throw new Error('WebGL unsupported');\r\n        }\r\n\r\n        this.gl = gl;\r\n\r\n        //  Set it back into the Game, so developers can access it from there too\r\n        game.context = gl;\r\n\r\n        for (var i = 0; i <= 27; i++)\r\n        {\r\n            this.blendModes.push({ func: [ gl.ONE, gl.ONE_MINUS_SRC_ALPHA ], equation: gl.FUNC_ADD });\r\n        }\r\n\r\n        //  ADD\r\n        this.blendModes[1].func = [ gl.ONE, gl.DST_ALPHA ];\r\n\r\n        //  MULTIPLY\r\n        this.blendModes[2].func = [ gl.DST_COLOR, gl.ONE_MINUS_SRC_ALPHA ];\r\n\r\n        //  SCREEN\r\n        this.blendModes[3].func = [ gl.ONE, gl.ONE_MINUS_SRC_COLOR ];\r\n\r\n        //  ERASE\r\n        this.blendModes[17] = { func: [ gl.ZERO, gl.ONE_MINUS_SRC_ALPHA ], equation: gl.FUNC_REVERSE_SUBTRACT };\r\n\r\n        this.glFormats[0] = gl.BYTE;\r\n        this.glFormats[1] = gl.SHORT;\r\n        this.glFormats[2] = gl.UNSIGNED_BYTE;\r\n        this.glFormats[3] = gl.UNSIGNED_SHORT;\r\n        this.glFormats[4] = gl.FLOAT;\r\n\r\n        //  Set the gl function map\r\n        this.glFuncMap = {\r\n\r\n            mat2: { func: gl.uniformMatrix2fv, length: 1, matrix: true },\r\n            mat3: { func: gl.uniformMatrix3fv, length: 1, matrix: true },\r\n            mat4: { func: gl.uniformMatrix4fv, length: 1, matrix: true },\r\n\r\n            '1f': { func: gl.uniform1f, length: 1 },\r\n            '1fv': { func: gl.uniform1fv, length: 1 },\r\n            '1i': { func: gl.uniform1i, length: 1 },\r\n            '1iv': { func: gl.uniform1iv, length: 1 },\r\n\r\n            '2f': { func: gl.uniform2f, length: 2 },\r\n            '2fv': { func: gl.uniform2fv, length: 1 },\r\n            '2i': { func: gl.uniform2i, length: 2 },\r\n            '2iv': { func: gl.uniform2iv, length: 1 },\r\n\r\n            '3f': { func: gl.uniform3f, length: 3 },\r\n            '3fv': { func: gl.uniform3fv, length: 1 },\r\n            '3i': { func: gl.uniform3i, length: 3 },\r\n            '3iv': { func: gl.uniform3iv, length: 1 },\r\n\r\n            '4f': { func: gl.uniform4f, length: 4 },\r\n            '4fv': { func: gl.uniform4fv, length: 1 },\r\n            '4i': { func: gl.uniform4i, length: 4 },\r\n            '4iv': { func: gl.uniform4iv, length: 1 }\r\n\r\n        };\r\n\r\n        // Load supported extensions\r\n        var exts = gl.getSupportedExtensions();\r\n\r\n        if (!config.maxTextures)\r\n        {\r\n            config.maxTextures = gl.getParameter(gl.MAX_TEXTURE_IMAGE_UNITS);\r\n        }\r\n\r\n        if (!config.maxTextureSize)\r\n        {\r\n            config.maxTextureSize = gl.getParameter(gl.MAX_TEXTURE_SIZE);\r\n        }\r\n\r\n        var extString = 'WEBGL_compressed_texture_';\r\n        var wkExtString = 'WEBKIT_' + extString;\r\n\r\n        this.compression.ETC1 = gl.getExtension(extString + 'etc1') || gl.getExtension(wkExtString + 'etc1');\r\n        this.compression.PVRTC = gl.getExtension(extString + 'pvrtc') || gl.getExtension(wkExtString + 'pvrtc');\r\n        this.compression.S3TC = gl.getExtension(extString + 's3tc') || gl.getExtension(wkExtString + 's3tc');\r\n\r\n        this.supportedExtensions = exts;\r\n\r\n        //  Setup initial WebGL state\r\n        gl.disable(gl.DEPTH_TEST);\r\n        gl.disable(gl.CULL_FACE);\r\n\r\n        gl.enable(gl.BLEND);\r\n\r\n        gl.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL);\r\n\r\n        // Initialize all textures to null\r\n        for (var index = 0; index < this.currentTextures.length; ++index)\r\n        {\r\n            this.currentTextures[index] = null;\r\n        }\r\n\r\n        // Clear previous pipelines and reload default ones\r\n        this.pipelines = {};\r\n\r\n        this.addPipeline('TextureTintPipeline', new TextureTintPipeline({ game: game, renderer: this }));\r\n        this.addPipeline('BitmapMaskPipeline', new BitmapMaskPipeline({ game: game, renderer: this }));\r\n        this.addPipeline('Light2D', new ForwardDiffuseLightPipeline({ game: game, renderer: this, maxLights: config.maxLights }));\r\n\r\n        this.setBlendMode(CONST.BlendModes.NORMAL);\r\n\r\n        game.textures.once(TextureEvents.READY, this.boot, this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal boot handler. Calls 'boot' on each pipeline.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#boot\r\n     * @private\r\n     * @since 3.11.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        for (var pipelineName in this.pipelines)\r\n        {\r\n            this.pipelines[pipelineName].boot();\r\n        }\r\n\r\n        var blank = this.game.textures.getFrame('__DEFAULT');\r\n\r\n        this.pipelines.TextureTintPipeline.currentFrame = blank;\r\n\r\n        this.blankTexture = blank;\r\n\r\n        var gl = this.gl;\r\n\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n\r\n        gl.enable(gl.SCISSOR_TEST);\r\n\r\n        this.setPipeline(this.pipelines.TextureTintPipeline);\r\n\r\n        this.game.scale.on('resize', this.onResize, this);\r\n\r\n        var baseSize = this.game.scale.baseSize;\r\n\r\n        this.resize(baseSize.width, baseSize.height, this.game.scale.resolution);\r\n    },\r\n\r\n    /**\r\n     * The event handler that manages the `resize` event dispatched by the Scale Manager.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#onResize\r\n     * @since 3.16.0\r\n     *\r\n     * @param {Phaser.Structs.Size} gameSize - The default Game Size object. This is the un-modified game dimensions.\r\n     * @param {Phaser.Structs.Size} baseSize - The base Size object. The game dimensions multiplied by the resolution. The canvas width / height values match this.\r\n     * @param {Phaser.Structs.Size} displaySize - The display Size object. The size of the canvas style width / height attributes.\r\n     * @param {number} [resolution] - The Scale Manager resolution setting.\r\n     */\r\n    onResize: function (gameSize, baseSize, displaySize, resolution)\r\n    {\r\n        //  Has the underlying canvas size changed?\r\n        if (baseSize.width !== this.width || baseSize.height !== this.height || resolution !== this.resolution)\r\n        {\r\n            this.resize(baseSize.width, baseSize.height, resolution);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Resizes the drawing buffer to match that required by the Scale Manager.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#resize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [width] - The new width of the renderer.\r\n     * @param {number} [height] - The new height of the renderer.\r\n     * @param {number} [resolution] - The new resolution of the renderer.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    resize: function (width, height, resolution)\r\n    {\r\n        var gl = this.gl;\r\n        var pipelines = this.pipelines;\r\n\r\n        this.width = width;\r\n        this.height = height;\r\n        this.resolution = resolution;\r\n\r\n        gl.viewport(0, 0, width, height);\r\n\r\n        //  Update all registered pipelines\r\n        for (var pipelineName in pipelines)\r\n        {\r\n            pipelines[pipelineName].resize(width, height, resolution);\r\n        }\r\n\r\n        this.drawingBufferHeight = gl.drawingBufferHeight;\r\n\r\n        gl.scissor(0, (gl.drawingBufferHeight - height), width, height);\r\n\r\n        this.defaultCamera.setSize(width, height);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a callback to be invoked when the WebGL context has been restored by the browser.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#onContextRestored\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLContextCallback} callback - The callback to be invoked on context restoration.\r\n     * @param {object} target - The context of the callback.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    onContextRestored: function (callback, target)\r\n    {\r\n        this.restoredContextCallbacks.push([ callback, target ]);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a callback to be invoked when the WebGL context has been lost by the browser.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#onContextLost\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLContextCallback} callback - The callback to be invoked on context loss.\r\n     * @param {object} target - The context of the callback.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    onContextLost: function (callback, target)\r\n    {\r\n        this.lostContextCallbacks.push([ callback, target ]);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Checks if a WebGL extension is supported\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#hasExtension\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} extensionName - Name of the WebGL extension\r\n     *\r\n     * @return {boolean} `true` if the extension is supported, otherwise `false`.\r\n     */\r\n    hasExtension: function (extensionName)\r\n    {\r\n        return this.supportedExtensions ? this.supportedExtensions.indexOf(extensionName) : false;\r\n    },\r\n\r\n    /**\r\n     * Loads a WebGL extension\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#getExtension\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} extensionName - The name of the extension to load.\r\n     *\r\n     * @return {object} WebGL extension if the extension is supported\r\n     */\r\n    getExtension: function (extensionName)\r\n    {\r\n        if (!this.hasExtension(extensionName)) { return null; }\r\n\r\n        if (!(extensionName in this.extensions))\r\n        {\r\n            this.extensions[extensionName] = this.gl.getExtension(extensionName);\r\n        }\r\n\r\n        return this.extensions[extensionName];\r\n    },\r\n\r\n    /**\r\n     * Flushes the current pipeline if the pipeline is bound\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#flush\r\n     * @since 3.0.0\r\n     */\r\n    flush: function ()\r\n    {\r\n        if (this.currentPipeline)\r\n        {\r\n            this.currentPipeline.flush();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Checks if a pipeline is present in the current WebGLRenderer\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#hasPipeline\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} pipelineName - The name of the pipeline.\r\n     *\r\n     * @return {boolean} `true` if the given pipeline is loaded, otherwise `false`.\r\n     */\r\n    hasPipeline: function (pipelineName)\r\n    {\r\n        return (pipelineName in this.pipelines);\r\n    },\r\n\r\n    /**\r\n     * Returns the pipeline by name if the pipeline exists\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#getPipeline\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} pipelineName - The name of the pipeline.\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} The pipeline instance, or `null` if not found.\r\n     */\r\n    getPipeline: function (pipelineName)\r\n    {\r\n        return (this.hasPipeline(pipelineName)) ? this.pipelines[pipelineName] : null;\r\n    },\r\n\r\n    /**\r\n     * Removes a pipeline by name.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#removePipeline\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} pipelineName - The name of the pipeline to be removed.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    removePipeline: function (pipelineName)\r\n    {\r\n        delete this.pipelines[pipelineName];\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Adds a pipeline instance into the collection of pipelines\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#addPipeline\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} pipelineName - A unique string-based key for the pipeline.\r\n     * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipelineInstance - A pipeline instance which must extend WebGLPipeline.\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} The pipeline instance that was passed.\r\n     */\r\n    addPipeline: function (pipelineName, pipelineInstance)\r\n    {\r\n        if (!this.hasPipeline(pipelineName))\r\n        {\r\n            this.pipelines[pipelineName] = pipelineInstance;\r\n        }\r\n        else\r\n        {\r\n            console.warn('Pipeline exists: ' + pipelineName);\r\n        }\r\n\r\n        pipelineInstance.name = pipelineName;\r\n\r\n        this.pipelines[pipelineName].resize(this.width, this.height, this.config.resolution);\r\n\r\n        return pipelineInstance;\r\n    },\r\n\r\n    /**\r\n     * Pushes a new scissor state. This is used to set nested scissor states.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#pushScissor\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} x - The x position of the scissor.\r\n     * @param {integer} y - The y position of the scissor.\r\n     * @param {integer} width - The width of the scissor.\r\n     * @param {integer} height - The height of the scissor.\r\n     * @param {integer} [drawingBufferHeight] - Optional drawingBufferHeight override value.\r\n     *\r\n     * @return {integer[]} An array containing the scissor values.\r\n     */\r\n    pushScissor: function (x, y, width, height, drawingBufferHeight)\r\n    {\r\n        if (drawingBufferHeight === undefined) { drawingBufferHeight = this.drawingBufferHeight; }\r\n\r\n        var scissorStack = this.scissorStack;\r\n\r\n        var scissor = [ x, y, width, height ];\r\n\r\n        scissorStack.push(scissor);\r\n\r\n        this.setScissor(x, y, width, height, drawingBufferHeight);\r\n\r\n        this.currentScissor = scissor;\r\n\r\n        return scissor;\r\n    },\r\n\r\n    /**\r\n     * Sets the current scissor state.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setScissor\r\n     * @since 3.0.0\r\n     * \r\n     * @param {integer} x - The x position of the scissor.\r\n     * @param {integer} y - The y position of the scissor.\r\n     * @param {integer} width - The width of the scissor.\r\n     * @param {integer} height - The height of the scissor.\r\n     * @param {integer} [drawingBufferHeight] - Optional drawingBufferHeight override value.\r\n     */\r\n    setScissor: function (x, y, width, height, drawingBufferHeight)\r\n    {\r\n        var gl = this.gl;\r\n\r\n        var current = this.currentScissor;\r\n\r\n        var setScissor = (width > 0 && height > 0);\r\n\r\n        if (current && setScissor)\r\n        {\r\n            var cx = current[0];\r\n            var cy = current[1];\r\n            var cw = current[2];\r\n            var ch = current[3];\r\n\r\n            setScissor = (cx !== x || cy !== y || cw !== width || ch !== height);\r\n        }\r\n\r\n        if (setScissor)\r\n        {\r\n            this.flush();\r\n\r\n            // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/scissor\r\n            gl.scissor(x, (drawingBufferHeight - y - height), width, height);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Pops the last scissor state and sets it.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#popScissor\r\n     * @since 3.0.0\r\n     */\r\n    popScissor: function ()\r\n    {\r\n        var scissorStack = this.scissorStack;\r\n\r\n        //  Remove the current scissor\r\n        scissorStack.pop();\r\n\r\n        //  Reset the previous scissor\r\n        var scissor = scissorStack[scissorStack.length - 1];\r\n\r\n        if (scissor)\r\n        {\r\n            this.setScissor(scissor[0], scissor[1], scissor[2], scissor[3]);\r\n        }\r\n\r\n        this.currentScissor = scissor;\r\n    },\r\n\r\n    /**\r\n     * Binds a WebGLPipeline and sets it as the current pipeline to be used.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setPipeline\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipelineInstance - The pipeline instance to be activated.\r\n     * @param {Phaser.GameObjects.GameObject} [gameObject] - The Game Object that invoked this pipeline, if any.\r\n     *\r\n     * @return {Phaser.Renderer.WebGL.WebGLPipeline} The pipeline that was activated.\r\n     */\r\n    setPipeline: function (pipelineInstance, gameObject)\r\n    {\r\n        if (this.currentPipeline !== pipelineInstance ||\r\n            this.currentPipeline.vertexBuffer !== this.currentVertexBuffer ||\r\n            this.currentPipeline.program !== this.currentProgram)\r\n        {\r\n            this.flush();\r\n            this.currentPipeline = pipelineInstance;\r\n            this.currentPipeline.bind();\r\n        }\r\n\r\n        this.currentPipeline.onBind(gameObject);\r\n\r\n        return this.currentPipeline;\r\n    },\r\n\r\n    /**\r\n     * Is there an active stencil mask?\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#hasActiveStencilMask\r\n     * @since 3.17.0\r\n     * \r\n     * @return {boolean} `true` if there is an active stencil mask, otherwise `false`.\r\n     */\r\n    hasActiveStencilMask: function ()\r\n    {\r\n        var mask = this.currentMask.mask;\r\n        var camMask = this.currentCameraMask.mask;\r\n\r\n        return ((mask && mask.isStencil) || (camMask && camMask.isStencil));\r\n    },\r\n\r\n    /**\r\n     * Use this to reset the gl context to the state that Phaser requires to continue rendering.\r\n     * Calling this will:\r\n     * \r\n     * * Disable `DEPTH_TEST`, `CULL_FACE` and `STENCIL_TEST`.\r\n     * * Clear the depth buffer and stencil buffers.\r\n     * * Reset the viewport size.\r\n     * * Reset the blend mode.\r\n     * * Bind a blank texture as the active texture on texture unit zero.\r\n     * * Rebinds the given pipeline instance.\r\n     * \r\n     * You should call this having previously called `clearPipeline` and then wishing to return\r\n     * control to Phaser again.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#rebindPipeline\r\n     * @since 3.16.0\r\n     * \r\n     * @param {Phaser.Renderer.WebGL.WebGLPipeline} pipelineInstance - The pipeline instance to be activated.\r\n     */\r\n    rebindPipeline: function (pipelineInstance)\r\n    {\r\n        var gl = this.gl;\r\n\r\n        gl.disable(gl.DEPTH_TEST);\r\n        gl.disable(gl.CULL_FACE);\r\n\r\n        if (this.hasActiveStencilMask())\r\n        {\r\n            gl.clear(gl.DEPTH_BUFFER_BIT);\r\n        }\r\n        else\r\n        {\r\n            //  If there wasn't a stencil mask set before this call, we can disable it safely\r\n            gl.disable(gl.STENCIL_TEST);\r\n            gl.clear(gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\r\n        }\r\n\r\n        gl.viewport(0, 0, this.width, this.height);\r\n\r\n        this.setBlendMode(0, true);\r\n\r\n        gl.activeTexture(gl.TEXTURE0);\r\n        gl.bindTexture(gl.TEXTURE_2D, this.blankTexture.glTexture);\r\n\r\n        this.currentActiveTextureUnit = 0;\r\n        this.currentTextures[0] = this.blankTexture.glTexture;\r\n\r\n        this.currentPipeline = pipelineInstance;\r\n        this.currentPipeline.bind();\r\n        this.currentPipeline.onBind();\r\n    },\r\n\r\n    /**\r\n     * Flushes the current WebGLPipeline being used and then clears it, along with the\r\n     * the current shader program and vertex buffer. Then resets the blend mode to NORMAL.\r\n     * Call this before jumping to your own gl context handler, and then call `rebindPipeline` when\r\n     * you wish to return control to Phaser again.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#clearPipeline\r\n     * @since 3.16.0\r\n     */\r\n    clearPipeline: function ()\r\n    {\r\n        this.flush();\r\n\r\n        this.currentPipeline = null;\r\n        this.currentProgram = null;\r\n        this.currentVertexBuffer = null;\r\n        this.currentIndexBuffer = null;\r\n\r\n        this.setBlendMode(0, true);\r\n    },\r\n\r\n    /**\r\n     * Sets the blend mode to the value given.\r\n     *\r\n     * If the current blend mode is different from the one given, the pipeline is flushed and the new\r\n     * blend mode is enabled.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setBlendMode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} blendModeId - The blend mode to be set. Can be a `BlendModes` const or an integer value.\r\n     * @param {boolean} [force=false] - Force the blend mode to be set, regardless of the currently set blend mode.\r\n     *\r\n     * @return {boolean} `true` if the blend mode was changed as a result of this call, forcing a flush, otherwise `false`.\r\n     */\r\n    setBlendMode: function (blendModeId, force)\r\n    {\r\n        if (force === undefined) { force = false; }\r\n\r\n        var gl = this.gl;\r\n        var blendMode = this.blendModes[blendModeId];\r\n\r\n        if (force || (blendModeId !== CONST.BlendModes.SKIP_CHECK && this.currentBlendMode !== blendModeId))\r\n        {\r\n            this.flush();\r\n\r\n            gl.enable(gl.BLEND);\r\n            gl.blendEquation(blendMode.equation);\r\n\r\n            if (blendMode.func.length > 2)\r\n            {\r\n                gl.blendFuncSeparate(blendMode.func[0], blendMode.func[1], blendMode.func[2], blendMode.func[3]);\r\n            }\r\n            else\r\n            {\r\n                gl.blendFunc(blendMode.func[0], blendMode.func[1]);\r\n            }\r\n\r\n            this.currentBlendMode = blendModeId;\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Creates a new custom blend mode for the renderer.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#addBlendMode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} func - An array containing the WebGL functions to use for the source and the destination blending factors, respectively. See the possible constants for {@link WebGLRenderingContext#blendFunc()}.\r\n     * @param {function} equation - The equation to use for combining the RGB and alpha components of a new pixel with a rendered one. See the possible constants for {@link WebGLRenderingContext#blendEquation()}.\r\n     *\r\n     * @return {integer} The index of the new blend mode, used for referencing it in the future.\r\n     */\r\n    addBlendMode: function (func, equation)\r\n    {\r\n        var index = this.blendModes.push({ func: func, equation: equation });\r\n\r\n        return index - 1;\r\n    },\r\n\r\n    /**\r\n     * Updates the function bound to a given custom blend mode.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#updateBlendMode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - The index of the custom blend mode.\r\n     * @param {function} func - The function to use for the blend mode.\r\n     * @param {function} equation - The equation to use for the blend mode.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    updateBlendMode: function (index, func, equation)\r\n    {\r\n        if (this.blendModes[index])\r\n        {\r\n            this.blendModes[index].func = func;\r\n\r\n            if (equation)\r\n            {\r\n                this.blendModes[index].equation = equation;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes a custom blend mode from the renderer.\r\n     * Any Game Objects still using this blend mode will error, so be sure to clear them first.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#removeBlendMode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - The index of the custom blend mode to be removed.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    removeBlendMode: function (index)\r\n    {\r\n        if (index > 17 && this.blendModes[index])\r\n        {\r\n            this.blendModes.splice(index, 1);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the current active texture for texture unit zero to be a blank texture.\r\n     * This only happens if there isn't a texture already in use by texture unit zero.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setBlankTexture\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {boolean} [force=false] - Force a blank texture set, regardless of what's already bound?\r\n     */\r\n    setBlankTexture: function (force)\r\n    {\r\n        if (force === undefined) { force = false; }\r\n\r\n        if (force || this.currentActiveTextureUnit !== 0 || !this.currentTextures[0])\r\n        {\r\n            this.setTexture2D(this.blankTexture.glTexture, 0);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Binds a texture at a texture unit. If a texture is already\r\n     * bound to that unit it will force a flush on the current pipeline.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setTexture2D\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLTexture} texture - The WebGL texture that needs to be bound.\r\n     * @param {integer} textureUnit - The texture unit to which the texture will be bound.\r\n     * @param {boolean} [flush=true] - Will the current pipeline be flushed if this is a new texture, or not?\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    setTexture2D: function (texture, textureUnit, flush)\r\n    {\r\n        if (flush === undefined) { flush = true; }\r\n\r\n        var gl = this.gl;\r\n\r\n        if (texture !== this.currentTextures[textureUnit])\r\n        {\r\n            if (flush)\r\n            {\r\n                this.flush();\r\n            }\r\n\r\n            if (this.currentActiveTextureUnit !== textureUnit)\r\n            {\r\n                gl.activeTexture(gl.TEXTURE0 + textureUnit);\r\n\r\n                this.currentActiveTextureUnit = textureUnit;\r\n            }\r\n\r\n            gl.bindTexture(gl.TEXTURE_2D, texture);\r\n\r\n            this.currentTextures[textureUnit] = texture;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Binds a framebuffer. If there was another framebuffer already bound it will force a pipeline flush.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFramebuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLFramebuffer} framebuffer - The framebuffer that needs to be bound.\r\n     * @param {boolean} [updateScissor=false] - If a framebuffer is given, set the gl scissor to match the frame buffer size? Or, if `null` given, pop the scissor from the stack.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    setFramebuffer: function (framebuffer, updateScissor)\r\n    {\r\n        if (updateScissor === undefined) { updateScissor = false; }\r\n\r\n        var gl = this.gl;\r\n\r\n        var width = this.width;\r\n        var height = this.height;\r\n\r\n        if (framebuffer !== this.currentFramebuffer)\r\n        {\r\n            if (framebuffer && framebuffer.renderTexture)\r\n            {\r\n                width = framebuffer.renderTexture.width;\r\n                height = framebuffer.renderTexture.height;\r\n            }\r\n            else\r\n            {\r\n                this.flush();\r\n            }\r\n\r\n            gl.bindFramebuffer(gl.FRAMEBUFFER, framebuffer);\r\n\r\n            gl.viewport(0, 0, width, height);\r\n\r\n            if (updateScissor)\r\n            {\r\n                if (framebuffer)\r\n                {\r\n                    this.drawingBufferHeight = height;\r\n\r\n                    this.pushScissor(0, 0, width, height);\r\n                }\r\n                else\r\n                {\r\n                    this.drawingBufferHeight = this.height;\r\n\r\n                    this.popScissor();\r\n                }\r\n            }\r\n\r\n            this.currentFramebuffer = framebuffer;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Binds a program. If there was another program already bound it will force a pipeline flush.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setProgram\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The program that needs to be bound.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    setProgram: function (program)\r\n    {\r\n        var gl = this.gl;\r\n\r\n        if (program !== this.currentProgram)\r\n        {\r\n            this.flush();\r\n\r\n            gl.useProgram(program);\r\n\r\n            this.currentProgram = program;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Bounds a vertex buffer. If there is a vertex buffer already bound it'll force a pipeline flush.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setVertexBuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLBuffer} vertexBuffer - The buffer that needs to be bound.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    setVertexBuffer: function (vertexBuffer)\r\n    {\r\n        var gl = this.gl;\r\n\r\n        if (vertexBuffer !== this.currentVertexBuffer)\r\n        {\r\n            this.flush();\r\n\r\n            gl.bindBuffer(gl.ARRAY_BUFFER, vertexBuffer);\r\n\r\n            this.currentVertexBuffer = vertexBuffer;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Bounds a index buffer. If there is a index buffer already bound it'll force a pipeline flush.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setIndexBuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLBuffer} indexBuffer - The buffer the needs to be bound.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    setIndexBuffer: function (indexBuffer)\r\n    {\r\n        var gl = this.gl;\r\n\r\n        if (indexBuffer !== this.currentIndexBuffer)\r\n        {\r\n            this.flush();\r\n\r\n            gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, indexBuffer);\r\n\r\n            this.currentIndexBuffer = indexBuffer;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a texture from an image source. If the source is not valid it creates an empty texture.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createTextureFromSource\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} source - The source of the texture.\r\n     * @param {integer} width - The width of the texture.\r\n     * @param {integer} height - The height of the texture.\r\n     * @param {integer} scaleMode - The scale mode to be used by the texture.\r\n     *\r\n     * @return {?WebGLTexture} The WebGL Texture that was created, or `null` if it couldn't be created.\r\n     */\r\n    createTextureFromSource: function (source, width, height, scaleMode)\r\n    {\r\n        var gl = this.gl;\r\n        var filter = gl.NEAREST;\r\n        var wrap = gl.CLAMP_TO_EDGE;\r\n        var texture = null;\r\n\r\n        width = source ? source.width : width;\r\n        height = source ? source.height : height;\r\n\r\n        if (IsSizePowerOfTwo(width, height))\r\n        {\r\n            wrap = gl.REPEAT;\r\n        }\r\n\r\n        if (scaleMode === CONST.ScaleModes.LINEAR && this.config.antialias)\r\n        {\r\n            filter = gl.LINEAR;\r\n        }\r\n\r\n        if (!source && typeof width === 'number' && typeof height === 'number')\r\n        {\r\n            texture = this.createTexture2D(0, filter, filter, wrap, wrap, gl.RGBA, null, width, height);\r\n        }\r\n        else\r\n        {\r\n            texture = this.createTexture2D(0, filter, filter, wrap, wrap, gl.RGBA, source);\r\n        }\r\n\r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * A wrapper for creating a WebGLTexture. If no pixel data is passed it will create an empty texture.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createTexture2D\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} mipLevel - Mip level of the texture.\r\n     * @param {integer} minFilter - Filtering of the texture.\r\n     * @param {integer} magFilter - Filtering of the texture.\r\n     * @param {integer} wrapT - Wrapping mode of the texture.\r\n     * @param {integer} wrapS - Wrapping mode of the texture.\r\n     * @param {integer} format - Which format does the texture use.\r\n     * @param {object} pixels - pixel data.\r\n     * @param {integer} width - Width of the texture in pixels.\r\n     * @param {integer} height - Height of the texture in pixels.\r\n     * @param {boolean} pma - Does the texture have premultiplied alpha?\r\n     *\r\n     * @return {WebGLTexture} The WebGLTexture that was created.\r\n     */\r\n    createTexture2D: function (mipLevel, minFilter, magFilter, wrapT, wrapS, format, pixels, width, height, pma)\r\n    {\r\n        pma = (pma === undefined || pma === null) ? true : pma;\r\n\r\n        var gl = this.gl;\r\n        var texture = gl.createTexture();\r\n\r\n        this.setTexture2D(texture, 0);\r\n\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\r\n        gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, pma);\r\n\r\n        if (pixels === null || pixels === undefined)\r\n        {\r\n            gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, width, height, 0, format, gl.UNSIGNED_BYTE, null);\r\n        }\r\n        else\r\n        {\r\n            gl.texImage2D(gl.TEXTURE_2D, mipLevel, format, format, gl.UNSIGNED_BYTE, pixels);\r\n\r\n            width = pixels.width;\r\n            height = pixels.height;\r\n        }\r\n\r\n        this.setTexture2D(null, 0);\r\n\r\n        texture.isAlphaPremultiplied = pma;\r\n        texture.isRenderTexture = false;\r\n        texture.width = width;\r\n        texture.height = height;\r\n\r\n        this.nativeTextures.push(texture);\r\n\r\n        return texture;\r\n    },\r\n\r\n    /**\r\n     * Wrapper for creating WebGLFramebuffer.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createFramebuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} width - Width in pixels of the framebuffer\r\n     * @param {integer} height - Height in pixels of the framebuffer\r\n     * @param {WebGLTexture} renderTexture - The color texture to where the color pixels are written\r\n     * @param {boolean} addDepthStencilBuffer - Indicates if the current framebuffer support depth and stencil buffers\r\n     *\r\n     * @return {WebGLFramebuffer} Raw WebGLFramebuffer\r\n     */\r\n    createFramebuffer: function (width, height, renderTexture, addDepthStencilBuffer)\r\n    {\r\n        var gl = this.gl;\r\n        var framebuffer = gl.createFramebuffer();\r\n        var complete = 0;\r\n\r\n        this.setFramebuffer(framebuffer);\r\n\r\n        if (addDepthStencilBuffer)\r\n        {\r\n            var depthStencilBuffer = gl.createRenderbuffer();\r\n            gl.bindRenderbuffer(gl.RENDERBUFFER, depthStencilBuffer);\r\n            gl.renderbufferStorage(gl.RENDERBUFFER, gl.DEPTH_STENCIL, width, height);\r\n            gl.framebufferRenderbuffer(gl.FRAMEBUFFER, gl.DEPTH_STENCIL_ATTACHMENT, gl.RENDERBUFFER, depthStencilBuffer);\r\n        }\r\n\r\n        renderTexture.isRenderTexture = true;\r\n        renderTexture.isAlphaPremultiplied = false;\r\n\r\n        gl.framebufferTexture2D(gl.FRAMEBUFFER, gl.COLOR_ATTACHMENT0, gl.TEXTURE_2D, renderTexture, 0);\r\n\r\n        complete = gl.checkFramebufferStatus(gl.FRAMEBUFFER);\r\n\r\n        if (complete !== gl.FRAMEBUFFER_COMPLETE)\r\n        {\r\n            var errors = {\r\n                36054: 'Incomplete Attachment',\r\n                36055: 'Missing Attachment',\r\n                36057: 'Incomplete Dimensions',\r\n                36061: 'Framebuffer Unsupported'\r\n            };\r\n\r\n            throw new Error('Framebuffer incomplete. Framebuffer status: ' + errors[complete]);\r\n        }\r\n\r\n        framebuffer.renderTexture = renderTexture;\r\n\r\n        this.setFramebuffer(null);\r\n\r\n        return framebuffer;\r\n    },\r\n\r\n    /**\r\n     * Wrapper for creating a WebGLProgram\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createProgram\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} vertexShader - Source to the vertex shader\r\n     * @param {string} fragmentShader - Source to the fragment shader\r\n     *\r\n     * @return {WebGLProgram} Raw WebGLProgram\r\n     */\r\n    createProgram: function (vertexShader, fragmentShader)\r\n    {\r\n        var gl = this.gl;\r\n        var program = gl.createProgram();\r\n        var vs = gl.createShader(gl.VERTEX_SHADER);\r\n        var fs = gl.createShader(gl.FRAGMENT_SHADER);\r\n\r\n        gl.shaderSource(vs, vertexShader);\r\n        gl.shaderSource(fs, fragmentShader);\r\n        gl.compileShader(vs);\r\n        gl.compileShader(fs);\r\n\r\n        if (!gl.getShaderParameter(vs, gl.COMPILE_STATUS))\r\n        {\r\n            throw new Error('Failed to compile Vertex Shader:\\n' + gl.getShaderInfoLog(vs));\r\n        }\r\n        if (!gl.getShaderParameter(fs, gl.COMPILE_STATUS))\r\n        {\r\n            throw new Error('Failed to compile Fragment Shader:\\n' + gl.getShaderInfoLog(fs));\r\n        }\r\n\r\n        gl.attachShader(program, vs);\r\n        gl.attachShader(program, fs);\r\n        gl.linkProgram(program);\r\n\r\n        if (!gl.getProgramParameter(program, gl.LINK_STATUS))\r\n        {\r\n            throw new Error('Failed to link program:\\n' + gl.getProgramInfoLog(program));\r\n        }\r\n\r\n        return program;\r\n    },\r\n\r\n    /**\r\n     * Wrapper for creating a vertex buffer.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createVertexBuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ArrayBuffer} initialDataOrSize - It's either ArrayBuffer or an integer indicating the size of the vbo\r\n     * @param {integer} bufferUsage - How the buffer is used. gl.DYNAMIC_DRAW, gl.STATIC_DRAW or gl.STREAM_DRAW\r\n     *\r\n     * @return {WebGLBuffer} Raw vertex buffer\r\n     */\r\n    createVertexBuffer: function (initialDataOrSize, bufferUsage)\r\n    {\r\n        var gl = this.gl;\r\n        var vertexBuffer = gl.createBuffer();\r\n\r\n        this.setVertexBuffer(vertexBuffer);\r\n\r\n        gl.bufferData(gl.ARRAY_BUFFER, initialDataOrSize, bufferUsage);\r\n\r\n        this.setVertexBuffer(null);\r\n\r\n        return vertexBuffer;\r\n    },\r\n\r\n    /**\r\n     * Wrapper for creating a vertex buffer.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#createIndexBuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {ArrayBuffer} initialDataOrSize - Either ArrayBuffer or an integer indicating the size of the vbo.\r\n     * @param {integer} bufferUsage - How the buffer is used. gl.DYNAMIC_DRAW, gl.STATIC_DRAW or gl.STREAM_DRAW.\r\n     *\r\n     * @return {WebGLBuffer} Raw index buffer\r\n     */\r\n    createIndexBuffer: function (initialDataOrSize, bufferUsage)\r\n    {\r\n        var gl = this.gl;\r\n        var indexBuffer = gl.createBuffer();\r\n\r\n        this.setIndexBuffer(indexBuffer);\r\n\r\n        gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, initialDataOrSize, bufferUsage);\r\n\r\n        this.setIndexBuffer(null);\r\n\r\n        return indexBuffer;\r\n    },\r\n\r\n    /**\r\n     * Removes the given texture from the nativeTextures array and then deletes it from the GPU.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLTexture} texture - The WebGL Texture to be deleted.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    deleteTexture: function (texture)\r\n    {\r\n        var index = this.nativeTextures.indexOf(texture);\r\n\r\n        if (index !== -1)\r\n        {\r\n            SpliceOne(this.nativeTextures, index);\r\n        }\r\n\r\n        this.gl.deleteTexture(texture);\r\n\r\n        if (this.currentTextures[0] === texture && !this.game.pendingDestroy)\r\n        {\r\n            //  texture we just deleted is in use, so bind a blank texture\r\n            this.setBlankTexture(true);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Deletes a WebGLFramebuffer from the GL instance.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteFramebuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLFramebuffer} framebuffer - The Framebuffer to be deleted.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    deleteFramebuffer: function (framebuffer)\r\n    {\r\n        this.gl.deleteFramebuffer(framebuffer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Deletes a WebGLProgram from the GL instance.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteProgram\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The shader program to be deleted.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    deleteProgram: function (program)\r\n    {\r\n        this.gl.deleteProgram(program);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Deletes a WebGLBuffer from the GL instance.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#deleteBuffer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLBuffer} vertexBuffer - The WebGLBuffer to be deleted.\r\n     *\r\n     * @return {this} This WebGLRenderer instance.\r\n     */\r\n    deleteBuffer: function (buffer)\r\n    {\r\n        this.gl.deleteBuffer(buffer);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Controls the pre-render operations for the given camera.\r\n     * Handles any clipping needed by the camera and renders the background color if a color is visible.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#preRenderCamera\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to pre-render.\r\n     */\r\n    preRenderCamera: function (camera)\r\n    {\r\n        var cx = camera._cx;\r\n        var cy = camera._cy;\r\n        var cw = camera._cw;\r\n        var ch = camera._ch;\r\n\r\n        var TextureTintPipeline = this.pipelines.TextureTintPipeline;\r\n\r\n        var color = camera.backgroundColor;\r\n\r\n        if (camera.renderToTexture)\r\n        {\r\n            this.flush();\r\n\r\n            this.pushScissor(cx, cy, cw, -ch);\r\n\r\n            this.setFramebuffer(camera.framebuffer);\r\n\r\n            var gl = this.gl;\r\n\r\n            gl.clearColor(0, 0, 0, 0);\r\n\r\n            gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n            TextureTintPipeline.projOrtho(cx, cw + cx, cy, ch + cy, -1000, 1000);\r\n\r\n            if (camera.mask)\r\n            {\r\n                this.currentCameraMask.mask = camera.mask;\r\n                this.currentCameraMask.camera = camera._maskCamera;\r\n\r\n                camera.mask.preRenderWebGL(this, camera, camera._maskCamera);\r\n            }\r\n\r\n            if (color.alphaGL > 0)\r\n            {\r\n                TextureTintPipeline.drawFillRect(\r\n                    cx, cy, cw + cx, ch + cy,\r\n                    Utils.getTintFromFloats(color.redGL, color.greenGL, color.blueGL, 1),\r\n                    color.alphaGL\r\n                );\r\n            }\r\n            \r\n            camera.emit(CameraEvents.PRE_RENDER, camera);\r\n        }\r\n        else\r\n        {\r\n            this.pushScissor(cx, cy, cw, ch);\r\n\r\n            if (camera.mask)\r\n            {\r\n                this.currentCameraMask.mask = camera.mask;\r\n                this.currentCameraMask.camera = camera._maskCamera;\r\n\r\n                camera.mask.preRenderWebGL(this, camera, camera._maskCamera);\r\n            }\r\n\r\n            if (color.alphaGL > 0)\r\n            {\r\n                TextureTintPipeline.drawFillRect(\r\n                    cx, cy, cw , ch,\r\n                    Utils.getTintFromFloats(color.redGL, color.greenGL, color.blueGL, 1),\r\n                    color.alphaGL\r\n                );\r\n            }\r\n        }\r\n    },\r\n\r\n    getCurrentStencilMask: function ()\r\n    {\r\n        var prev = null;\r\n        var stack = this.maskStack;\r\n        var cameraMask = this.currentCameraMask;\r\n\r\n        if (stack.length > 0)\r\n        {\r\n            prev = stack[stack.length - 1];\r\n        }\r\n        else if (cameraMask.mask && cameraMask.mask.isStencil)\r\n        {\r\n            prev = cameraMask;\r\n        }\r\n\r\n        return prev;\r\n    },\r\n\r\n    /**\r\n     * Controls the post-render operations for the given camera.\r\n     * Renders the foreground camera effects like flash and fading. It resets the current scissor state.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#postRenderCamera\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to post-render.\r\n     */\r\n    postRenderCamera: function (camera)\r\n    {\r\n        var TextureTintPipeline = this.pipelines.TextureTintPipeline;\r\n\r\n        camera.flashEffect.postRenderWebGL(TextureTintPipeline, Utils.getTintFromFloats);\r\n        camera.fadeEffect.postRenderWebGL(TextureTintPipeline, Utils.getTintFromFloats);\r\n\r\n        camera.dirty = false;\r\n\r\n        this.popScissor();\r\n\r\n        if (camera.renderToTexture)\r\n        {\r\n            TextureTintPipeline.flush();\r\n\r\n            this.setFramebuffer(null);\r\n\r\n            camera.emit(CameraEvents.POST_RENDER, camera);\r\n\r\n            TextureTintPipeline.projOrtho(0, TextureTintPipeline.width, TextureTintPipeline.height, 0, -1000.0, 1000.0);\r\n\r\n            var getTint = Utils.getTintAppendFloatAlpha;\r\n\r\n            var pipeline = (camera.pipeline) ? camera.pipeline : TextureTintPipeline;\r\n\r\n            pipeline.batchTexture(\r\n                camera,\r\n                camera.glTexture,\r\n                camera.width, camera.height,\r\n                camera.x, camera.y,\r\n                camera.width, camera.height,\r\n                camera.zoom, camera.zoom,\r\n                camera.rotation,\r\n                camera.flipX, !camera.flipY,\r\n                1, 1,\r\n                0, 0,\r\n                0, 0, camera.width, camera.height,\r\n                getTint(camera._tintTL, camera._alphaTL),\r\n                getTint(camera._tintTR, camera._alphaTR),\r\n                getTint(camera._tintBL, camera._alphaBL),\r\n                getTint(camera._tintBR, camera._alphaBR),\r\n                (camera._isTinted && camera.tintFill),\r\n                0, 0,\r\n                this.defaultCamera,\r\n                null\r\n            );\r\n\r\n            //  Force clear the current texture so that items next in the batch (like Graphics) don't try and use it\r\n            this.setBlankTexture(true);\r\n        }\r\n\r\n        if (camera.mask)\r\n        {\r\n            this.currentCameraMask.mask = null;\r\n\r\n            camera.mask.postRenderWebGL(this, camera._maskCamera);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Clears the current vertex buffer and updates pipelines.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#preRender\r\n     * @since 3.0.0\r\n     */\r\n    preRender: function ()\r\n    {\r\n        if (this.contextLost) { return; }\r\n\r\n        var gl = this.gl;\r\n        var pipelines = this.pipelines;\r\n\r\n        //  Make sure we are bound to the main frame buffer\r\n        gl.bindFramebuffer(gl.FRAMEBUFFER, null);\r\n\r\n        if (this.config.clearBeforeRender)\r\n        {\r\n            var clearColor = this.config.backgroundColor;\r\n\r\n            gl.clearColor(clearColor.redGL, clearColor.greenGL, clearColor.blueGL, clearColor.alphaGL);\r\n\r\n            gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT | gl.STENCIL_BUFFER_BIT);\r\n        }\r\n\r\n        gl.enable(gl.SCISSOR_TEST);\r\n\r\n        for (var key in pipelines)\r\n        {\r\n            pipelines[key].onPreRender();\r\n        }\r\n\r\n        //  TODO - Find a way to stop needing to create these arrays every frame\r\n        //  and equally not need a huge array buffer created to hold them\r\n\r\n        this.currentScissor = [ 0, 0, this.width, this.height ];\r\n        this.scissorStack = [ this.currentScissor ];\r\n\r\n        if (this.game.scene.customViewports)\r\n        {\r\n            gl.scissor(0, (this.drawingBufferHeight - this.height), this.width, this.height);\r\n        }\r\n\r\n        this.currentMask.mask = null;\r\n        this.currentCameraMask.mask = null;\r\n        this.maskStack.length = 0;\r\n\r\n        this.setPipeline(this.pipelines.TextureTintPipeline);\r\n    },\r\n\r\n    /**\r\n     * The core render step for a Scene Camera.\r\n     * \r\n     * Iterates through the given Game Object's array and renders them with the given Camera.\r\n     * \r\n     * This is called by the `CameraManager.render` method. The Camera Manager instance belongs to a Scene, and is invoked\r\n     * by the Scene Systems.render method.\r\n     * \r\n     * This method is not called if `Camera.visible` is `false`, or `Camera.alpha` is zero.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#render\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - The Scene to render.\r\n     * @param {Phaser.GameObjects.GameObject} children - The Game Object's within the Scene to be rendered.\r\n     * @param {number} interpolationPercentage - The interpolation percentage to apply. Currently un-used.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Scene Camera to render with.\r\n     */\r\n    render: function (scene, children, interpolationPercentage, camera)\r\n    {\r\n        if (this.contextLost) { return; }\r\n\r\n        var list = children.list;\r\n        var childCount = list.length;\r\n        var pipelines = this.pipelines;\r\n\r\n        for (var key in pipelines)\r\n        {\r\n            pipelines[key].onRender(scene, camera);\r\n        }\r\n\r\n        //   Apply scissor for cam region + render background color, if not transparent\r\n        this.preRenderCamera(camera);\r\n\r\n        var current = this.currentMask;\r\n\r\n        for (var i = 0; i < childCount; i++)\r\n        {\r\n            var child = list[i];\r\n\r\n            if (!child.willRender(camera))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            if (child.blendMode !== this.currentBlendMode)\r\n            {\r\n                this.setBlendMode(child.blendMode);\r\n            }\r\n\r\n            var mask = child.mask;\r\n\r\n            current = this.currentMask;\r\n\r\n            if (current.mask && current.mask !== mask)\r\n            {\r\n                //  Render out the previously set mask\r\n                current.mask.postRenderWebGL(this, current.camera);\r\n            }\r\n\r\n            if (mask && current.mask !== mask)\r\n            {\r\n                mask.preRenderWebGL(this, child, camera);\r\n            }\r\n\r\n            child.renderWebGL(this, child, interpolationPercentage, camera);\r\n        }\r\n\r\n        current = this.currentMask;\r\n\r\n        if (current.mask)\r\n        {\r\n            //  Render out the previously set mask, if it was the last item in the display list\r\n            current.mask.postRenderWebGL(this, current.camera);\r\n        }\r\n\r\n        this.setBlendMode(CONST.BlendModes.NORMAL);\r\n\r\n        //  Applies camera effects and pops the scissor, if set\r\n        this.postRenderCamera(camera);\r\n    },\r\n\r\n    /**\r\n     * The post-render step happens after all Cameras in all Scenes have been rendered.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#postRender\r\n     * @since 3.0.0\r\n     */\r\n    postRender: function ()\r\n    {\r\n        if (this.contextLost) { return; }\r\n\r\n        this.flush();\r\n\r\n        // Unbind custom framebuffer here\r\n\r\n        var state = this.snapshotState;\r\n\r\n        if (state.callback)\r\n        {\r\n            WebGLSnapshot(this.canvas, state);\r\n\r\n            state.callback = null;\r\n        }\r\n\r\n        var pipelines = this.pipelines;\r\n\r\n        for (var key in pipelines)\r\n        {\r\n            pipelines[key].onPostRender();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Schedules a snapshot of the entire game viewport to be taken after the current frame is rendered.\r\n     * \r\n     * To capture a specific area see the `snapshotArea` method. To capture a specific pixel, see `snapshotPixel`.\r\n     * \r\n     * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then\r\n     * calling this method will override it.\r\n     * \r\n     * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.\r\n     * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,\r\n     * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,\r\n     * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#snapshot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n     *\r\n     * @return {this} This WebGL Renderer.\r\n     */\r\n    snapshot: function (callback, type, encoderOptions)\r\n    {\r\n        return this.snapshotArea(0, 0, this.gl.drawingBufferWidth, this.gl.drawingBufferHeight, callback, type, encoderOptions);\r\n    },\r\n\r\n    /**\r\n     * Schedules a snapshot of the given area of the game viewport to be taken after the current frame is rendered.\r\n     * \r\n     * To capture the whole game viewport see the `snapshot` method. To capture a specific pixel, see `snapshotPixel`.\r\n     * \r\n     * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then\r\n     * calling this method will override it.\r\n     * \r\n     * Snapshots work by using the WebGL `readPixels` feature to grab every pixel from the frame buffer into an ArrayBufferView.\r\n     * It then parses this, copying the contents to a temporary Canvas and finally creating an Image object from it,\r\n     * which is the image returned to the callback provided. All in all, this is a computationally expensive and blocking process,\r\n     * which gets more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#snapshotArea\r\n     * @since 3.16.0\r\n     *\r\n     * @param {integer} x - The x coordinate to grab from.\r\n     * @param {integer} y - The y coordinate to grab from.\r\n     * @param {integer} width - The width of the area to grab.\r\n     * @param {integer} height - The height of the area to grab.\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n     *\r\n     * @return {this} This WebGL Renderer.\r\n     */\r\n    snapshotArea: function (x, y, width, height, callback, type, encoderOptions)\r\n    {\r\n        var state = this.snapshotState;\r\n\r\n        state.callback = callback;\r\n        state.type = type;\r\n        state.encoder = encoderOptions;\r\n        state.getPixel = false;\r\n        state.x = x;\r\n        state.y = y;\r\n        state.width = Math.min(width, this.gl.drawingBufferWidth);\r\n        state.height = Math.min(height, this.gl.drawingBufferHeight);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Schedules a snapshot of the given pixel from the game viewport to be taken after the current frame is rendered.\r\n     * \r\n     * To capture the whole game viewport see the `snapshot` method. To capture a specific area, see `snapshotArea`.\r\n     * \r\n     * Only one snapshot can be active _per frame_. If you have already called `snapshotArea`, for example, then\r\n     * calling this method will override it.\r\n     * \r\n     * Unlike the other two snapshot methods, this one will return a `Color` object containing the color data for\r\n     * the requested pixel. It doesn't need to create an internal Canvas or Image object, so is a lot faster to execute,\r\n     * using less memory.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#snapshotPixel\r\n     * @since 3.16.0\r\n     *\r\n     * @param {integer} x - The x coordinate of the pixel to get.\r\n     * @param {integer} y - The y coordinate of the pixel to get.\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot pixel data is extracted.\r\n     *\r\n     * @return {this} This WebGL Renderer.\r\n     */\r\n    snapshotPixel: function (x, y, callback)\r\n    {\r\n        this.snapshotArea(x, y, 1, 1, callback);\r\n\r\n        this.snapshotState.getPixel = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Creates a WebGL Texture based on the given canvas element.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#canvasToTexture\r\n     * @since 3.0.0\r\n     *\r\n     * @param {HTMLCanvasElement} srcCanvas - The Canvas element that will be used to populate the texture.\r\n     * @param {WebGLTexture} [dstTexture] - Is this going to replace an existing texture? If so, pass it here.\r\n     * @param {boolean} [noRepeat=false] - Should this canvas never be allowed to set REPEAT? (such as for Text objects)\r\n     *\r\n     * @return {WebGLTexture} The newly created WebGL Texture.\r\n     */\r\n    canvasToTexture: function (srcCanvas, dstTexture, noRepeat)\r\n    {\r\n        if (noRepeat === undefined) { noRepeat = false; }\r\n\r\n        var gl = this.gl;\r\n\r\n        if (!dstTexture)\r\n        {\r\n            var wrapping = gl.CLAMP_TO_EDGE;\r\n\r\n            if (!noRepeat && IsSizePowerOfTwo(srcCanvas.width, srcCanvas.height))\r\n            {\r\n                wrapping = gl.REPEAT;\r\n            }\r\n\r\n            var filter = (this.config.antialias) ? gl.LINEAR : gl.NEAREST;\r\n\r\n            dstTexture = this.createTexture2D(0, filter, filter, wrapping, wrapping, gl.RGBA, srcCanvas, srcCanvas.width, srcCanvas.height, true);\r\n        }\r\n        else\r\n        {\r\n            this.setTexture2D(dstTexture, 0);\r\n\r\n            gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, srcCanvas);\r\n\r\n            dstTexture.width = srcCanvas.width;\r\n            dstTexture.height = srcCanvas.height;\r\n\r\n            this.setTexture2D(null, 0);\r\n        }\r\n\r\n        return dstTexture;\r\n    },\r\n\r\n    /**\r\n     * Sets the minification and magnification filter for a texture.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setTextureFilter\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} texture - The texture to set the filter for.\r\n     * @param {integer} filter - The filter to set. 0 for linear filtering, 1 for nearest neighbor (blocky) filtering.\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setTextureFilter: function (texture, filter)\r\n    {\r\n        var gl = this.gl;\r\n        var glFilter = [ gl.LINEAR, gl.NEAREST ][filter];\r\n\r\n        this.setTexture2D(texture, 0);\r\n\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, glFilter);\r\n        gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, glFilter);\r\n\r\n        this.setTexture2D(null, 0);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat1\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {number} x - [description]\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setFloat1: function (program, name, x)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniform1f(this.gl.getUniformLocation(program, name), x);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat2\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setFloat2: function (program, name, x, y)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniform2f(this.gl.getUniformLocation(program, name), x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat3\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} z - [description]\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setFloat3: function (program, name, x, y, z)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniform3f(this.gl.getUniformLocation(program, name), x, y, z);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets uniform of a WebGLProgram\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {number} x - X component\r\n     * @param {number} y - Y component\r\n     * @param {number} z - Z component\r\n     * @param {number} w - W component\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setFloat4: function (program, name, x, y, z, w)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniform4f(this.gl.getUniformLocation(program, name), x, y, z, w);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the value of a uniform variable in the given WebGLProgram.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat1v\r\n     * @since 3.13.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {Float32Array} arr - The new value to be used for the uniform variable.\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setFloat1v: function (program, name, arr)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniform1fv(this.gl.getUniformLocation(program, name), arr);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the value of a uniform variable in the given WebGLProgram.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat2v\r\n     * @since 3.13.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {Float32Array} arr - The new value to be used for the uniform variable.\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setFloat2v: function (program, name, arr)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniform2fv(this.gl.getUniformLocation(program, name), arr);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the value of a uniform variable in the given WebGLProgram.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat3v\r\n     * @since 3.13.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {Float32Array} arr - The new value to be used for the uniform variable.\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setFloat3v: function (program, name, arr)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniform3fv(this.gl.getUniformLocation(program, name), arr);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the value of a uniform variable in the given WebGLProgram.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setFloat4v\r\n     * @since 3.13.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {Float32Array} arr - The new value to be used for the uniform variable.\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n\r\n    setFloat4v: function (program, name, arr)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniform4fv(this.gl.getUniformLocation(program, name), arr);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the value of a uniform variable in the given WebGLProgram.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setInt1\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {integer} x - [description]\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setInt1: function (program, name, x)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniform1i(this.gl.getUniformLocation(program, name), x);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the value of a uniform variable in the given WebGLProgram.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setInt2\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {integer} x - The new X component\r\n     * @param {integer} y - The new Y component\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setInt2: function (program, name, x, y)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniform2i(this.gl.getUniformLocation(program, name), x, y);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the value of a uniform variable in the given WebGLProgram.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setInt3\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {integer} x - The new X component\r\n     * @param {integer} y - The new Y component\r\n     * @param {integer} z - The new Z component\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setInt3: function (program, name, x, y, z)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniform3i(this.gl.getUniformLocation(program, name), x, y, z);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the value of a uniform variable in the given WebGLProgram.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setInt4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {integer} x - X component\r\n     * @param {integer} y - Y component\r\n     * @param {integer} z - Z component\r\n     * @param {integer} w - W component\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setInt4: function (program, name, x, y, z, w)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniform4i(this.gl.getUniformLocation(program, name), x, y, z, w);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the value of a 2x2 matrix uniform variable in the given WebGLProgram.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setMatrix2\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {boolean} transpose - The value indicating whether to transpose the matrix. Must be false.\r\n     * @param {Float32Array} matrix - The new matrix value.\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setMatrix2: function (program, name, transpose, matrix)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniformMatrix2fv(this.gl.getUniformLocation(program, name), transpose, matrix);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setMatrix3\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {boolean} transpose - [description]\r\n     * @param {Float32Array} matrix - [description]\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setMatrix3: function (program, name, transpose, matrix)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniformMatrix3fv(this.gl.getUniformLocation(program, name), transpose, matrix);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets uniform of a WebGLProgram\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#setMatrix4\r\n     * @since 3.0.0\r\n     *\r\n     * @param {WebGLProgram} program - The target WebGLProgram from which the uniform location will be looked-up.\r\n     * @param {string} name - The name of the uniform to look-up and modify.\r\n     * @param {boolean} transpose - Is the matrix transposed\r\n     * @param {Float32Array} matrix - Matrix data\r\n     *\r\n     * @return {this} This WebGL Renderer instance.\r\n     */\r\n    setMatrix4: function (program, name, transpose, matrix)\r\n    {\r\n        this.setProgram(program);\r\n\r\n        this.gl.uniformMatrix4fv(this.gl.getUniformLocation(program, name), transpose, matrix);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the maximum number of texture units that can be used in a fragment shader.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#getMaxTextures\r\n     * @since 3.8.0\r\n     *\r\n     * @return {integer} The maximum number of textures WebGL supports.\r\n     */\r\n    getMaxTextures: function ()\r\n    {\r\n        return this.config.maxTextures;\r\n    },\r\n\r\n    /**\r\n     * Returns the largest texture size (either width or height) that can be created.\r\n     * Note that VRAM may not allow a texture of any given size, it just expresses\r\n     * hardware / driver support for a given size.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#getMaxTextureSize\r\n     * @since 3.8.0\r\n     *\r\n     * @return {integer} The maximum supported texture size.\r\n     */\r\n    getMaxTextureSize: function ()\r\n    {\r\n        return this.config.maxTextureSize;\r\n    },\r\n\r\n    /**\r\n     * Destroy this WebGLRenderer, cleaning up all related resources such as pipelines, native textures, etc.\r\n     *\r\n     * @method Phaser.Renderer.WebGL.WebGLRenderer#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        //  Clear-up anything that should be cleared :)\r\n        for (var key in this.pipelines)\r\n        {\r\n            this.pipelines[key].destroy();\r\n\r\n            delete this.pipelines[key];\r\n        }\r\n\r\n        for (var index = 0; index < this.nativeTextures.length; index++)\r\n        {\r\n            this.deleteTexture(this.nativeTextures[index]);\r\n\r\n            delete this.nativeTextures[index];\r\n        }\r\n\r\n        delete this.gl;\r\n        delete this.game;\r\n\r\n        this.maskStack.length = 0;\r\n\r\n        this.contextLost = true;\r\n        this.extensions = {};\r\n        this.nativeTextures.length = 0;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = WebGLRenderer;\r\n"},"sourceMaps":null,"error":null,"hash":"13e461def93274392c89f2faec36b154","cacheData":{"env":{}}}