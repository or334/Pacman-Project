{"id":"../../node_modules/phaser/src/scene/SceneManager.js","dependencies":[{"name":"C:\\Users\\דור\\Desktop\\pmm\\package.json","includedInParent":true,"mtime":1560952935180},{"name":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\package.json","includedInParent":true,"mtime":1561396619369},{"name":"../utils/Class","loc":{"line":7,"column":20},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\scene\\SceneManager.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\Class.js"},{"name":"./const","loc":{"line":8,"column":20},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\scene\\SceneManager.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\scene\\const.js"},{"name":"./events","loc":{"line":9,"column":21},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\scene\\SceneManager.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\scene\\events\\index.js"},{"name":"../core/events","loc":{"line":10,"column":25},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\scene\\SceneManager.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\core\\events\\index.js"},{"name":"../utils/object/GetValue","loc":{"line":11,"column":23},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\scene\\SceneManager.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\object\\GetValue.js"},{"name":"../loader/events","loc":{"line":12,"column":27},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\scene\\SceneManager.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\loader\\events\\index.js"},{"name":"../utils/NOOP","loc":{"line":13,"column":19},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\scene\\SceneManager.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\NOOP.js"},{"name":"./Scene","loc":{"line":14,"column":20},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\scene\\SceneManager.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\scene\\Scene.js"},{"name":"./Systems","loc":{"line":15,"column":22},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\scene\\SceneManager.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\scene\\Systems.js"}],"generated":{"js":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar CONST = require('./const');\r\nvar Events = require('./events');\r\nvar GameEvents = require('../core/events');\r\nvar GetValue = require('../utils/object/GetValue');\r\nvar LoaderEvents = require('../loader/events');\r\nvar NOOP = require('../utils/NOOP');\r\nvar Scene = require('./Scene');\r\nvar Systems = require('./Systems');\r\n\r\n/**\r\n * @classdesc\r\n * The Scene Manager.\r\n *\r\n * The Scene Manager is a Game level system, responsible for creating, processing and updating all of the\r\n * Scenes in a Game instance.\r\n *\r\n *\r\n * @class SceneManager\r\n * @memberof Phaser.Scenes\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Phaser.Game instance this Scene Manager belongs to.\r\n * @param {object} sceneConfig - Scene specific configuration settings.\r\n */\r\nvar SceneManager = new Class({\r\n\r\n    initialize:\r\n\r\n    function SceneManager (game, sceneConfig)\r\n    {\r\n        /**\r\n         * The Game that this SceneManager belongs to.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */\r\n        this.game = game;\r\n\r\n        /**\r\n         * An object that maps the keys to the scene so we can quickly get a scene from a key without iteration.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#keys\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.keys = {};\r\n\r\n        /**\r\n         * The array in which all of the scenes are kept.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#scenes\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.scenes = [];\r\n\r\n        /**\r\n         * Scenes pending to be added are stored in here until the manager has time to add it.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#_pending\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._pending = [];\r\n\r\n        /**\r\n         * An array of scenes waiting to be started once the game has booted.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#_start\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._start = [];\r\n\r\n        /**\r\n         * An operations queue, because we don't manipulate the scenes array during processing.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#_queue\r\n         * @type {array}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._queue = [];\r\n\r\n        /**\r\n         * Boot time data to merge.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#_data\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.4.0\r\n         */\r\n        this._data = {};\r\n\r\n        /**\r\n         * Is the Scene Manager actively processing the Scenes list?\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#isProcessing\r\n         * @type {boolean}\r\n         * @default false\r\n         * @readonly\r\n         * @since 3.0.0\r\n         */\r\n        this.isProcessing = false;\r\n\r\n        /**\r\n         * Has the Scene Manager properly started?\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#isBooted\r\n         * @type {boolean}\r\n         * @default false\r\n         * @readonly\r\n         * @since 3.4.0\r\n         */\r\n        this.isBooted = false;\r\n\r\n        /**\r\n         * Do any of the Cameras in any of the Scenes require a custom viewport?\r\n         * If not we can skip scissor tests.\r\n         *\r\n         * @name Phaser.Scenes.SceneManager#customViewports\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.12.0\r\n         */\r\n        this.customViewports = 0;\r\n\r\n        if (sceneConfig)\r\n        {\r\n            if (!Array.isArray(sceneConfig))\r\n            {\r\n                sceneConfig = [ sceneConfig ];\r\n            }\r\n\r\n            for (var i = 0; i < sceneConfig.length; i++)\r\n            {\r\n                //  The i === 0 part just autostarts the first Scene given (unless it says otherwise in its config)\r\n                this._pending.push({\r\n                    key: 'default',\r\n                    scene: sceneConfig[i],\r\n                    autoStart: (i === 0),\r\n                    data: {}\r\n                });\r\n            }\r\n        }\r\n\r\n        game.events.once(GameEvents.READY, this.bootQueue, this);\r\n    },\r\n\r\n    /**\r\n     * Internal first-time Scene boot handler.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#bootQueue\r\n     * @private\r\n     * @since 3.2.0\r\n     */\r\n    bootQueue: function ()\r\n    {\r\n        if (this.isBooted)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var i;\r\n        var entry;\r\n        var key;\r\n        var sceneConfig;\r\n\r\n        for (i = 0; i < this._pending.length; i++)\r\n        {\r\n            entry = this._pending[i];\r\n\r\n            key = entry.key;\r\n            sceneConfig = entry.scene;\r\n\r\n            var newScene;\r\n\r\n            if (sceneConfig instanceof Scene)\r\n            {\r\n                newScene = this.createSceneFromInstance(key, sceneConfig);\r\n            }\r\n            else if (typeof sceneConfig === 'object')\r\n            {\r\n                newScene = this.createSceneFromObject(key, sceneConfig);\r\n            }\r\n            else if (typeof sceneConfig === 'function')\r\n            {\r\n                newScene = this.createSceneFromFunction(key, sceneConfig);\r\n            }\r\n\r\n            //  Replace key in case the scene changed it\r\n            key = newScene.sys.settings.key;\r\n\r\n            this.keys[key] = newScene;\r\n\r\n            this.scenes.push(newScene);\r\n\r\n            //  Any data to inject?\r\n            if (this._data[key])\r\n            {\r\n                newScene.sys.settings.data = this._data[key].data;\r\n\r\n                if (this._data[key].autoStart)\r\n                {\r\n                    entry.autoStart = true;\r\n                }\r\n            }\r\n\r\n            if (entry.autoStart || newScene.sys.settings.active)\r\n            {\r\n                this._start.push(key);\r\n            }\r\n        }\r\n\r\n        //  Clear the pending lists\r\n        this._pending.length = 0;\r\n\r\n        this._data = {};\r\n\r\n        this.isBooted = true;\r\n\r\n        //  _start might have been populated by the above\r\n        for (i = 0; i < this._start.length; i++)\r\n        {\r\n            entry = this._start[i];\r\n\r\n            this.start(entry);\r\n        }\r\n\r\n        this._start.length = 0;\r\n    },\r\n\r\n    /**\r\n     * Process the Scene operations queue.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#processQueue\r\n     * @since 3.0.0\r\n     */\r\n    processQueue: function ()\r\n    {\r\n        var pendingLength = this._pending.length;\r\n        var queueLength = this._queue.length;\r\n\r\n        if (pendingLength === 0 && queueLength === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var i;\r\n        var entry;\r\n\r\n        if (pendingLength)\r\n        {\r\n            for (i = 0; i < pendingLength; i++)\r\n            {\r\n                entry = this._pending[i];\r\n\r\n                this.add(entry.key, entry.scene, entry.autoStart, entry.data);\r\n            }\r\n\r\n            //  _start might have been populated by this.add\r\n            for (i = 0; i < this._start.length; i++)\r\n            {\r\n                entry = this._start[i];\r\n\r\n                this.start(entry);\r\n            }\r\n\r\n            //  Clear the pending lists\r\n            this._start.length = 0;\r\n            this._pending.length = 0;\r\n\r\n            return;\r\n        }\r\n\r\n        for (i = 0; i < this._queue.length; i++)\r\n        {\r\n            entry = this._queue[i];\r\n\r\n            this[entry.op](entry.keyA, entry.keyB);\r\n        }\r\n\r\n        this._queue.length = 0;\r\n    },\r\n\r\n    /**\r\n     * Adds a new Scene into the SceneManager.\r\n     * You must give each Scene a unique key by which you'll identify it.\r\n     *\r\n     * The `sceneConfig` can be:\r\n     *\r\n     * * A `Phaser.Scene` object, or an object that extends it.\r\n     * * A plain JavaScript object\r\n     * * A JavaScript ES6 Class that extends `Phaser.Scene`\r\n     * * A JavaScript ES5 prototype based Class\r\n     * * A JavaScript function\r\n     *\r\n     * If a function is given then a new Scene will be created by calling it.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - A unique key used to reference the Scene, i.e. `MainMenu` or `Level1`.\r\n     * @param {(Phaser.Scene|Phaser.Types.Scenes.SettingsConfig|Phaser.Types.Scenes.CreateSceneFromObjectConfig|function)} sceneConfig - The config for the Scene\r\n     * @param {boolean} [autoStart=false] - If `true` the Scene will be started immediately after being added.\r\n     * @param {object} [data] - Optional data object. This will be set as Scene.settings.data and passed to `Scene.init`.\r\n     *\r\n     * @return {?Phaser.Scene} The added Scene, if it was added immediately, otherwise `null`.\r\n     */\r\n    add: function (key, sceneConfig, autoStart, data)\r\n    {\r\n        if (autoStart === undefined) { autoStart = false; }\r\n        if (data === undefined) { data = {}; }\r\n\r\n        //  If processing or not booted then put scene into a holding pattern\r\n        if (this.isProcessing || !this.isBooted)\r\n        {\r\n            this._pending.push({\r\n                key: key,\r\n                scene: sceneConfig,\r\n                autoStart: autoStart,\r\n                data: data\r\n            });\r\n\r\n            if (!this.isBooted)\r\n            {\r\n                this._data[key] = { data: data };\r\n            }\r\n\r\n            return null;\r\n        }\r\n\r\n        key = this.getKey(key, sceneConfig);\r\n\r\n        var newScene;\r\n\r\n        if (sceneConfig instanceof Scene)\r\n        {\r\n            newScene = this.createSceneFromInstance(key, sceneConfig);\r\n        }\r\n        else if (typeof sceneConfig === 'object')\r\n        {\r\n            sceneConfig.key = key;\r\n\r\n            newScene = this.createSceneFromObject(key, sceneConfig);\r\n        }\r\n        else if (typeof sceneConfig === 'function')\r\n        {\r\n            newScene = this.createSceneFromFunction(key, sceneConfig);\r\n        }\r\n\r\n        //  Any data to inject?\r\n        newScene.sys.settings.data = data;\r\n\r\n        //  Replace key in case the scene changed it\r\n        key = newScene.sys.settings.key;\r\n\r\n        this.keys[key] = newScene;\r\n\r\n        this.scenes.push(newScene);\r\n\r\n        if (autoStart || newScene.sys.settings.active)\r\n        {\r\n            if (this._pending.length)\r\n            {\r\n                this._start.push(key);\r\n            }\r\n            else\r\n            {\r\n                this.start(key);\r\n            }\r\n        }\r\n\r\n        return newScene;\r\n    },\r\n\r\n    /**\r\n     * Removes a Scene from the SceneManager.\r\n     *\r\n     * The Scene is removed from the local scenes array, it's key is cleared from the keys\r\n     * cache and Scene.Systems.destroy is then called on it.\r\n     *\r\n     * If the SceneManager is processing the Scenes when this method is called it will\r\n     * queue the operation for the next update sequence.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#remove\r\n     * @since 3.2.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} scene - The Scene to be removed.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    remove: function (key)\r\n    {\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'remove', keyA: key, keyB: null });\r\n        }\r\n        else\r\n        {\r\n            var sceneToRemove = this.getScene(key);\r\n\r\n            if (!sceneToRemove || sceneToRemove.sys.isTransitioning())\r\n            {\r\n                return this;\r\n            }\r\n\r\n            var index = this.scenes.indexOf(sceneToRemove);\r\n            var sceneKey = sceneToRemove.sys.settings.key;\r\n\r\n            if (index > -1)\r\n            {\r\n                delete this.keys[sceneKey];\r\n                this.scenes.splice(index, 1);\r\n\r\n                if (this._start.indexOf(sceneKey) > -1)\r\n                {\r\n                    index = this._start.indexOf(sceneKey);\r\n                    this._start.splice(index, 1);\r\n                }\r\n\r\n                sceneToRemove.sys.destroy();\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Boot the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#bootScene\r\n     * @private\r\n     * @fires Phaser.Scenes.Events#TRANSITION_INIT\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - The Scene to boot.\r\n     */\r\n    bootScene: function (scene)\r\n    {\r\n        var sys = scene.sys;\r\n        var settings = sys.settings;\r\n\r\n        if (scene.init)\r\n        {\r\n            scene.init.call(scene, settings.data);\r\n\r\n            settings.status = CONST.INIT;\r\n\r\n            if (settings.isTransition)\r\n            {\r\n                sys.events.emit(Events.TRANSITION_INIT, settings.transitionFrom, settings.transitionDuration);\r\n            }\r\n        }\r\n\r\n        var loader;\r\n\r\n        if (sys.load)\r\n        {\r\n            loader = sys.load;\r\n\r\n            loader.reset();\r\n        }\r\n\r\n        if (loader && scene.preload)\r\n        {\r\n            scene.preload.call(scene);\r\n\r\n            //  Is the loader empty?\r\n            if (loader.list.size === 0)\r\n            {\r\n                this.create(scene);\r\n            }\r\n            else\r\n            {\r\n                settings.status = CONST.LOADING;\r\n\r\n                //  Start the loader going as we have something in the queue\r\n                loader.once(LoaderEvents.COMPLETE, this.loadComplete, this);\r\n\r\n                loader.start();\r\n            }\r\n        }\r\n        else\r\n        {\r\n            //  No preload? Then there was nothing to load either\r\n            this.create(scene);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Handles load completion for a Scene's Loader.\r\n     *\r\n     * Starts the Scene that the Loader belongs to.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#loadComplete\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Loader.LoaderPlugin} loader - The loader that has completed loading.\r\n     */\r\n    loadComplete: function (loader)\r\n    {\r\n        var scene = loader.scene;\r\n\r\n        //  TODO - Remove. This should *not* be handled here\r\n        //  Try to unlock HTML5 sounds every time any loader completes\r\n        if (this.game.sound && this.game.sound.onBlurPausedSounds)\r\n        {\r\n            this.game.sound.unlock();\r\n        }\r\n\r\n        this.create(scene);\r\n    },\r\n\r\n    /**\r\n     * Handle payload completion for a Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#payloadComplete\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Loader.LoaderPlugin} loader - The loader that has completed loading its Scene's payload.\r\n     */\r\n    payloadComplete: function (loader)\r\n    {\r\n        this.bootScene(loader.scene);\r\n    },\r\n\r\n    /**\r\n     * Updates the Scenes.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - Time elapsed.\r\n     * @param {number} delta - Delta time from the last update.\r\n     */\r\n    update: function (time, delta)\r\n    {\r\n        this.processQueue();\r\n\r\n        this.isProcessing = true;\r\n\r\n        //  Loop through the active scenes in reverse order\r\n        for (var i = this.scenes.length - 1; i >= 0; i--)\r\n        {\r\n            var sys = this.scenes[i].sys;\r\n\r\n            if (sys.settings.status > CONST.START && sys.settings.status <= CONST.RUNNING)\r\n            {\r\n                sys.step(time, delta);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Renders the Scenes.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#render\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)} renderer - The renderer to use.\r\n     */\r\n    render: function (renderer)\r\n    {\r\n        //  Loop through the scenes in forward order\r\n        for (var i = 0; i < this.scenes.length; i++)\r\n        {\r\n            var sys = this.scenes[i].sys;\r\n\r\n            if (sys.settings.visible && sys.settings.status >= CONST.LOADING && sys.settings.status < CONST.SLEEPING)\r\n            {\r\n                sys.render(renderer);\r\n            }\r\n        }\r\n\r\n        this.isProcessing = false;\r\n    },\r\n\r\n    /**\r\n     * Calls the given Scene's {@link Phaser.Scene#create} method and updates its status.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#create\r\n     * @private\r\n     * @fires Phaser.Scenes.Events#CREATE\r\n     * @fires Phaser.Scenes.Events#TRANSITION_INIT\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - The Scene to create.\r\n     */\r\n    create: function (scene)\r\n    {\r\n        var sys = scene.sys;\r\n        var settings = sys.settings;\r\n\r\n        if (scene.create)\r\n        {\r\n            settings.status = CONST.CREATING;\r\n\r\n            scene.create.call(scene, settings.data);\r\n        }\r\n\r\n        if (settings.isTransition)\r\n        {\r\n            sys.events.emit(Events.TRANSITION_START, settings.transitionFrom, settings.transitionDuration);\r\n        }\r\n\r\n        //  If the Scene has an update function we'll set it now, otherwise it'll remain as NOOP\r\n        if (scene.update)\r\n        {\r\n            sys.sceneUpdate = scene.update;\r\n        }\r\n\r\n        settings.status = CONST.RUNNING;\r\n\r\n        sys.events.emit(Events.CREATE, scene);\r\n    },\r\n\r\n    /**\r\n     * Creates and initializes a Scene from a function.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#createSceneFromFunction\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the Scene.\r\n     * @param {function} scene - The function to create the Scene from.\r\n     *\r\n     * @return {Phaser.Scene} The created Scene.\r\n     */\r\n    createSceneFromFunction: function (key, scene)\r\n    {\r\n        var newScene = new scene();\r\n\r\n        if (newScene instanceof Scene)\r\n        {\r\n            var configKey = newScene.sys.settings.key;\r\n\r\n            if (configKey !== '')\r\n            {\r\n                key = configKey;\r\n            }\r\n\r\n            if (this.keys.hasOwnProperty(key))\r\n            {\r\n                throw new Error('Cannot add a Scene with duplicate key: ' + key);\r\n            }\r\n\r\n            return this.createSceneFromInstance(key, newScene);\r\n        }\r\n        else\r\n        {\r\n            newScene.sys = new Systems(newScene);\r\n\r\n            newScene.sys.settings.key = key;\r\n\r\n            newScene.sys.init(this.game);\r\n\r\n            return newScene;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates and initializes a Scene instance.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#createSceneFromInstance\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the Scene.\r\n     * @param {Phaser.Scene} newScene - The Scene instance.\r\n     *\r\n     * @return {Phaser.Scene} The created Scene.\r\n     */\r\n    createSceneFromInstance: function (key, newScene)\r\n    {\r\n        var configKey = newScene.sys.settings.key;\r\n\r\n        if (configKey !== '')\r\n        {\r\n            key = configKey;\r\n        }\r\n        else\r\n        {\r\n            newScene.sys.settings.key = key;\r\n        }\r\n\r\n        newScene.sys.init(this.game);\r\n\r\n        return newScene;\r\n    },\r\n\r\n    /**\r\n     * Creates and initializes a Scene from an Object definition.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#createSceneFromObject\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key of the Scene.\r\n     * @param {(string|Phaser.Types.Scenes.SettingsConfig|Phaser.Types.Scenes.CreateSceneFromObjectConfig)} sceneConfig - The Scene config.\r\n     *\r\n     * @return {Phaser.Scene} The created Scene.\r\n     */\r\n    createSceneFromObject: function (key, sceneConfig)\r\n    {\r\n        var newScene = new Scene(sceneConfig);\r\n\r\n        var configKey = newScene.sys.settings.key;\r\n\r\n        if (configKey !== '')\r\n        {\r\n            key = configKey;\r\n        }\r\n        else\r\n        {\r\n            newScene.sys.settings.key = key;\r\n        }\r\n\r\n        newScene.sys.init(this.game);\r\n\r\n        //  Extract callbacks\r\n\r\n        var defaults = [ 'init', 'preload', 'create', 'update', 'render' ];\r\n\r\n        for (var i = 0; i < defaults.length; i++)\r\n        {\r\n            var sceneCallback = GetValue(sceneConfig, defaults[i], null);\r\n\r\n            if (sceneCallback)\r\n            {\r\n                newScene[defaults[i]] = sceneCallback;\r\n            }\r\n        }\r\n\r\n        //  Now let's move across any other functions or properties that may exist in the extend object:\r\n\r\n        /*\r\n        scene: {\r\n            preload: preload,\r\n            create: create,\r\n            extend: {\r\n                hello: 1,\r\n                test: 'atari',\r\n                addImage: addImage\r\n            }\r\n        }\r\n        */\r\n\r\n        if (sceneConfig.hasOwnProperty('extend'))\r\n        {\r\n            for (var propertyKey in sceneConfig.extend)\r\n            {\r\n                var value = sceneConfig.extend[propertyKey];\r\n\r\n                if (propertyKey === 'data' && newScene.hasOwnProperty('data') && typeof value === 'object')\r\n                {\r\n                    //  Populate the DataManager\r\n                    newScene.data.merge(value);\r\n                }\r\n                else if (propertyKey !== 'sys')\r\n                {\r\n                    newScene[propertyKey] = value;\r\n                }\r\n            }\r\n        }\r\n\r\n        return newScene;\r\n    },\r\n\r\n    /**\r\n     * Retrieves the key of a Scene from a Scene config.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#getKey\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The key to check in the Scene config.\r\n     * @param {(Phaser.Scene|Phaser.Types.Scenes.SettingsConfig|function)} sceneConfig - The Scene config.\r\n     *\r\n     * @return {string} The Scene key.\r\n     */\r\n    getKey: function (key, sceneConfig)\r\n    {\r\n        if (!key) { key = 'default'; }\r\n\r\n        if (typeof sceneConfig === 'function')\r\n        {\r\n            return key;\r\n        }\r\n        else if (sceneConfig instanceof Scene)\r\n        {\r\n            key = sceneConfig.sys.settings.key;\r\n        }\r\n        else if (typeof sceneConfig === 'object' && sceneConfig.hasOwnProperty('key'))\r\n        {\r\n            key = sceneConfig.key;\r\n        }\r\n\r\n        //  By this point it's either 'default' or extracted from the Scene\r\n\r\n        if (this.keys.hasOwnProperty(key))\r\n        {\r\n            throw new Error('Cannot add a Scene with duplicate key: ' + key);\r\n        }\r\n        else\r\n        {\r\n            return key;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns an array of all the current Scenes being managed by this Scene Manager.\r\n     * \r\n     * You can filter the output by the active state of the Scene and choose to have\r\n     * the array returned in normal or reversed order.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#getScenes\r\n     * @since 3.16.0\r\n     *\r\n     * @param {boolean} [isActive=true] - Only include Scene's that are currently active?\r\n     * @param {boolean} [inReverse=false] - Return the array of Scenes in reverse?\r\n     *\r\n     * @return {Phaser.Scene[]} An array containing all of the Scenes in the Scene Manager.\r\n     */\r\n    getScenes: function (isActive, inReverse)\r\n    {\r\n        if (isActive === undefined) { isActive = true; }\r\n        if (inReverse === undefined) { inReverse = false; }\r\n\r\n        var out = [];\r\n        var scenes = this.scenes;\r\n\r\n        for (var i = 0; i < scenes.length; i++)\r\n        {\r\n            var scene = scenes[i];\r\n\r\n            if (scene && (!isActive || (isActive && scene.sys.isActive())))\r\n            {\r\n                out.push(scene);\r\n            }\r\n        }\r\n\r\n        return (inReverse) ? out.reverse() : out;\r\n    },\r\n\r\n    /**\r\n     * Retrieves a Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#getScene\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string|Phaser.Scene} key - The Scene to retrieve.\r\n     *\r\n     * @return {?Phaser.Scene} The Scene.\r\n     */\r\n    getScene: function (key)\r\n    {\r\n        if (typeof key === 'string')\r\n        {\r\n            if (this.keys[key])\r\n            {\r\n                return this.keys[key];\r\n            }\r\n        }\r\n        else\r\n        {\r\n            for (var i = 0; i < this.scenes.length; i++)\r\n            {\r\n                if (key === this.scenes[i])\r\n                {\r\n                    return key;\r\n                }\r\n            }\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Determines whether a Scene is running.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#isActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is running.\r\n     */\r\n    isActive: function (key)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            return scene.sys.isActive();\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Determines whether a Scene is paused.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#isPaused\r\n     * @since 3.17.0\r\n     *\r\n     * @param {string} key - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is paused.\r\n     */\r\n    isPaused: function (key)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            return scene.sys.isPaused();\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Determines whether a Scene is visible.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#isVisible\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is visible.\r\n     */\r\n    isVisible: function (key)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            return scene.sys.isVisible();\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Determines whether a Scene is sleeping.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#isSleeping\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to check.\r\n     *\r\n     * @return {boolean} Whether the Scene is sleeping.\r\n     */\r\n    isSleeping: function (key)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            return scene.sys.isSleeping();\r\n        }\r\n\r\n        return null;\r\n    },\r\n\r\n    /**\r\n     * Pauses the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to pause.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its pause event.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    pause: function (key, data)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            scene.sys.pause(data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resumes the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to resume.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its resume event.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    resume: function (key, data)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            scene.sys.resume(data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Puts the given Scene to sleep.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#sleep\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to put to sleep.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its sleep event.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    sleep: function (key, data)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene && !scene.sys.isTransitioning())\r\n        {\r\n            scene.sys.sleep(data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Awakens the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#wake\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to wake up.\r\n     * @param {object} [data] - An optional data object that will be passed to the Scene and emitted by its wake event.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    wake: function (key, data)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            scene.sys.wake(data);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Runs the given Scene, but does not change the state of this Scene.\r\n     *\r\n     * If the given Scene is paused, it will resume it. If sleeping, it will wake it.\r\n     * If not running at all, it will be started.\r\n     *\r\n     * Use this if you wish to open a modal Scene by calling `pause` on the current\r\n     * Scene, then `run` on the modal Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#run\r\n     * @since 3.10.0\r\n     *\r\n     * @param {string} key - The Scene to run.\r\n     * @param {object} [data] - A data object that will be passed to the Scene on start, wake, or resume.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This Scene Manager.\r\n     */\r\n    run: function (key, data)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (!scene)\r\n        {\r\n            for (var i = 0; i < this._pending.length; i++)\r\n            {\r\n                if (this._pending[i].key === key)\r\n                {\r\n                    this.queueOp('start', key, data);\r\n                    break;\r\n                }\r\n            }\r\n            return this;\r\n        }\r\n\r\n        if (scene.sys.isSleeping())\r\n        {\r\n            //  Sleeping?\r\n            scene.sys.wake(data);\r\n        }\r\n        else if (scene.sys.isBooted && !scene.sys.isActive())\r\n        {\r\n            //  Paused?\r\n            scene.sys.resume(data);\r\n        }\r\n        else\r\n        {\r\n            //  Not actually running?\r\n            this.start(key, data);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Starts the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#start\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to start.\r\n     * @param {object} [data] - Optional data object to pass to Scene.Settings and Scene.init.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    start: function (key, data)\r\n    {\r\n        //  If the Scene Manager is not running, then put the Scene into a holding pattern\r\n        if (!this.isBooted)\r\n        {\r\n            this._data[key] = {\r\n                autoStart: true,\r\n                data: data\r\n            };\r\n\r\n            return this;\r\n        }\r\n\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene)\r\n        {\r\n            //  If the Scene is already running (perhaps they called start from a launched sub-Scene?)\r\n            //  then we close it down before starting it again.\r\n            if (scene.sys.isActive() || scene.sys.isPaused())\r\n            {\r\n                scene.sys.shutdown();\r\n\r\n                scene.sys.start(data);\r\n            }\r\n            else\r\n            {\r\n                scene.sys.start(data);\r\n\r\n                var loader;\r\n    \r\n                if (scene.sys.load)\r\n                {\r\n                    loader = scene.sys.load;\r\n                }\r\n    \r\n                //  Files payload?\r\n                if (loader && scene.sys.settings.hasOwnProperty('pack'))\r\n                {\r\n                    loader.reset();\r\n    \r\n                    if (loader.addPack({ payload: scene.sys.settings.pack }))\r\n                    {\r\n                        scene.sys.settings.status = CONST.LOADING;\r\n    \r\n                        loader.once(LoaderEvents.COMPLETE, this.payloadComplete, this);\r\n    \r\n                        loader.start();\r\n    \r\n                        return this;\r\n                    }\r\n                }\r\n            }\r\n\r\n            this.bootScene(scene);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stops the given Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#stop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The Scene to stop.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    stop: function (key)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        if (scene && !scene.sys.isTransitioning())\r\n        {\r\n            scene.sys.shutdown();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sleeps one one Scene and starts the other.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#switch\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} from - The Scene to sleep.\r\n     * @param {string} to - The Scene to start.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    switch: function (from, to)\r\n    {\r\n        var sceneA = this.getScene(from);\r\n        var sceneB = this.getScene(to);\r\n\r\n        if (sceneA && sceneB && sceneA !== sceneB)\r\n        {\r\n            this.sleep(from);\r\n\r\n            if (this.isSleeping(to))\r\n            {\r\n                this.wake(to);\r\n            }\r\n            else\r\n            {\r\n                this.start(to);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Retrieves a Scene by numeric index.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#getAt\r\n     * @since 3.0.0\r\n     *\r\n     * @param {integer} index - The index of the Scene to retrieve.\r\n     *\r\n     * @return {(Phaser.Scene|undefined)} The Scene.\r\n     */\r\n    getAt: function (index)\r\n    {\r\n        return this.scenes[index];\r\n    },\r\n\r\n    /**\r\n     * Retrieves the numeric index of a Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#getIndex\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The key of the Scene.\r\n     *\r\n     * @return {integer} The index of the Scene.\r\n     */\r\n    getIndex: function (key)\r\n    {\r\n        var scene = this.getScene(key);\r\n\r\n        return this.scenes.indexOf(scene);\r\n    },\r\n\r\n    /**\r\n     * Brings a Scene to the top of the Scenes list.\r\n     *\r\n     * This means it will render above all other Scenes.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#bringToTop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    bringToTop: function (key)\r\n    {\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'bringToTop', keyA: key, keyB: null });\r\n        }\r\n        else\r\n        {\r\n            var index = this.getIndex(key);\r\n\r\n            if (index !== -1 && index < this.scenes.length)\r\n            {\r\n                var scene = this.getScene(key);\r\n\r\n                this.scenes.splice(index, 1);\r\n                this.scenes.push(scene);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sends a Scene to the back of the Scenes list.\r\n     *\r\n     * This means it will render below all other Scenes.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#sendToBack\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    sendToBack: function (key)\r\n    {\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'sendToBack', keyA: key, keyB: null });\r\n        }\r\n        else\r\n        {\r\n            var index = this.getIndex(key);\r\n\r\n            if (index !== -1 && index > 0)\r\n            {\r\n                var scene = this.getScene(key);\r\n\r\n                this.scenes.splice(index, 1);\r\n                this.scenes.unshift(scene);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Scene down one position in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#moveDown\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    moveDown: function (key)\r\n    {\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'moveDown', keyA: key, keyB: null });\r\n        }\r\n        else\r\n        {\r\n            var indexA = this.getIndex(key);\r\n\r\n            if (indexA > 0)\r\n            {\r\n                var indexB = indexA - 1;\r\n                var sceneA = this.getScene(key);\r\n                var sceneB = this.getAt(indexB);\r\n\r\n                this.scenes[indexA] = sceneB;\r\n                this.scenes[indexB] = sceneA;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Scene up one position in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#moveUp\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} key - The Scene to move.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    moveUp: function (key)\r\n    {\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'moveUp', keyA: key, keyB: null });\r\n        }\r\n        else\r\n        {\r\n            var indexA = this.getIndex(key);\r\n\r\n            if (indexA < this.scenes.length - 1)\r\n            {\r\n                var indexB = indexA + 1;\r\n                var sceneA = this.getScene(key);\r\n                var sceneB = this.getAt(indexB);\r\n\r\n                this.scenes[indexA] = sceneB;\r\n                this.scenes[indexB] = sceneA;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Scene so it is immediately above another Scene in the Scenes list.\r\n     *\r\n     * This means it will render over the top of the other Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#moveAbove\r\n     * @since 3.2.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} keyA - The Scene that Scene B will be moved above.\r\n     * @param {(string|Phaser.Scene)} keyB - The Scene to be moved.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    moveAbove: function (keyA, keyB)\r\n    {\r\n        if (keyA === keyB)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'moveAbove', keyA: keyA, keyB: keyB });\r\n        }\r\n        else\r\n        {\r\n            var indexA = this.getIndex(keyA);\r\n            var indexB = this.getIndex(keyB);\r\n\r\n            if (indexA !== -1 && indexB !== -1)\r\n            {\r\n                var tempScene = this.getAt(indexB);\r\n\r\n                //  Remove\r\n                this.scenes.splice(indexB, 1);\r\n\r\n                //  Add in new location\r\n                this.scenes.splice(indexA + 1, 0, tempScene);\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Moves a Scene so it is immediately below another Scene in the Scenes list.\r\n     *\r\n     * This means it will render behind the other Scene.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#moveBelow\r\n     * @since 3.2.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} keyA - The Scene that Scene B will be moved above.\r\n     * @param {(string|Phaser.Scene)} keyB - The Scene to be moved.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    moveBelow: function (keyA, keyB)\r\n    {\r\n        if (keyA === keyB)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'moveBelow', keyA: keyA, keyB: keyB });\r\n        }\r\n        else\r\n        {\r\n            var indexA = this.getIndex(keyA);\r\n            var indexB = this.getIndex(keyB);\r\n\r\n            if (indexA !== -1 && indexB !== -1)\r\n            {\r\n                var tempScene = this.getAt(indexB);\r\n\r\n                //  Remove\r\n                this.scenes.splice(indexB, 1);\r\n\r\n                if (indexA === 0)\r\n                {\r\n                    this.scenes.unshift(tempScene);\r\n                }\r\n                else\r\n                {\r\n                    //  Add in new location\r\n                    this.scenes.splice(indexA, 0, tempScene);\r\n                }\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Queue a Scene operation for the next update.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#queueOp\r\n     * @private\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} op - The operation to perform.\r\n     * @param {(string|Phaser.Scene)} keyA - Scene A.\r\n     * @param {(string|Phaser.Scene)} [keyB] - Scene B.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    queueOp: function (op, keyA, keyB)\r\n    {\r\n        this._queue.push({ op: op, keyA: keyA, keyB: keyB });\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Swaps the positions of two Scenes in the Scenes list.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#swapPosition\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|Phaser.Scene)} keyA - The first Scene to swap.\r\n     * @param {(string|Phaser.Scene)} keyB - The second Scene to swap.\r\n     *\r\n     * @return {Phaser.Scenes.SceneManager} This SceneManager.\r\n     */\r\n    swapPosition: function (keyA, keyB)\r\n    {\r\n        if (keyA === keyB)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (this.isProcessing)\r\n        {\r\n            this._queue.push({ op: 'swapPosition', keyA: keyA, keyB: keyB });\r\n        }\r\n        else\r\n        {\r\n            var indexA = this.getIndex(keyA);\r\n            var indexB = this.getIndex(keyB);\r\n\r\n            if (indexA !== indexB && indexA !== -1 && indexB !== -1)\r\n            {\r\n                var tempScene = this.getAt(indexA);\r\n\r\n                this.scenes[indexA] = this.scenes[indexB];\r\n                this.scenes[indexB] = tempScene;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Dumps debug information about each Scene to the developer console.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#dump\r\n     * @since 3.2.0\r\n     */\r\n    dump: function ()\r\n    {\r\n        var out = [];\r\n        var map = [ 'pending', 'init', 'start', 'loading', 'creating', 'running', 'paused', 'sleeping', 'shutdown', 'destroyed' ];\r\n\r\n        for (var i = 0; i < this.scenes.length; i++)\r\n        {\r\n            var sys = this.scenes[i].sys;\r\n\r\n            var key = (sys.settings.visible && (sys.settings.status === CONST.RUNNING || sys.settings.status === CONST.PAUSED)) ? '[*] ' : '[-] ';\r\n            key += sys.settings.key + ' (' + map[sys.settings.status] + ')';\r\n\r\n            out.push(key);\r\n        }\r\n\r\n        console.log(out.join('\\n'));\r\n    },\r\n\r\n    /**\r\n     * Destroy the SceneManager and all of its Scene's systems.\r\n     *\r\n     * @method Phaser.Scenes.SceneManager#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        for (var i = 0; i < this.scenes.length; i++)\r\n        {\r\n            var sys = this.scenes[i].sys;\r\n\r\n            sys.destroy();\r\n        }\r\n\r\n        this.update = NOOP;\r\n\r\n        this.scenes = [];\r\n\r\n        this._pending = [];\r\n        this._start = [];\r\n        this._queue = [];\r\n\r\n        this.game = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = SceneManager;\r\n"},"sourceMaps":null,"error":null,"hash":"c73e684013f1eea1c00f58b17c128277","cacheData":{"env":{}}}