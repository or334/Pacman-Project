{"id":"../../node_modules/phaser/src/gameobjects/shader/Shader.js","dependencies":[{"name":"C:\\Users\\דור\\Desktop\\pmm\\package.json","includedInParent":true,"mtime":1560952935180},{"name":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\package.json","includedInParent":true,"mtime":1561396619369},{"name":"../../utils/Class","loc":{"line":7,"column":20},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\shader\\Shader.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\Class.js"},{"name":"../components","loc":{"line":8,"column":25},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\shader\\Shader.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\components\\index.js"},{"name":"../GameObject","loc":{"line":9,"column":25},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\shader\\Shader.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\GameObject.js"},{"name":"../../utils/object/GetFastValue","loc":{"line":10,"column":27},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\shader\\Shader.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\object\\GetFastValue.js"},{"name":"../../utils/object/Merge","loc":{"line":11,"column":20},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\shader\\Shader.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\object\\Merge.js"},{"name":"../../utils/object/SetValue","loc":{"line":12,"column":23},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\shader\\Shader.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\object\\SetValue.js"},{"name":"./ShaderRender","loc":{"line":13,"column":27},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\shader\\Shader.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\shader\\ShaderRender.js"},{"name":"../components/TransformMatrix","loc":{"line":14,"column":30},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\shader\\Shader.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\components\\TransformMatrix.js"}],"generated":{"js":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar GameObject = require('../GameObject');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar Merge = require('../../utils/object/Merge');\r\nvar SetValue = require('../../utils/object/SetValue');\r\nvar ShaderRender = require('./ShaderRender');\r\nvar TransformMatrix = require('../components/TransformMatrix');\r\n\r\n/**\r\n * @classdesc\r\n * A Shader Game Object.\r\n * \r\n * This Game Object allows you to easily add a quad with its own shader into the display list, and manipulate it\r\n * as you would any other Game Object, including scaling, rotating, positioning and adding to Containers. Shaders\r\n * can be masked with either Bitmap or Geometry masks and can also be used as a Bitmap Mask for a Camera or other\r\n * Game Object. They can also be made interactive and used for input events.\r\n * \r\n * It works by taking a reference to a `Phaser.Display.BaseShader` instance, as found in the Shader Cache. These can\r\n * be created dynamically at runtime, or loaded in via the GLSL File Loader:\r\n * \r\n * ```javascript\r\n * function preload ()\r\n * {\r\n *     this.load.glsl('fire', 'shaders/fire.glsl.js');\r\n * }\r\n *  \r\n * function create ()\r\n * {\r\n *     this.add.shader('fire', 400, 300, 512, 512);\r\n * }\r\n * ```\r\n * \r\n * Please see the Phaser 3 Examples GitHub repo for examples of loading and creating shaders dynamically.\r\n * \r\n * Due to the way in which they work, you cannot directly change the alpha or blend mode of a Shader. This should\r\n * be handled via exposed uniforms in the shader code itself.\r\n * \r\n * By default a Shader will be created with a standard set of uniforms. These were added to match those\r\n * found on sites such as ShaderToy or GLSLSandbox, and provide common functionality a shader may need,\r\n * such as the timestamp, resolution or pointer position. You can replace them by specifying your own uniforms\r\n * in the Base Shader.\r\n * \r\n * These Shaders work by halting the current pipeline during rendering, creating a viewport matched to the\r\n * size of this Game Object and then renders a quad using the bound shader. At the end, the pipeline is restored.\r\n * \r\n * Because it blocks the pipeline it means it will interrupt any batching that is currently going on, so you should\r\n * use these Game Objects sparingly. If you need to have a fully batched custom shader, then please look at using\r\n * a custom pipeline instead. However, for background or special masking effects, they are extremely effective.\r\n * \r\n * @class Shader\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @webglOnly\r\n * @since 3.17.0\r\n *\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {(string|Phaser.Display.BaseShader)} key - The key of the shader to use from the shader cache, or a BaseShader instance.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {number} [width=128] - The width of the Game Object.\r\n * @param {number} [height=128] - The height of the Game Object.\r\n * @param {string[]} [textures] - Optional array of texture keys to bind to the iChannel0...3 uniforms. The textures must already exist in the Texture Manager.\r\n */\r\nvar Shader = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.ComputedSize,\r\n        Components.Depth,\r\n        Components.GetBounds,\r\n        Components.Mask,\r\n        Components.Origin,\r\n        Components.ScrollFactor,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        ShaderRender\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function Shader (scene, key, x, y, width, height, textures)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = 128; }\r\n        if (height === undefined) { height = 128; }\r\n\r\n        GameObject.call(this, scene, 'Shader');\r\n\r\n        /**\r\n         * This Game Object cannot have a blend mode, so skip all checks.\r\n         * \r\n         * @name Phaser.GameObjects.Shader#blendMode\r\n         * @type {integer}\r\n         * @private\r\n         * @since 3.17.0\r\n         */\r\n        this.blendMode = -1;\r\n\r\n        /**\r\n         * The underlying shader object being used.\r\n         * Empty by default and set during a call to the `setShader` method.\r\n         * \r\n         * @name Phaser.GameObjects.Shader#shader\r\n         * @type {Phaser.Display.BaseShader}\r\n         * @since 3.17.0\r\n         */\r\n        this.shader;\r\n\r\n        var renderer = scene.sys.renderer;\r\n\r\n        /**\r\n         * A reference to the current renderer.\r\n         * Shaders only work with the WebGL Renderer.\r\n         * \r\n         * @name Phaser.GameObjects.Shader#renderer\r\n         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n         * @since 3.17.0\r\n         */\r\n        this.renderer = renderer;\r\n\r\n        /**\r\n         * The WebGL context belonging to the renderer.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#gl\r\n         * @type {WebGLRenderingContext}\r\n         * @since 3.17.0\r\n         */\r\n        this.gl = renderer.gl;\r\n\r\n        /**\r\n         * Raw byte buffer of vertices this Shader uses.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#vertexData\r\n         * @type {ArrayBuffer}\r\n         * @since 3.17.0\r\n         */\r\n        this.vertexData = new ArrayBuffer(6 * (Float32Array.BYTES_PER_ELEMENT * 2));\r\n\r\n        /**\r\n         * The WebGL vertex buffer object this shader uses.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#vertexBuffer\r\n         * @type {WebGLBuffer}\r\n         * @since 3.17.0\r\n         */\r\n        this.vertexBuffer = renderer.createVertexBuffer(this.vertexData.byteLength, this.gl.STREAM_DRAW);\r\n\r\n        /**\r\n         * The WebGL shader program this shader uses.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#program\r\n         * @type {WebGLProgram}\r\n         * @since 3.17.0\r\n         */\r\n        this.program = null;\r\n\r\n        /**\r\n         * Uint8 view to the vertex raw buffer. Used for uploading vertex buffer resources to the GPU.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#bytes\r\n         * @type {Uint8Array}\r\n         * @since 3.17.0\r\n         */\r\n        this.bytes = new Uint8Array(this.vertexData);\r\n\r\n        /**\r\n         * Float32 view of the array buffer containing the shaders vertices.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#vertexViewF32\r\n         * @type {Float32Array}\r\n         * @since 3.17.0\r\n         */\r\n        this.vertexViewF32 = new Float32Array(this.vertexData);\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#_tempMatrix1\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.17.0\r\n         */\r\n        this._tempMatrix1 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#_tempMatrix2\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.17.0\r\n         */\r\n        this._tempMatrix2 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.GameObjects.Shader#_tempMatrix3\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.17.0\r\n         */\r\n        this._tempMatrix3 = new TransformMatrix();\r\n\r\n        /**\r\n         * The view matrix the shader uses during rendering.\r\n         * \r\n         * @name Phaser.GameObjects.Shader#viewMatrix\r\n         * @type {Float32Array}\r\n         * @readonly\r\n         * @since 3.17.0\r\n         */\r\n        this.viewMatrix = new Float32Array([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]);\r\n\r\n        /**\r\n         * The projection matrix the shader uses during rendering.\r\n         * \r\n         * @name Phaser.GameObjects.Shader#projectionMatrix\r\n         * @type {Float32Array}\r\n         * @readonly\r\n         * @since 3.17.0\r\n         */\r\n        this.projectionMatrix = new Float32Array([ 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1 ]);\r\n\r\n        /**\r\n         * The default uniform mappings. These can be added to (or replaced) by specifying your own uniforms when\r\n         * creating this shader game object. The uniforms are updated automatically during the render step.\r\n         * \r\n         * The defaults are:\r\n         * \r\n         * `resolution` (2f) - Set to the size of this shader.\r\n         * `time` (1f) - The elapsed game time, in seconds.\r\n         * `mouse` (2f) - If a pointer has been bound (with `setPointer`), this uniform contains its position each frame.\r\n         * `date` (4fv) - A vec4 containing the year, month, day and time in seconds.\r\n         * `sampleRate` (1f) - Sound sample rate. 44100 by default.\r\n         * `iChannel0...3` (sampler2D) - Input channels 0 to 3. `null` by default.\r\n         * \r\n         * @name Phaser.GameObjects.Shader#uniforms\r\n         * @type {any}\r\n         * @since 3.17.0\r\n         */\r\n        this.uniforms = {};\r\n\r\n        /**\r\n         * The pointer bound to this shader, if any.\r\n         * Set via the chainable `setPointer` method, or by modifying this property directly.\r\n         * \r\n         * @name Phaser.GameObjects.Shader#pointer\r\n         * @type {Phaser.Input.Pointer}\r\n         * @since 3.17.0\r\n         */\r\n        this.pointer = null;\r\n\r\n        /**\r\n         * The cached width of the renderer.\r\n         * \r\n         * @name Phaser.GameObjects.Shader#_rendererWidth\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.17.0\r\n         */\r\n        this._rendererWidth = renderer.width;\r\n\r\n        /**\r\n         * The cached height of the renderer.\r\n         * \r\n         * @name Phaser.GameObjects.Shader#_rendererHeight\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.17.0\r\n         */\r\n        this._rendererHeight = renderer.height;\r\n\r\n        /**\r\n         * Internal texture count tracker.\r\n         * \r\n         * @name Phaser.GameObjects.Shader#_textureCount\r\n         * @type {number}\r\n         * @private\r\n         * @since 3.17.0\r\n         */\r\n        this._textureCount = 0;\r\n\r\n        this.setPosition(x, y);\r\n        this.setSize(width, height);\r\n        this.setOrigin(0.5, 0.5);\r\n        this.setShader(key, textures);\r\n    },\r\n\r\n    /**\r\n     * Sets the fragment and, optionally, the vertex shader source code that this Shader will use.\r\n     * This will immediately delete the active shader program, if set, and then create a new one\r\n     * with the given source. Finally, the shader uniforms are initialized.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setShader\r\n     * @since 3.17.0\r\n     * \r\n     * @param {(string|Phaser.Display.BaseShader)} key - The key of the shader to use from the shader cache, or a BaseShader instance.\r\n     * @param {string[]} [textures] - Optional array of texture keys to bind to the iChannel0...3 uniforms. The textures must already exist in the Texture Manager.\r\n     * \r\n     * @return {this} This Shader instance.\r\n     */\r\n    setShader: function (key, textures)\r\n    {\r\n        if (textures === undefined) { textures = []; }\r\n\r\n        if (typeof key === 'string')\r\n        {\r\n            var cache = this.scene.sys.cache.shader;\r\n\r\n            if (!cache.has(key))\r\n            {\r\n                console.warn('Shader missing: ' + key);\r\n                return this;\r\n            }\r\n    \r\n            this.shader = cache.get(key);\r\n        }\r\n        else\r\n        {\r\n            this.shader = key;\r\n        }\r\n\r\n        var gl = this.gl;\r\n        var renderer = this.renderer;\r\n\r\n        if (this.program)\r\n        {\r\n            gl.deleteProgram(this.program);\r\n        }\r\n\r\n        var program = renderer.createProgram(this.shader.vertexSrc, this.shader.fragmentSrc);\r\n\r\n        renderer.setMatrix4(program, 'uViewMatrix', false, this.viewMatrix);\r\n        renderer.setMatrix4(program, 'uProjectionMatrix', false, this.projectionMatrix);\r\n\r\n        this.program = program;\r\n\r\n        var d = new Date();\r\n\r\n        var defaultUniforms = {\r\n            resolution: { type: '2f', value: { x: this.width, y: this.height }},\r\n            time: { type: '1f', value: 0 },\r\n            mouse: { type: '2f', value: { x: this.width / 2, y: this.height / 2 } },\r\n            date: { type: '4fv', value: [ d.getFullYear(), d.getMonth(), d.getDate(), d.getHours() * 60 * 60 + d.getMinutes() * 60 + d.getSeconds() ] },\r\n            sampleRate: { type: '1f', value: 44100.0 },\r\n            iChannel0: { type: 'sampler2D', value: null, textureData: { repeat: true } },\r\n            iChannel1: { type: 'sampler2D', value: null, textureData: { repeat: true } },\r\n            iChannel2: { type: 'sampler2D', value: null, textureData: { repeat: true } },\r\n            iChannel3: { type: 'sampler2D', value: null, textureData: { repeat: true } }\r\n        };\r\n\r\n        if (this.shader.uniforms)\r\n        {\r\n            this.uniforms = Merge(this.shader.uniforms, defaultUniforms);\r\n        }\r\n        else\r\n        {\r\n            this.uniforms = defaultUniforms;\r\n        }\r\n\r\n        for (var i = 0; i < 4; i++)\r\n        {\r\n            if (textures[i])\r\n            {\r\n                this.setSampler2D('iChannel' + i, textures[i], i);\r\n            }\r\n        }\r\n\r\n        this.initUniforms();\r\n\r\n        this.projOrtho(0, renderer.width, renderer.height, 0);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Binds a Phaser Pointer object to this Shader.\r\n     * \r\n     * The screen position of the pointer will be set in to the shaders `mouse` uniform\r\n     * automatically every frame. Call this method with no arguments to unbind the pointer.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setPointer\r\n     * @since 3.17.0\r\n     * \r\n     * @param {Phaser.Input.Pointer} [pointer] - The Pointer to bind to this shader.\r\n     * \r\n     * @return {this} This Shader instance.\r\n     */\r\n    setPointer: function (pointer)\r\n    {\r\n        this.pointer = pointer;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets this shader to use an orthographic projection matrix.\r\n     * This matrix is stored locally in the `projectionMatrix` property,\r\n     * as well as being bound to the `uProjectionMatrix` uniform.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#projOrtho\r\n     * @since 3.17.0\r\n     *\r\n     * @param {number} left - The left value.\r\n     * @param {number} right - The right value.\r\n     * @param {number} bottom - The bottom value.\r\n     * @param {number} top - The top value.\r\n     */\r\n    projOrtho: function (left, right, bottom, top)\r\n    {\r\n        var near = -1000;\r\n        var far = 1000;\r\n\r\n        var leftRight = 1 / (left - right);\r\n        var bottomTop = 1 / (bottom - top);\r\n        var nearFar = 1 / (near - far);\r\n\r\n        var pm = this.projectionMatrix;\r\n\r\n        pm[0] = -2 * leftRight;\r\n        pm[5] = -2 * bottomTop;\r\n        pm[10] = 2 * nearFar;\r\n        pm[12] = (left + right) * leftRight;\r\n        pm[13] = (top + bottom) * bottomTop;\r\n        pm[14] = (far + near) * nearFar;\r\n\r\n        var program = this.program;\r\n\r\n        this.renderer.setMatrix4(program, 'uProjectionMatrix', false, this.projectionMatrix);\r\n\r\n        this._rendererWidth = right;\r\n        this._rendererHeight = bottom;\r\n    },\r\n\r\n    // Uniforms are specified in the GLSL_ES Specification: http://www.khronos.org/registry/webgl/specs/latest/1.0/\r\n    // http://www.khronos.org/registry/gles/specs/2.0/GLSL_ES_Specification_1.0.17.pdf\r\n\r\n    /**\r\n     * Initializes all of the uniforms this shader uses.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#initUniforms\r\n     * @private\r\n     * @since 3.17.0\r\n     */\r\n    initUniforms: function ()\r\n    {\r\n        var gl = this.gl;\r\n        var map = this.renderer.glFuncMap;\r\n        var program = this.program;\r\n\r\n        this._textureCount = 0;\r\n\r\n        for (var key in this.uniforms)\r\n        {\r\n            var uniform = this.uniforms[key];\r\n\r\n            var type = uniform.type;\r\n            var data = map[type];\r\n\r\n            uniform.uniformLocation = gl.getUniformLocation(program, key);\r\n\r\n            if (type !== 'sampler2D')\r\n            {\r\n                uniform.glMatrix = data.matrix;\r\n                uniform.glValueLength = data.length;\r\n                uniform.glFunc = data.func;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets a sampler2D uniform on this shader.\r\n     * \r\n     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#setSampler2D\r\n     * @since 3.17.0\r\n     * \r\n     * @param {string} uniformKey - The key of the sampler2D uniform to be updated, i.e. `iChannel0`.\r\n     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n     * @param {integer} [textureIndex=0] - The texture index.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     * \r\n     * @return {this} This Shader instance.\r\n     */\r\n    setSampler2D: function (uniformKey, textureKey, textureIndex, textureData)\r\n    {\r\n        if (textureIndex === undefined) { textureIndex = 0; }\r\n\r\n        var textureManager = this.scene.sys.textures;\r\n\r\n        if (textureManager.exists(textureKey))\r\n        {\r\n            var frame = textureManager.getFrame(textureKey);\r\n            var uniform = this.uniforms[uniformKey];\r\n\r\n            uniform.textureKey = textureKey;\r\n            uniform.source = frame.source.image;\r\n            uniform.value = frame.glTexture;\r\n\r\n            if (textureData)\r\n            {\r\n                uniform.textureData = textureData;\r\n            }\r\n\r\n            this._textureCount = textureIndex;\r\n\r\n            this.initSampler2D(uniform);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets a property of a uniform already present on this shader.\r\n     * \r\n     * To modify the value of a uniform such as a 1f or 1i use the `value` property directly:\r\n     * \r\n     * ```javascript\r\n     * shader.setUniform('size.value', 16);\r\n     * ```\r\n     * \r\n     * You can use dot notation to access deeper values, for example:\r\n     * \r\n     * ```javascript\r\n     * shader.setUniform('resolution.value.x', 512);\r\n     * ```\r\n     * \r\n     * The change to the uniform will take effect the next time the shader is rendered.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#setUniform\r\n     * @since 3.17.0\r\n     * \r\n     * @param {string} key - The key of the uniform to modify. Use dots for deep properties, i.e. `resolution.value.x`.\r\n     * @param {any} value - The value to set into the uniform.\r\n     * \r\n     * @return {this} This Shader instance.\r\n     */\r\n    setUniform: function (key, value)\r\n    {\r\n        SetValue(this.uniforms, key, value);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the uniform object for the given key, or `null` if the uniform couldn't be found.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#getUniform\r\n     * @since 3.17.0\r\n     * \r\n     * @param {string} key - The key of the uniform to return the value for.\r\n     * \r\n     * @return {this} This Shader instance.\r\n     */\r\n    getUniform: function (key)\r\n    {\r\n        return GetFastValue(this.uniforms, key, null);\r\n    },\r\n\r\n    /**\r\n     * A short-cut method that will directly set the texture being used by the `iChannel0` sampler2D uniform.\r\n     * \r\n     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#setChannel0\r\n     * @since 3.17.0\r\n     * \r\n     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     * \r\n     * @return {this} This Shader instance.\r\n     */\r\n    setChannel0: function (textureKey, textureData)\r\n    {\r\n        return this.setSampler2D('iChannel0', textureKey, 0, textureData);\r\n    },\r\n\r\n    /**\r\n     * A short-cut method that will directly set the texture being used by the `iChannel1` sampler2D uniform.\r\n     * \r\n     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#setChannel1\r\n     * @since 3.17.0\r\n     * \r\n     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     * \r\n     * @return {this} This Shader instance.\r\n     */\r\n    setChannel1: function (textureKey, textureData)\r\n    {\r\n        return this.setSampler2D('iChannel1', textureKey, 1, textureData);\r\n    },\r\n\r\n    /**\r\n     * A short-cut method that will directly set the texture being used by the `iChannel2` sampler2D uniform.\r\n     * \r\n     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#setChannel2\r\n     * @since 3.17.0\r\n     * \r\n     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     * \r\n     * @return {this} This Shader instance.\r\n     */\r\n    setChannel2: function (textureKey, textureData)\r\n    {\r\n        return this.setSampler2D('iChannel2', textureKey, 2, textureData);\r\n    },\r\n\r\n    /**\r\n     * A short-cut method that will directly set the texture being used by the `iChannel3` sampler2D uniform.\r\n     * \r\n     * The textureKey given is the key from the Texture Manager cache. You cannot use a single frame\r\n     * from a texture, only the full image. Also, lots of shaders expect textures to be power-of-two sized.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#setChannel3\r\n     * @since 3.17.0\r\n     * \r\n     * @param {string} textureKey - The key of the texture, as stored in the Texture Manager. Must already be loaded.\r\n     * @param {any} [textureData] - Additional texture data.\r\n     * \r\n     * @return {this} This Shader instance.\r\n     */\r\n    setChannel3: function (textureKey, textureData)\r\n    {\r\n        return this.setSampler2D('iChannel3', textureKey, 3, textureData);\r\n    },\r\n\r\n    /**\r\n     * Internal method that takes a sampler2D uniform and prepares it for use by setting the\r\n     * gl texture parameters.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#initSampler2D\r\n     * @private\r\n     * @since 3.17.0\r\n     * \r\n     * @param {any} uniform - The sampler2D uniform to process.\r\n     */\r\n    initSampler2D: function (uniform)\r\n    {\r\n        if (!uniform.value)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var gl = this.gl;\r\n\r\n        gl.activeTexture(gl.TEXTURE0 + this._textureCount);\r\n        gl.bindTexture(gl.TEXTURE_2D, uniform.value);\r\n    \r\n        //  Extended texture data\r\n\r\n        var data = uniform.textureData;\r\n\r\n        if (data)\r\n        {\r\n            // https://developer.mozilla.org/en-US/docs/Web/API/WebGLRenderingContext/texImage2D\r\n    \r\n            //  mag / minFilter can be: gl.LINEAR, gl.LINEAR_MIPMAP_LINEAR or gl.NEAREST\r\n            //  wrapS/T can be: gl.CLAMP_TO_EDGE or gl.REPEAT\r\n            //  format can be: gl.LUMINANCE or gl.RGBA\r\n    \r\n            var magFilter = gl[GetFastValue(data, 'magFilter', 'linear').toUpperCase()];\r\n            var minFilter = gl[GetFastValue(data, 'minFilter', 'linear').toUpperCase()];\r\n            var wrapS = gl[GetFastValue(data, 'wrapS', 'repeat').toUpperCase()];\r\n            var wrapT = gl[GetFastValue(data, 'wrapT', 'repeat').toUpperCase()];\r\n            var format = gl[GetFastValue(data, 'format', 'rgba').toUpperCase()];\r\n\r\n            if (data.repeat)\r\n            {\r\n                wrapS = gl.REPEAT;\r\n                wrapT = gl.REPEAT;\r\n            }\r\n\r\n            gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, !!data.flipY);\r\n\r\n            if (data.width)\r\n            {\r\n                var width = GetFastValue(data, 'width', 512);\r\n                var height = GetFastValue(data, 'height', 2);\r\n                var border = GetFastValue(data, 'border', 0);\r\n    \r\n                //  texImage2D(GLenum target, GLint level, GLenum internalformat, GLsizei width, GLsizei height, GLint border, GLenum format, GLenum type, ArrayBufferView? pixels)\r\n                gl.texImage2D(gl.TEXTURE_2D, 0, format, width, height, border, format, gl.UNSIGNED_BYTE, null);\r\n            }\r\n            else\r\n            {\r\n                //  texImage2D(GLenum target, GLint level, GLenum internalformat, GLenum format, GLenum type, ImageData? pixels)\r\n                gl.texImage2D(gl.TEXTURE_2D, 0, format, gl.RGBA, gl.UNSIGNED_BYTE, uniform.source);\r\n            }\r\n    \r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, magFilter);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, minFilter);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, wrapS);\r\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, wrapT);\r\n        }\r\n\r\n        this.renderer.setProgram(this.program);\r\n    \r\n        gl.uniform1i(uniform.uniformLocation, this._textureCount);\r\n    \r\n        this._textureCount++;\r\n    },\r\n\r\n    /**\r\n     * Synchronizes all of the uniforms this shader uses.\r\n     * Each uniforms gl function is called in turn.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#syncUniforms\r\n     * @private\r\n     * @since 3.17.0\r\n     */\r\n    syncUniforms: function ()\r\n    {\r\n        var gl = this.gl;\r\n\r\n        var uniforms = this.uniforms;\r\n        var uniform;\r\n        var length;\r\n        var glFunc;\r\n        var location;\r\n        var value;\r\n        var textureCount = 0;\r\n    \r\n        for (var key in uniforms)\r\n        {\r\n            uniform = uniforms[key];\r\n\r\n            glFunc = uniform.glFunc;\r\n            length = uniform.glValueLength;\r\n            location = uniform.uniformLocation;\r\n            value = uniform.value;\r\n\r\n            if (length === 1)\r\n            {\r\n                if (uniform.glMatrix)\r\n                {\r\n                    glFunc.call(gl, location, uniform.transpose, value);\r\n                }\r\n                else\r\n                {\r\n                    glFunc.call(gl, location, value);\r\n                }\r\n            }\r\n            else if (length === 2)\r\n            {\r\n                glFunc.call(gl, location, value.x, value.y);\r\n            }\r\n            else if (length === 3)\r\n            {\r\n                glFunc.call(gl, location, value.x, value.y, value.z);\r\n            }\r\n            else if (length === 4)\r\n            {\r\n                glFunc.call(gl, location, value.x, value.y, value.z, value.w);\r\n            }\r\n            else if (uniform.type === 'sampler2D')\r\n            {\r\n                gl.activeTexture(gl['TEXTURE' + textureCount]);\r\n\r\n                gl.bindTexture(gl.TEXTURE_2D, value);\r\n\r\n                gl.uniform1i(location, textureCount);\r\n\r\n                textureCount++;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called automatically during render.\r\n     * \r\n     * This method performs matrix ITRS and then stores the resulting value in the `uViewMatrix` uniform.\r\n     * It then sets up the vertex buffer and shader, updates and syncs the uniforms ready\r\n     * for flush to be called.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#load\r\n     * @since 3.17.0\r\n     * \r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} matrix2D - The transform matrix to use during rendering.\r\n     */\r\n    load: function (matrix2D)\r\n    {\r\n        //  ITRS\r\n\r\n        var width = this.width;\r\n        var height = this.height;\r\n        var renderer = this.renderer;\r\n        var program = this.program;\r\n\r\n        var x = -this._displayOriginX;\r\n        var y = -this._displayOriginY;\r\n\r\n        var vm = this.viewMatrix;\r\n\r\n        vm[0] = matrix2D[0];\r\n        vm[1] = matrix2D[1];\r\n        vm[4] = matrix2D[2];\r\n        vm[5] = matrix2D[3];\r\n        vm[8] = matrix2D[4];\r\n        vm[9] = matrix2D[5];\r\n        vm[12] = vm[0] * x + vm[4] * y;\r\n        vm[13] = vm[1] * x + vm[5] * y;\r\n\r\n        this.renderer.setMatrix4(program, 'uViewMatrix', false, this.viewMatrix);\r\n\r\n        //  Update common uniforms\r\n\r\n        var uniforms = this.uniforms;\r\n        var res = uniforms.resolution;\r\n\r\n        res.value.x = width;\r\n        res.value.y = height;\r\n\r\n        uniforms.time.value = renderer.game.loop.getDuration();\r\n\r\n        var pointer = this.pointer;\r\n\r\n        if (pointer)\r\n        {\r\n            var mouse = uniforms.mouse;\r\n\r\n            var px = pointer.x / width;\r\n            var py = 1 - pointer.y / height;\r\n    \r\n            mouse.value.x = px.toFixed(2);\r\n            mouse.value.y = py.toFixed(2);\r\n        }\r\n\r\n        this.syncUniforms();\r\n    },\r\n\r\n    /**\r\n     * Called automatically during render.\r\n     * \r\n     * Sets the active shader, loads the vertex buffer and then draws.\r\n     * \r\n     * @method Phaser.GameObjects.Shader#flush\r\n     * @since 3.17.0\r\n     */\r\n    flush: function ()\r\n    {\r\n        //  Bind\r\n\r\n        var width = this.width;\r\n        var height = this.height;\r\n        var program = this.program;\r\n\r\n        var gl = this.gl;\r\n        var vertexBuffer = this.vertexBuffer;\r\n        var renderer = this.renderer;\r\n        var vertexSize = Float32Array.BYTES_PER_ELEMENT * 2;\r\n\r\n        renderer.setProgram(program);\r\n        renderer.setVertexBuffer(vertexBuffer);\r\n\r\n        var location = gl.getAttribLocation(program, 'inPosition');\r\n\r\n        if (location !== -1)\r\n        {\r\n            gl.enableVertexAttribArray(location);\r\n\r\n            gl.vertexAttribPointer(location, 2, gl.FLOAT, false, vertexSize, 0);\r\n        }\r\n\r\n        //  Draw\r\n\r\n        var vf = this.vertexViewF32;\r\n\r\n        vf[3] = height;\r\n        vf[4] = width;\r\n        vf[5] = height;\r\n        vf[8] = width;\r\n        vf[9] = height;\r\n        vf[10] = width;\r\n\r\n        //  Flush\r\n\r\n        var vertexCount = 6;\r\n\r\n        gl.bufferSubData(gl.ARRAY_BUFFER, 0, this.bytes.subarray(0, vertexCount * vertexSize));\r\n\r\n        gl.drawArrays(gl.TRIANGLES, 0, vertexCount);\r\n    },\r\n\r\n    /**\r\n     * A NOOP method so you can pass a Shader to a Container.\r\n     * Calling this method will do nothing. It is intentionally empty.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setAlpha\r\n     * @private\r\n     * @since 3.17.0\r\n     */\r\n    setAlpha: function ()\r\n    {\r\n    },\r\n    \r\n    /**\r\n     * A NOOP method so you can pass a Shader to a Container.\r\n     * Calling this method will do nothing. It is intentionally empty.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#setBlendMode\r\n     * @private\r\n     * @since 3.17.0\r\n     */\r\n    setBlendMode: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.Shader#preDestroy\r\n     * @protected\r\n     * @since 3.17.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        var gl = this.gl;\r\n\r\n        gl.deleteProgram(this.program);\r\n        gl.deleteBuffer(this.vertexBuffer);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = Shader;\r\n"},"sourceMaps":null,"error":null,"hash":"664445d2bf6d177f379839f6b0475410","cacheData":{"env":{}}}