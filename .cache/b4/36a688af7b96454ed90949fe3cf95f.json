{"id":"../../node_modules/phaser/src/tweens/tween/Tween.js","dependencies":[{"name":"C:\\Users\\Admin\\Desktop\\pmm\\package.json","includedInParent":true,"mtime":1560952935180},{"name":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\package.json","includedInParent":true,"mtime":1561134727120},{"name":"../../utils/Class","loc":{"line":7,"column":20},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\tweens\\tween\\Tween.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\Class.js"},{"name":"../../gameobjects/GameObjectCreator","loc":{"line":8,"column":32},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\tweens\\tween\\Tween.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\GameObjectCreator.js"},{"name":"../../gameobjects/GameObjectFactory","loc":{"line":9,"column":32},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\tweens\\tween\\Tween.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\GameObjectFactory.js"},{"name":"./const","loc":{"line":10,"column":26},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\tweens\\tween\\Tween.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\tweens\\tween\\const.js"}],"generated":{"js":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar GameObjectCreator = require('../../gameobjects/GameObjectCreator');\r\nvar GameObjectFactory = require('../../gameobjects/GameObjectFactory');\r\nvar TWEEN_CONST = require('./const');\r\n\r\n/**\r\n * @classdesc\r\n * A Tween is able to manipulate the properties of one or more objects to any given value, based\r\n * on a duration and type of ease. They are rarely instantiated directly and instead should be\r\n * created via the TweenManager.\r\n *\r\n * @class Tween\r\n * @memberof Phaser.Tweens\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {(Phaser.Tweens.TweenManager|Phaser.Tweens.Timeline)} parent - A reference to the parent of this Tween. Either the Tween Manager or a Tween Timeline instance.\r\n * @param {Phaser.Types.Tweens.TweenDataConfig[]} data - An array of TweenData objects, each containing a unique property to be tweened.\r\n * @param {array} targets - An array of targets to be tweened.\r\n */\r\nvar Tween = new Class({\r\n\r\n    initialize:\r\n\r\n    function Tween (parent, data, targets)\r\n    {\r\n        /**\r\n         * A reference to the parent of this Tween.\r\n         * Either the Tween Manager or a Tween Timeline instance.\r\n         *\r\n         * @name Phaser.Tweens.Tween#parent\r\n         * @type {(Phaser.Tweens.TweenManager|Phaser.Tweens.Timeline)}\r\n         * @since 3.0.0\r\n         */\r\n        this.parent = parent;\r\n\r\n        /**\r\n         * Is the parent of this Tween a Timeline?\r\n         *\r\n         * @name Phaser.Tweens.Tween#parentIsTimeline\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.parentIsTimeline = parent.hasOwnProperty('isTimeline');\r\n\r\n        /**\r\n         * An array of TweenData objects, each containing a unique property and target being tweened.\r\n         *\r\n         * @name Phaser.Tweens.Tween#data\r\n         * @type {Phaser.Types.Tweens.TweenDataConfig[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.data = data;\r\n\r\n        /**\r\n         * The cached length of the data array.\r\n         *\r\n         * @name Phaser.Tweens.Tween#totalData\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.totalData = data.length;\r\n\r\n        /**\r\n         * An array of references to the target/s this Tween is operating on.\r\n         *\r\n         * @name Phaser.Tweens.Tween#targets\r\n         * @type {object[]}\r\n         * @since 3.0.0\r\n         */\r\n        this.targets = targets;\r\n\r\n        /**\r\n         * Cached target total (not necessarily the same as the data total)\r\n         *\r\n         * @name Phaser.Tweens.Tween#totalTargets\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.totalTargets = targets.length;\r\n\r\n        /**\r\n         * If `true` then duration, delay, etc values are all frame totals.\r\n         *\r\n         * @name Phaser.Tweens.Tween#useFrames\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.useFrames = false;\r\n\r\n        /**\r\n         * Scales the time applied to this Tween. A value of 1 runs in real-time. A value of 0.5 runs 50% slower, and so on.\r\n         * Value isn't used when calculating total duration of the tween, it's a run-time delta adjustment only.\r\n         *\r\n         * @name Phaser.Tweens.Tween#timeScale\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.timeScale = 1;\r\n\r\n        /**\r\n         * Loop this tween? Can be -1 for an infinite loop, or an integer.\r\n         * When enabled it will play through ALL TweenDatas again. Use TweenData.repeat to loop a single element.\r\n         *\r\n         * @name Phaser.Tweens.Tween#loop\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.loop = 0;\r\n\r\n        /**\r\n         * Time in ms/frames before the tween loops.\r\n         *\r\n         * @name Phaser.Tweens.Tween#loopDelay\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.loopDelay = 0;\r\n\r\n        /**\r\n         * How many loops are left to run?\r\n         *\r\n         * @name Phaser.Tweens.Tween#loopCounter\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.loopCounter = 0;\r\n\r\n        /**\r\n         * Time in ms/frames before the 'onComplete' event fires. This never fires if loop = -1 (as it never completes)\r\n         *\r\n         * @name Phaser.Tweens.Tween#completeDelay\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.completeDelay = 0;\r\n\r\n        /**\r\n         * Countdown timer (used by timeline offset, loopDelay and completeDelay)\r\n         *\r\n         * @name Phaser.Tweens.Tween#countdown\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.countdown = 0;\r\n\r\n        /**\r\n         * Set only if this Tween is part of a Timeline.\r\n         *\r\n         * @name Phaser.Tweens.Tween#offset\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.offset = 0;\r\n\r\n        /**\r\n         * Set only if this Tween is part of a Timeline. The calculated offset amount.\r\n         *\r\n         * @name Phaser.Tweens.Tween#calculatedOffset\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.calculatedOffset = 0;\r\n\r\n        /**\r\n         * The current state of the tween\r\n         *\r\n         * @name Phaser.Tweens.Tween#state\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.state = TWEEN_CONST.PENDING_ADD;\r\n\r\n        /**\r\n         * The state of the tween when it was paused (used by Resume)\r\n         *\r\n         * @name Phaser.Tweens.Tween#_pausedState\r\n         * @type {integer}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._pausedState = TWEEN_CONST.PENDING_ADD;\r\n\r\n        /**\r\n         * Does the Tween start off paused? (if so it needs to be started with Tween.play)\r\n         *\r\n         * @name Phaser.Tweens.Tween#paused\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.paused = false;\r\n\r\n        /**\r\n         * Elapsed time in ms/frames of this run through the Tween.\r\n         *\r\n         * @name Phaser.Tweens.Tween#elapsed\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.elapsed = 0;\r\n\r\n        /**\r\n         * Total elapsed time in ms/frames of the entire Tween, including looping.\r\n         *\r\n         * @name Phaser.Tweens.Tween#totalElapsed\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.totalElapsed = 0;\r\n\r\n        /**\r\n         * Time in ms/frames for the whole Tween to play through once, excluding loop amounts and loop delays.\r\n         *\r\n         * @name Phaser.Tweens.Tween#duration\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.duration = 0;\r\n\r\n        /**\r\n         * Value between 0 and 1. The amount through the Tween, excluding loops.\r\n         *\r\n         * @name Phaser.Tweens.Tween#progress\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.progress = 0;\r\n\r\n        /**\r\n         * Time in ms/frames for the Tween to complete (including looping)\r\n         *\r\n         * @name Phaser.Tweens.Tween#totalDuration\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.totalDuration = 0;\r\n\r\n        /**\r\n         * Value between 0 and 1. The amount through the entire Tween, including looping.\r\n         *\r\n         * @name Phaser.Tweens.Tween#totalProgress\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.totalProgress = 0;\r\n\r\n        /**\r\n         * An object containing the various Tween callback references.\r\n         *\r\n         * @name Phaser.Tweens.Tween#callbacks\r\n         * @type {object}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.callbacks = {\r\n            onComplete: null,\r\n            onLoop: null,\r\n            onRepeat: null,\r\n            onStart: null,\r\n            onUpdate: null,\r\n            onYoyo: null\r\n        };\r\n\r\n        this.callbackScope;\r\n    },\r\n\r\n    /**\r\n     * Returns the current value of the Tween.\r\n     *\r\n     * @method Phaser.Tweens.Tween#getValue\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The value of the Tween.\r\n     */\r\n    getValue: function ()\r\n    {\r\n        return this.data[0].current;\r\n    },\r\n\r\n    /**\r\n     * Set the scale the time applied to this Tween. A value of 1 runs in real-time. A value of 0.5 runs 50% slower, and so on.\r\n     *\r\n     * @method Phaser.Tweens.Tween#setTimeScale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The scale factor for timescale.\r\n     *\r\n     * @return {this} - This Tween instance.\r\n     */\r\n    setTimeScale: function (value)\r\n    {\r\n        this.timeScale = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Returns the scale of the time applied to this Tween.\r\n     *\r\n     * @method Phaser.Tweens.Tween#getTimeScale\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The timescale of this tween (between 0 and 1)\r\n     */\r\n    getTimeScale: function ()\r\n    {\r\n        return this.timeScale;\r\n    },\r\n\r\n    /**\r\n     * Checks if the Tween is currently active.\r\n     *\r\n     * @method Phaser.Tweens.Tween#isPlaying\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} `true` if the Tween is active, otherwise `false`.\r\n     */\r\n    isPlaying: function ()\r\n    {\r\n        return (this.state === TWEEN_CONST.ACTIVE);\r\n    },\r\n\r\n    /**\r\n     * Checks if the Tween is currently paused.\r\n     *\r\n     * @method Phaser.Tweens.Tween#isPaused\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} `true` if the Tween is paused, otherwise `false`.\r\n     */\r\n    isPaused: function ()\r\n    {\r\n        return (this.state === TWEEN_CONST.PAUSED);\r\n    },\r\n\r\n    /**\r\n     * See if this Tween is currently acting upon the given target.\r\n     *\r\n     * @method Phaser.Tweens.Tween#hasTarget\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} target - The target to check against this Tween.\r\n     *\r\n     * @return {boolean} `true` if the given target is a target of this Tween, otherwise `false`.\r\n     */\r\n    hasTarget: function (target)\r\n    {\r\n        return (this.targets.indexOf(target) !== -1);\r\n    },\r\n\r\n    /**\r\n     * Updates the value of a property of this Tween to a new value, without adjusting the\r\n     * Tween duration or current progress.\r\n     * \r\n     * You can optionally tell it to set the 'start' value to be the current value (before the change).\r\n     *\r\n     * @method Phaser.Tweens.Tween#updateTo\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} key - The property to set the new value for.\r\n     * @param {*} value - The new value of the property.\r\n     * @param {boolean} [startToCurrent=false] - Should this change set the start value to be the current value?\r\n     *\r\n     * @return {this} - This Tween instance.\r\n     */\r\n    updateTo: function (key, value, startToCurrent)\r\n    {\r\n        if (startToCurrent === undefined) { startToCurrent = false; }\r\n\r\n        for (var i = 0; i < this.totalData; i++)\r\n        {\r\n            var tweenData = this.data[i];\r\n\r\n            if (tweenData.key === key)\r\n            {\r\n                tweenData.end = value;\r\n\r\n                if (startToCurrent)\r\n                {\r\n                    tweenData.start = tweenData.current;\r\n                }\r\n\r\n                break;\r\n            }\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Restarts the tween from the beginning.\r\n     *\r\n     * @method Phaser.Tweens.Tween#restart\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} This Tween instance.\r\n     */\r\n    restart: function ()\r\n    {\r\n        if (this.state === TWEEN_CONST.PENDING_ADD)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        if (this.state === TWEEN_CONST.REMOVED)\r\n        {\r\n            this.seek(0);\r\n            this.parent.makeActive(this);\r\n        }\r\n        else\r\n        {\r\n            this.stop();\r\n            this.play();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal method that calculates the overall duration of the Tween.\r\n     *\r\n     * @method Phaser.Tweens.Tween#calcDuration\r\n     * @since 3.0.0\r\n     */\r\n    calcDuration: function ()\r\n    {\r\n        var max = 0;\r\n\r\n        var data = this.data;\r\n\r\n        for (var i = 0; i < this.totalData; i++)\r\n        {\r\n            var tweenData = data[i];\r\n\r\n            //  Set t1 (duration + hold + yoyo)\r\n            tweenData.t1 = tweenData.duration + tweenData.hold;\r\n\r\n            if (tweenData.yoyo)\r\n            {\r\n                tweenData.t1 += tweenData.duration;\r\n            }\r\n\r\n            //  Set t2 (repeatDelay + duration + hold + yoyo)\r\n            tweenData.t2 = tweenData.t1 + tweenData.repeatDelay;\r\n\r\n            //  Total Duration\r\n            tweenData.totalDuration = tweenData.delay + tweenData.t1;\r\n\r\n            if (tweenData.repeat === -1)\r\n            {\r\n                tweenData.totalDuration += (tweenData.t2 * 999999999999);\r\n            }\r\n            else if (tweenData.repeat > 0)\r\n            {\r\n                tweenData.totalDuration += (tweenData.t2 * tweenData.repeat);\r\n            }\r\n\r\n            if (tweenData.totalDuration > max)\r\n            {\r\n                //  Get the longest TweenData from the Tween, used to calculate the Tween TD\r\n                max = tweenData.totalDuration;\r\n            }\r\n        }\r\n\r\n        //  Excludes loop values\r\n\r\n        //  If duration has been set to 0 then we give it a super-low value so that it always\r\n        //  renders at least 1 frame, but no more, without causing divided by zero errors elsewhere.\r\n        this.duration = Math.max(max, 0.001);\r\n\r\n        this.loopCounter = (this.loop === -1) ? 999999999999 : this.loop;\r\n\r\n        if (this.loopCounter > 0)\r\n        {\r\n            this.totalDuration = this.duration + this.completeDelay + ((this.duration + this.loopDelay) * this.loopCounter);\r\n        }\r\n        else\r\n        {\r\n            this.totalDuration = this.duration + this.completeDelay;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Called by TweenManager.preUpdate as part of its loop to check pending and active tweens.\r\n     * Should not be called directly.\r\n     *\r\n     * @method Phaser.Tweens.Tween#init\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} Returns `true` if this Tween should be moved from the pending list to the active list by the Tween Manager.\r\n     */\r\n    init: function ()\r\n    {\r\n        var data = this.data;\r\n        var totalTargets = this.totalTargets;\r\n\r\n        for (var i = 0; i < this.totalData; i++)\r\n        {\r\n            var tweenData = data[i];\r\n            var target = tweenData.target;\r\n            var gen = tweenData.gen;\r\n\r\n            tweenData.delay = gen.delay(i, totalTargets, target);\r\n            tweenData.duration = Math.max(gen.duration(i, totalTargets, target), 0.001);\r\n            tweenData.hold = gen.hold(i, totalTargets, target);\r\n            tweenData.repeat = gen.repeat(i, totalTargets, target);\r\n            tweenData.repeatDelay = gen.repeatDelay(i, totalTargets, target);\r\n        }\r\n\r\n        this.calcDuration();\r\n\r\n        this.progress = 0;\r\n        this.totalProgress = 0;\r\n        this.elapsed = 0;\r\n        this.totalElapsed = 0;\r\n\r\n        //  You can't have a paused Tween if it's part of a Timeline\r\n        if (this.paused && !this.parentIsTimeline)\r\n        {\r\n            this.state = TWEEN_CONST.PENDING_ADD;\r\n            this._pausedState = TWEEN_CONST.INIT;\r\n\r\n            return false;\r\n        }\r\n        else\r\n        {\r\n            this.state = TWEEN_CONST.INIT;\r\n\r\n            return true;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method that advances to the next state of the Tween during playback.\r\n     *\r\n     * @method Phaser.Tweens.Tween#nextState\r\n     * @since 3.0.0\r\n     */\r\n    nextState: function ()\r\n    {\r\n        if (this.loopCounter > 0)\r\n        {\r\n            this.elapsed = 0;\r\n            this.progress = 0;\r\n            this.loopCounter--;\r\n\r\n            var onLoop = this.callbacks.onLoop;\r\n\r\n            if (onLoop)\r\n            {\r\n                onLoop.params[1] = this.targets;\r\n\r\n                onLoop.func.apply(onLoop.scope, onLoop.params);\r\n            }\r\n\r\n            this.resetTweenData(true);\r\n\r\n            if (this.loopDelay > 0)\r\n            {\r\n                this.countdown = this.loopDelay;\r\n                this.state = TWEEN_CONST.LOOP_DELAY;\r\n            }\r\n            else\r\n            {\r\n                this.state = TWEEN_CONST.ACTIVE;\r\n            }\r\n        }\r\n        else if (this.completeDelay > 0)\r\n        {\r\n            this.countdown = this.completeDelay;\r\n            this.state = TWEEN_CONST.COMPLETE_DELAY;\r\n        }\r\n        else\r\n        {\r\n            var onComplete = this.callbacks.onComplete;\r\n\r\n            if (onComplete)\r\n            {\r\n                onComplete.params[1] = this.targets;\r\n\r\n                onComplete.func.apply(onComplete.scope, onComplete.params);\r\n            }\r\n\r\n            this.state = TWEEN_CONST.PENDING_REMOVE;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Pauses the Tween immediately. Use `resume` to continue playback.\r\n     *\r\n     * @method Phaser.Tweens.Tween#pause\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} - This Tween instance.\r\n     */\r\n    pause: function ()\r\n    {\r\n        if (this.state === TWEEN_CONST.PAUSED)\r\n        {\r\n            return this;\r\n        }\r\n\r\n        this.paused = true;\r\n\r\n        this._pausedState = this.state;\r\n\r\n        this.state = TWEEN_CONST.PAUSED;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Starts a Tween playing.\r\n     * \r\n     * You only need to call this method if you have configured the tween to be paused on creation.\r\n     * \r\n     * If the Tween is already playing, calling this method again will have no effect. If you wish to\r\n     * restart the Tween, use `Tween.restart` instead.\r\n     * \r\n     * Calling this method after the Tween has completed will start the Tween playing again from the start.\r\n     * This is the same as calling `Tween.seek(0)` and then `Tween.play()`.\r\n     *\r\n     * @method Phaser.Tweens.Tween#play\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} [resetFromTimeline=false] - Is this Tween being played as part of a Timeline?\r\n     *\r\n     * @return {this} This Tween instance.\r\n     */\r\n    play: function (resetFromTimeline)\r\n    {\r\n        if (resetFromTimeline === undefined) { resetFromTimeline = false; }\r\n\r\n        if (this.state === TWEEN_CONST.ACTIVE || this.state === TWEEN_CONST.PENDING_ADD)\r\n        {\r\n            return this;\r\n        }\r\n        else if (this.state === TWEEN_CONST.PENDING_REMOVE || this.state === TWEEN_CONST.REMOVED)\r\n        {\r\n            this.seek(0);\r\n            this.parent.makeActive(this);\r\n\r\n            return this;\r\n        }\r\n\r\n        var onStart = this.callbacks.onStart;\r\n\r\n        if (this.parentIsTimeline)\r\n        {\r\n            this.resetTweenData(resetFromTimeline);\r\n\r\n            if (this.calculatedOffset === 0)\r\n            {\r\n                if (onStart)\r\n                {\r\n                    onStart.params[1] = this.targets;\r\n\r\n                    onStart.func.apply(onStart.scope, onStart.params);\r\n                }\r\n\r\n                this.state = TWEEN_CONST.ACTIVE;\r\n            }\r\n            else\r\n            {\r\n                this.countdown = this.calculatedOffset;\r\n\r\n                this.state = TWEEN_CONST.OFFSET_DELAY;\r\n            }\r\n        }\r\n        else if (this.paused)\r\n        {\r\n            this.paused = false;\r\n\r\n            this.parent.makeActive(this);\r\n        }\r\n        else\r\n        {\r\n            this.resetTweenData(resetFromTimeline);\r\n\r\n            this.state = TWEEN_CONST.ACTIVE;\r\n\r\n            if (onStart)\r\n            {\r\n                onStart.params[1] = this.targets;\r\n\r\n                onStart.func.apply(onStart.scope, onStart.params);\r\n            }\r\n\r\n            this.parent.makeActive(this);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal method that resets all of the Tween Data, including the progress and elapsed values.\r\n     *\r\n     * @method Phaser.Tweens.Tween#resetTweenData\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} resetFromLoop - Has this method been called as part of a loop?\r\n     */\r\n    resetTweenData: function (resetFromLoop)\r\n    {\r\n        var data = this.data;\r\n\r\n        for (var i = 0; i < this.totalData; i++)\r\n        {\r\n            var tweenData = data[i];\r\n\r\n            tweenData.progress = 0;\r\n            tweenData.elapsed = 0;\r\n\r\n            tweenData.repeatCounter = (tweenData.repeat === -1) ? 999999999999 : tweenData.repeat;\r\n\r\n            if (resetFromLoop)\r\n            {\r\n                tweenData.start = tweenData.getStartValue(tweenData.target, tweenData.key, tweenData.start);\r\n\r\n                tweenData.end = tweenData.getEndValue(tweenData.target, tweenData.key, tweenData.end);\r\n\r\n                tweenData.current = tweenData.start;\r\n\r\n                tweenData.state = TWEEN_CONST.PLAYING_FORWARD;\r\n            }\r\n            else\r\n            {\r\n                tweenData.state = TWEEN_CONST.PENDING_RENDER;\r\n            }\r\n\r\n            if (tweenData.delay > 0)\r\n            {\r\n                tweenData.elapsed = tweenData.delay;\r\n                tweenData.state = TWEEN_CONST.DELAY;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Resumes the playback of a previously paused Tween.\r\n     *\r\n     * @method Phaser.Tweens.Tween#resume\r\n     * @since 3.0.0\r\n     *\r\n     * @return {this} - This Tween instance.\r\n     */\r\n    resume: function ()\r\n    {\r\n        if (this.state === TWEEN_CONST.PAUSED)\r\n        {\r\n            this.paused = false;\r\n\r\n            this.state = this._pausedState;\r\n        }\r\n        else\r\n        {\r\n            this.play();\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Attempts to seek to a specific position in a Tween.\r\n     *\r\n     * @method Phaser.Tweens.Tween#seek\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} toPosition - A value between 0 and 1 which represents the progress point to seek to.\r\n     *\r\n     * @return {this} This Tween instance.\r\n     */\r\n    seek: function (toPosition)\r\n    {\r\n        var data = this.data;\r\n\r\n        for (var i = 0; i < this.totalData; i++)\r\n        {\r\n            //  This won't work with loop > 0 yet\r\n            var ms = this.totalDuration * toPosition;\r\n\r\n            var tweenData = data[i];\r\n            var progress = 0;\r\n            var elapsed = 0;\r\n\r\n            if (ms <= tweenData.delay)\r\n            {\r\n                progress = 0;\r\n                elapsed = 0;\r\n            }\r\n            else if (ms >= tweenData.totalDuration)\r\n            {\r\n                progress = 1;\r\n                elapsed = tweenData.duration;\r\n            }\r\n            else if (ms > tweenData.delay && ms <= tweenData.t1)\r\n            {\r\n                //  Keep it zero bound\r\n                ms = Math.max(0, ms - tweenData.delay);\r\n\r\n                //  Somewhere in the first playthru range\r\n                progress = ms / tweenData.t1;\r\n                elapsed = tweenData.duration * progress;\r\n            }\r\n            else if (ms > tweenData.t1 && ms < tweenData.totalDuration)\r\n            {\r\n                //  Somewhere in repeat land\r\n                ms -= tweenData.delay;\r\n                ms -= tweenData.t1;\r\n\r\n                // var repeats = Math.floor(ms / tweenData.t2);\r\n\r\n                //  remainder\r\n                ms = ((ms / tweenData.t2) % 1) * tweenData.t2;\r\n\r\n                if (ms > tweenData.repeatDelay)\r\n                {\r\n                    progress = ms / tweenData.t1;\r\n                    elapsed = tweenData.duration * progress;\r\n                }\r\n            }\r\n\r\n            tweenData.progress = progress;\r\n            tweenData.elapsed = elapsed;\r\n\r\n            var v = tweenData.ease(tweenData.progress);\r\n\r\n            tweenData.current = tweenData.start + ((tweenData.end - tweenData.start) * v);\r\n\r\n            tweenData.target[tweenData.key] = tweenData.current;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets an event based callback to be invoked during playback.\r\n     *\r\n     * @method Phaser.Tweens.Tween#setCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} type - Type of the callback.\r\n     * @param {function} callback - Callback function.\r\n     * @param {array} [params] - An array of parameters for specified callbacks types.\r\n     * @param {object} [scope] - The context the callback will be invoked in.\r\n     *\r\n     * @return {this} This Tween instance.\r\n     */\r\n    setCallback: function (type, callback, params, scope)\r\n    {\r\n        this.callbacks[type] = { func: callback, scope: scope, params: params };\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Flags the Tween as being complete, whatever stage of progress it is at.\r\n     *\r\n     * If an onComplete callback has been defined it will automatically invoke it, unless a `delay`\r\n     * argument is provided, in which case the Tween will delay for that period of time before calling the callback.\r\n     *\r\n     * If you don't need a delay, or have an onComplete callback, then call `Tween.stop` instead.\r\n     *\r\n     * @method Phaser.Tweens.Tween#complete\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} [delay=0] - The time to wait before invoking the complete callback. If zero it will fire immediately.\r\n     *\r\n     * @return {this} This Tween instance.\r\n     */\r\n    complete: function (delay)\r\n    {\r\n        if (delay === undefined) { delay = 0; }\r\n\r\n        if (delay)\r\n        {\r\n            this.countdown = delay;\r\n            this.state = TWEEN_CONST.COMPLETE_DELAY;\r\n        }\r\n        else\r\n        {\r\n            var onComplete = this.callbacks.onComplete;\r\n\r\n            if (onComplete)\r\n            {\r\n                onComplete.params[1] = this.targets;\r\n\r\n                onComplete.func.apply(onComplete.scope, onComplete.params);\r\n            }\r\n\r\n            this.state = TWEEN_CONST.PENDING_REMOVE;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Immediately removes this Tween from the TweenManager and all of its internal arrays,\r\n     * no matter what stage it as it. Then sets the tween state to `REMOVED`.\r\n     * \r\n     * You should dispose of your reference to this tween after calling this method, to\r\n     * free it from memory.\r\n     *\r\n     * @method Phaser.Tweens.Tween#remove\r\n     * @since 3.17.0\r\n     *\r\n     * @return {this} This Tween instance.\r\n     */\r\n    remove: function ()\r\n    {\r\n        this.parent.remove(this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stops the Tween immediately, whatever stage of progress it is at and flags it for removal by the TweenManager.\r\n     *\r\n     * @method Phaser.Tweens.Tween#stop\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [resetTo] - If you want to seek the tween, provide a value between 0 and 1.\r\n     *\r\n     * @return {this} This Tween instance.\r\n     */\r\n    stop: function (resetTo)\r\n    {\r\n        if (this.state === TWEEN_CONST.ACTIVE)\r\n        {\r\n            if (resetTo !== undefined)\r\n            {\r\n                this.seek(resetTo);\r\n            }\r\n        }\r\n\r\n        if (this.state !== TWEEN_CONST.REMOVED)\r\n        {\r\n            if (this.state === TWEEN_CONST.PAUSED || this.state === TWEEN_CONST.PENDING_ADD)\r\n            {\r\n                if (this.parentIsTimeline)\r\n                {\r\n                    this.parent.manager._destroy.push(this);\r\n                    this.parent.manager._toProcess++;\r\n                }\r\n                else\r\n                {\r\n                    this.parent._destroy.push(this);\r\n                    this.parent._toProcess++;\r\n                }\r\n            }\r\n\r\n            this.state = TWEEN_CONST.PENDING_REMOVE;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal method that advances the Tween based on the time values.\r\n     *\r\n     * @method Phaser.Tweens.Tween#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} timestamp - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n     *\r\n     * @return {boolean} Returns `true` if this Tween has finished and should be removed from the Tween Manager, otherwise returns `false`.\r\n     */\r\n    update: function (timestamp, delta)\r\n    {\r\n        if (this.state === TWEEN_CONST.PAUSED)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        if (this.useFrames)\r\n        {\r\n            delta = 1 * this.parent.timeScale;\r\n        }\r\n\r\n        delta *= this.timeScale;\r\n\r\n        this.elapsed += delta;\r\n        this.progress = Math.min(this.elapsed / this.duration, 1);\r\n\r\n        this.totalElapsed += delta;\r\n        this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1);\r\n\r\n        switch (this.state)\r\n        {\r\n            case TWEEN_CONST.ACTIVE:\r\n\r\n                var stillRunning = false;\r\n\r\n                for (var i = 0; i < this.totalData; i++)\r\n                {\r\n                    if (this.updateTweenData(this, this.data[i], delta))\r\n                    {\r\n                        stillRunning = true;\r\n                    }\r\n                }\r\n\r\n                //  Anything still running? If not, we're done\r\n                if (!stillRunning)\r\n                {\r\n                    this.nextState();\r\n                }\r\n\r\n                break;\r\n\r\n            case TWEEN_CONST.LOOP_DELAY:\r\n\r\n                this.countdown -= delta;\r\n\r\n                if (this.countdown <= 0)\r\n                {\r\n                    this.state = TWEEN_CONST.ACTIVE;\r\n                }\r\n\r\n                break;\r\n\r\n            case TWEEN_CONST.OFFSET_DELAY:\r\n\r\n                this.countdown -= delta;\r\n\r\n                if (this.countdown <= 0)\r\n                {\r\n                    var onStart = this.callbacks.onStart;\r\n\r\n                    if (onStart)\r\n                    {\r\n                        onStart.params[1] = this.targets;\r\n\r\n                        onStart.func.apply(onStart.scope, onStart.params);\r\n                    }\r\n\r\n                    this.state = TWEEN_CONST.ACTIVE;\r\n                }\r\n\r\n                break;\r\n\r\n            case TWEEN_CONST.COMPLETE_DELAY:\r\n\r\n                this.countdown -= delta;\r\n\r\n                if (this.countdown <= 0)\r\n                {\r\n                    var onComplete = this.callbacks.onComplete;\r\n\r\n                    if (onComplete)\r\n                    {\r\n                        onComplete.func.apply(onComplete.scope, onComplete.params);\r\n                    }\r\n\r\n                    this.state = TWEEN_CONST.PENDING_REMOVE;\r\n                }\r\n\r\n                break;\r\n        }\r\n\r\n        return (this.state === TWEEN_CONST.PENDING_REMOVE);\r\n    },\r\n\r\n    /**\r\n     * Internal method used as part of the playback process that sets a tween to play in reverse.\r\n     *\r\n     * @method Phaser.Tweens.Tween#setStateFromEnd\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tweens.Tween} tween - The Tween to update.\r\n     * @param {Phaser.Types.Tweens.TweenDataConfig} tweenData - The TweenData property to update.\r\n     * @param {number} diff - Any extra time that needs to be accounted for in the elapsed and progress values.\r\n     *\r\n     * @return {integer} The state of this Tween.\r\n     */\r\n    setStateFromEnd: function (tween, tweenData, diff)\r\n    {\r\n        if (tweenData.yoyo)\r\n        {\r\n            //  We've hit the end of a Playing Forward TweenData and we have a yoyo\r\n\r\n            //  Account for any extra time we got from the previous frame\r\n            tweenData.elapsed = diff;\r\n            tweenData.progress = diff / tweenData.duration;\r\n\r\n            if (tweenData.flipX)\r\n            {\r\n                tweenData.target.toggleFlipX();\r\n            }\r\n\r\n            //  Problem: The flip and callback and so on gets called for every TweenData that triggers it at the same time.\r\n            //  If you're tweening several properties it can fire for all of them, at once.\r\n\r\n            if (tweenData.flipY)\r\n            {\r\n                tweenData.target.toggleFlipY();\r\n            }\r\n\r\n            var onYoyo = tween.callbacks.onYoyo;\r\n\r\n            if (onYoyo)\r\n            {\r\n                //  Element 1 is reserved for the target of the yoyo (and needs setting here)\r\n                onYoyo.params[1] = tweenData.target;\r\n\r\n                onYoyo.func.apply(onYoyo.scope, onYoyo.params);\r\n            }\r\n\r\n            tweenData.start = tweenData.getStartValue(tweenData.target, tweenData.key, tweenData.start);\r\n\r\n            return TWEEN_CONST.PLAYING_BACKWARD;\r\n        }\r\n        else if (tweenData.repeatCounter > 0)\r\n        {\r\n            //  We've hit the end of a Playing Forward TweenData and we have a Repeat.\r\n            //  So we're going to go right back to the start to repeat it again.\r\n\r\n            tweenData.repeatCounter--;\r\n\r\n            //  Account for any extra time we got from the previous frame\r\n            tweenData.elapsed = diff;\r\n            tweenData.progress = diff / tweenData.duration;\r\n\r\n            if (tweenData.flipX)\r\n            {\r\n                tweenData.target.toggleFlipX();\r\n            }\r\n\r\n            if (tweenData.flipY)\r\n            {\r\n                tweenData.target.toggleFlipY();\r\n            }\r\n\r\n            var onRepeat = tween.callbacks.onRepeat;\r\n\r\n            if (onRepeat)\r\n            {\r\n                //  Element 1 is reserved for the target of the repeat (and needs setting here)\r\n                onRepeat.params[1] = tweenData.target;\r\n\r\n                onRepeat.func.apply(onRepeat.scope, onRepeat.params);\r\n            }\r\n\r\n            tweenData.start = tweenData.getStartValue(tweenData.target, tweenData.key, tweenData.start);\r\n\r\n            tweenData.end = tweenData.getEndValue(tweenData.target, tweenData.key, tweenData.start);\r\n\r\n            //  Delay?\r\n            if (tweenData.repeatDelay > 0)\r\n            {\r\n                tweenData.elapsed = tweenData.repeatDelay - diff;\r\n\r\n                tweenData.current = tweenData.start;\r\n\r\n                tweenData.target[tweenData.key] = tweenData.current;\r\n\r\n                return TWEEN_CONST.REPEAT_DELAY;\r\n            }\r\n            else\r\n            {\r\n                return TWEEN_CONST.PLAYING_FORWARD;\r\n            }\r\n        }\r\n\r\n        return TWEEN_CONST.COMPLETE;\r\n    },\r\n\r\n    /**\r\n     * Internal method used as part of the playback process that sets a tween to play from the start.\r\n     *\r\n     * @method Phaser.Tweens.Tween#setStateFromStart\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tweens.Tween} tween - The Tween to update.\r\n     * @param {Phaser.Types.Tweens.TweenDataConfig} tweenData - The TweenData property to update.\r\n     * @param {number} diff - Any extra time that needs to be accounted for in the elapsed and progress values.\r\n     *\r\n     * @return {integer} The state of this Tween.\r\n     */\r\n    setStateFromStart: function (tween, tweenData, diff)\r\n    {\r\n        if (tweenData.repeatCounter > 0)\r\n        {\r\n            tweenData.repeatCounter--;\r\n\r\n            //  Account for any extra time we got from the previous frame\r\n            tweenData.elapsed = diff;\r\n            tweenData.progress = diff / tweenData.duration;\r\n\r\n            if (tweenData.flipX)\r\n            {\r\n                tweenData.target.toggleFlipX();\r\n            }\r\n\r\n            if (tweenData.flipY)\r\n            {\r\n                tweenData.target.toggleFlipY();\r\n            }\r\n\r\n            var onRepeat = tween.callbacks.onRepeat;\r\n\r\n            if (onRepeat)\r\n            {\r\n                //  Element 1 is reserved for the target of the repeat (and needs setting here)\r\n                onRepeat.params[1] = tweenData.target;\r\n\r\n                onRepeat.func.apply(onRepeat.scope, onRepeat.params);\r\n            }\r\n\r\n            tweenData.end = tweenData.getEndValue(tweenData.target, tweenData.key, tweenData.start);\r\n\r\n            //  Delay?\r\n            if (tweenData.repeatDelay > 0)\r\n            {\r\n                tweenData.elapsed = tweenData.repeatDelay - diff;\r\n\r\n                tweenData.current = tweenData.start;\r\n\r\n                tweenData.target[tweenData.key] = tweenData.current;\r\n\r\n                return TWEEN_CONST.REPEAT_DELAY;\r\n            }\r\n            else\r\n            {\r\n                return TWEEN_CONST.PLAYING_FORWARD;\r\n            }\r\n        }\r\n\r\n        return TWEEN_CONST.COMPLETE;\r\n    },\r\n\r\n    /**\r\n     * Internal method that advances the TweenData based on the time value given.\r\n     *\r\n     * @method Phaser.Tweens.Tween#updateTweenData\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tweens.Tween} tween - The Tween to update.\r\n     * @param {Phaser.Types.Tweens.TweenDataConfig} tweenData - The TweenData property to update.\r\n     * @param {number} delta - Either a value in ms, or 1 if Tween.useFrames is true\r\n     *\r\n     * @return {boolean} [description]\r\n     */\r\n    updateTweenData: function (tween, tweenData, delta)\r\n    {\r\n        switch (tweenData.state)\r\n        {\r\n            case TWEEN_CONST.PLAYING_FORWARD:\r\n            case TWEEN_CONST.PLAYING_BACKWARD:\r\n\r\n                if (!tweenData.target)\r\n                {\r\n                    tweenData.state = TWEEN_CONST.COMPLETE;\r\n                    break;\r\n                }\r\n\r\n                var elapsed = tweenData.elapsed;\r\n                var duration = tweenData.duration;\r\n                var diff = 0;\r\n\r\n                elapsed += delta;\r\n\r\n                if (elapsed > duration)\r\n                {\r\n                    diff = elapsed - duration;\r\n                    elapsed = duration;\r\n                }\r\n\r\n                var forward = (tweenData.state === TWEEN_CONST.PLAYING_FORWARD);\r\n                var progress = elapsed / duration;\r\n\r\n                var v;\r\n\r\n                if (forward)\r\n                {\r\n                    v = tweenData.ease(progress);\r\n                }\r\n                else\r\n                {\r\n                    v = tweenData.ease(1 - progress);\r\n                }\r\n\r\n                tweenData.current = tweenData.start + ((tweenData.end - tweenData.start) * v);\r\n\r\n                tweenData.target[tweenData.key] = tweenData.current;\r\n\r\n                tweenData.elapsed = elapsed;\r\n                tweenData.progress = progress;\r\n\r\n                var onUpdate = tween.callbacks.onUpdate;\r\n\r\n                if (onUpdate)\r\n                {\r\n                    onUpdate.params[1] = tweenData.target;\r\n\r\n                    onUpdate.func.apply(onUpdate.scope, onUpdate.params);\r\n                }\r\n\r\n                if (progress === 1)\r\n                {\r\n                    if (forward)\r\n                    {\r\n                        if (tweenData.hold > 0)\r\n                        {\r\n                            tweenData.elapsed = tweenData.hold - diff;\r\n\r\n                            tweenData.state = TWEEN_CONST.HOLD_DELAY;\r\n                        }\r\n                        else\r\n                        {\r\n                            tweenData.state = this.setStateFromEnd(tween, tweenData, diff);\r\n                        }\r\n                    }\r\n                    else\r\n                    {\r\n                        tweenData.state = this.setStateFromStart(tween, tweenData, diff);\r\n                    }\r\n                }\r\n\r\n                break;\r\n\r\n            case TWEEN_CONST.DELAY:\r\n\r\n                tweenData.elapsed -= delta;\r\n\r\n                if (tweenData.elapsed <= 0)\r\n                {\r\n                    tweenData.elapsed = Math.abs(tweenData.elapsed);\r\n\r\n                    tweenData.state = TWEEN_CONST.PENDING_RENDER;\r\n                }\r\n\r\n                break;\r\n\r\n            case TWEEN_CONST.REPEAT_DELAY:\r\n\r\n                tweenData.elapsed -= delta;\r\n\r\n                if (tweenData.elapsed <= 0)\r\n                {\r\n                    tweenData.elapsed = Math.abs(tweenData.elapsed);\r\n\r\n                    tweenData.state = TWEEN_CONST.PLAYING_FORWARD;\r\n                }\r\n\r\n                break;\r\n\r\n            case TWEEN_CONST.HOLD_DELAY:\r\n\r\n                tweenData.elapsed -= delta;\r\n\r\n                if (tweenData.elapsed <= 0)\r\n                {\r\n                    tweenData.state = this.setStateFromEnd(tween, tweenData, Math.abs(tweenData.elapsed));\r\n                }\r\n\r\n                break;\r\n\r\n            case TWEEN_CONST.PENDING_RENDER:\r\n\r\n                if (tweenData.target)\r\n                {\r\n                    tweenData.start = tweenData.getStartValue(tweenData.target, tweenData.key, tweenData.target[tweenData.key]);\r\n\r\n                    tweenData.end = tweenData.getEndValue(tweenData.target, tweenData.key, tweenData.start);\r\n\r\n                    tweenData.current = tweenData.start;\r\n\r\n                    tweenData.target[tweenData.key] = tweenData.start;\r\n\r\n                    tweenData.state = TWEEN_CONST.PLAYING_FORWARD;\r\n                }\r\n                else\r\n                {\r\n                    tweenData.state = TWEEN_CONST.COMPLETE;\r\n                }\r\n\r\n                break;\r\n        }\r\n\r\n        //  Return TRUE if this TweenData still playing, otherwise return FALSE\r\n        return (tweenData.state !== TWEEN_CONST.COMPLETE);\r\n    }\r\n\r\n});\r\n\r\nTween.TYPES = [\r\n    'onComplete',\r\n    'onLoop',\r\n    'onRepeat',\r\n    'onStart',\r\n    'onUpdate',\r\n    'onYoyo'\r\n];\r\n\r\n/**\r\n * Creates a new Tween object.\r\n *\r\n * Note: This method will only be available Tweens have been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectFactory#tween\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - The Tween configuration.\r\n *\r\n * @return {Phaser.Tweens.Tween} The Tween that was created.\r\n */\r\nGameObjectFactory.register('tween', function (config)\r\n{\r\n    return this.scene.sys.tweens.add(config);\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectFactory context.\r\n//\r\n//  There are several properties available to use:\r\n//\r\n//  this.scene - a reference to the Scene that owns the GameObjectFactory\r\n//  this.displayList - a reference to the Display List the Scene owns\r\n//  this.updateList - a reference to the Update List the Scene owns\r\n\r\n/**\r\n * Creates a new Tween object and returns it.\r\n *\r\n * Note: This method will only be available if Tweens have been built into Phaser.\r\n *\r\n * @method Phaser.GameObjects.GameObjectCreator#tween\r\n * @since 3.0.0\r\n *\r\n * @param {object} config - The Tween configuration.\r\n *\r\n * @return {Phaser.Tweens.Tween} The Tween that was created.\r\n */\r\nGameObjectCreator.register('tween', function (config)\r\n{\r\n    return this.scene.sys.tweens.create(config);\r\n});\r\n\r\n//  When registering a factory function 'this' refers to the GameObjectCreator context.\r\n\r\nmodule.exports = Tween;\r\n"},"sourceMaps":null,"error":null,"hash":"3800106d2804ee1be21065883bd6f237","cacheData":{"env":{}}}