{"id":"../../node_modules/phaser/src/gameobjects/bitmaptext/GetBitmapTextSize.js","dependencies":[{"name":"C:\\Users\\דור\\Desktop\\pmm\\package.json","includedInParent":true,"mtime":1560952935180},{"name":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\package.json","includedInParent":true,"mtime":1561396619369}],"generated":{"js":"var global = arguments[3];\n/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\n/**\r\n * Calculate the position, width and height of a BitmapText Game Object.\r\n *\r\n * Returns a BitmapTextSize object that contains global and local variants of the Game Objects x and y coordinates and\r\n * its width and height.\r\n *\r\n * The global position and size take into account the Game Object's position and scale.\r\n *\r\n * The local position and size just takes into account the font data.\r\n *\r\n * @function GetBitmapTextSize\r\n * @since 3.0.0\r\n * @private\r\n *\r\n * @param {(Phaser.GameObjects.DynamicBitmapText|Phaser.GameObjects.BitmapText)} src - The BitmapText to calculate the position, width and height of.\r\n * @param {boolean} [round] - Whether to round the results to the nearest integer.\r\n * @param {object} [out] - Optional object to store the results in, to save constant object creation.\r\n *\r\n * @return {Phaser.Types.GameObjects.BitmapText.BitmapTextSize} The calculated position, width and height of the BitmapText.\r\n */\r\nvar GetBitmapTextSize = function (src, round, out)\r\n{\r\n    if (out === undefined)\r\n    {\r\n        out = {\r\n            local: {\r\n                x: 0,\r\n                y: 0,\r\n                width: 0,\r\n                height: 0\r\n            },\r\n            global: {\r\n                x: 0,\r\n                y: 0,\r\n                width: 0,\r\n                height: 0\r\n            },\r\n            lines: {\r\n                shortest: 0,\r\n                longest: 0,\r\n                lengths: null\r\n            }\r\n        };\r\n    }\r\n\r\n    var text = src.text;\r\n    var textLength = text.length;\r\n\r\n    var bx = Number.MAX_VALUE;\r\n    var by = Number.MAX_VALUE;\r\n    var bw = 0;\r\n    var bh = 0;\r\n\r\n    var chars = src.fontData.chars;\r\n    var lineHeight = src.fontData.lineHeight;\r\n    var letterSpacing = src.letterSpacing;\r\n\r\n    var xAdvance = 0;\r\n    var yAdvance = 0;\r\n\r\n    var charCode = 0;\r\n\r\n    var glyph = null;\r\n\r\n    var x = 0;\r\n    var y = 0;\r\n\r\n    var scale = (src.fontSize / src.fontData.size);\r\n    var sx = scale * src.scaleX;\r\n    var sy = scale * src.scaleY;\r\n\r\n    var lastGlyph = null;\r\n    var lastCharCode = 0;\r\n    var lineWidths = [];\r\n    var shortestLine = Number.MAX_VALUE;\r\n    var longestLine = 0;\r\n    var currentLine = 0;\r\n    var currentLineWidth = 0;\r\n\r\n    for (var i = 0; i < textLength; i++)\r\n    {\r\n        charCode = text.charCodeAt(i);\r\n\r\n        if (charCode === 10)\r\n        {\r\n            xAdvance = 0;\r\n            yAdvance += lineHeight;\r\n            lastGlyph = null;\r\n\r\n            lineWidths[currentLine] = currentLineWidth;\r\n\r\n            if (currentLineWidth > longestLine)\r\n            {\r\n                longestLine = currentLineWidth;\r\n            }\r\n\r\n            if (currentLineWidth < shortestLine)\r\n            {\r\n                shortestLine = currentLineWidth;\r\n            }\r\n\r\n            currentLine++;\r\n            currentLineWidth = 0;\r\n            continue;\r\n        }\r\n\r\n        glyph = chars[charCode];\r\n\r\n        if (!glyph)\r\n        {\r\n            continue;\r\n        }\r\n\r\n        x = xAdvance;\r\n        y = yAdvance;\r\n\r\n        if (lastGlyph !== null)\r\n        {\r\n            var kerningOffset = glyph.kerning[lastCharCode];\r\n            x += (kerningOffset !== undefined) ? kerningOffset : 0;\r\n        }\r\n\r\n        if (bx > x)\r\n        {\r\n            bx = x;\r\n        }\r\n\r\n        if (by > y)\r\n        {\r\n            by = y;\r\n        }\r\n\r\n        var gw = x + glyph.xAdvance;\r\n        var gh = y + lineHeight;\r\n\r\n        if (bw < gw)\r\n        {\r\n            bw = gw;\r\n        }\r\n\r\n        if (bh < gh)\r\n        {\r\n            bh = gh;\r\n        }\r\n\r\n        xAdvance += glyph.xAdvance + letterSpacing;\r\n        lastGlyph = glyph;\r\n        lastCharCode = charCode;\r\n        currentLineWidth = gw * scale;\r\n    }\r\n\r\n    lineWidths[currentLine] = currentLineWidth;\r\n\r\n    if (currentLineWidth > longestLine)\r\n    {\r\n        longestLine = currentLineWidth;\r\n    }\r\n\r\n    if (currentLineWidth < shortestLine)\r\n    {\r\n        shortestLine = currentLineWidth;\r\n    }\r\n\r\n    var local = out.local;\r\n    var global = out.global;\r\n    var lines = out.lines;\r\n\r\n    local.x = bx * scale;\r\n    local.y = by * scale;\r\n    local.width = bw * scale;\r\n    local.height = bh * scale;\r\n\r\n    global.x = (src.x - src.displayOriginX) + (bx * sx);\r\n    global.y = (src.y - src.displayOriginY) + (by * sy);\r\n    global.width = bw * sx;\r\n    global.height = bh * sy;\r\n\r\n    lines.shortest = shortestLine;\r\n    lines.longest = longestLine;\r\n    lines.lengths = lineWidths;\r\n\r\n    if (round)\r\n    {\r\n        local.x = Math.round(local.x);\r\n        local.y = Math.round(local.y);\r\n        local.width = Math.round(local.width);\r\n        local.height = Math.round(local.height);\r\n\r\n        global.x = Math.round(global.x);\r\n        global.y = Math.round(global.y);\r\n        global.width = Math.round(global.width);\r\n        global.height = Math.round(global.height);\r\n\r\n        lines.shortest = Math.round(shortestLine);\r\n        lines.longest = Math.round(longestLine);\r\n    }\r\n\r\n    return out;\r\n};\r\n\r\nmodule.exports = GetBitmapTextSize;\r\n"},"sourceMaps":null,"error":null,"hash":"e588b939819a428258e8c74993fd7007","cacheData":{"env":{}}}