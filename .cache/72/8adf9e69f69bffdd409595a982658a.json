{"id":"../../node_modules/phaser/src/physics/impact/CollisionMap.js","dependencies":[{"name":"C:\\Users\\דור\\Desktop\\pmm\\package.json","includedInParent":true,"mtime":1560952935180},{"name":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\package.json","includedInParent":true,"mtime":1561396619369},{"name":"../../utils/Class","loc":{"line":7,"column":20},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\impact\\CollisionMap.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\Class.js"},{"name":"./DefaultDefs","loc":{"line":8,"column":26},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\impact\\CollisionMap.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\impact\\DefaultDefs.js"}],"generated":{"js":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../../utils/Class');\r\nvar DefaultDefs = require('./DefaultDefs');\r\n\r\n/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class CollisionMap\r\n * @memberof Phaser.Physics.Impact\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {integer} [tilesize=32] - [description]\r\n * @param {array} [data] - [description]\r\n */\r\nvar CollisionMap = new Class({\r\n\r\n    initialize:\r\n\r\n    function CollisionMap (tilesize, data)\r\n    {\r\n        if (tilesize === undefined) { tilesize = 32; }\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.CollisionMap#tilesize\r\n         * @type {integer}\r\n         * @default 32\r\n         * @since 3.0.0\r\n         */\r\n        this.tilesize = tilesize;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.CollisionMap#data\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.data = (Array.isArray(data)) ? data : [];\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.CollisionMap#width\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = (Array.isArray(data)) ? data[0].length : 0;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.CollisionMap#height\r\n         * @type {number}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = (Array.isArray(data)) ? data.length : 0;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.CollisionMap#lastSlope\r\n         * @type {integer}\r\n         * @default 55\r\n         * @since 3.0.0\r\n         */\r\n        this.lastSlope = 55;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.CollisionMap#tiledef\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.tiledef = DefaultDefs;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.CollisionMap#trace\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} vx - [description]\r\n     * @param {number} vy - [description]\r\n     * @param {number} objectWidth - [description]\r\n     * @param {number} objectHeight - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */\r\n    trace: function (x, y, vx, vy, objectWidth, objectHeight)\r\n    {\r\n        // Set up the trace-result\r\n        var res = {\r\n            collision: { x: false, y: false, slope: false },\r\n            pos: { x: x + vx, y: y + vy },\r\n            tile: { x: 0, y: 0 }\r\n        };\r\n\r\n        if (!this.data)\r\n        {\r\n            return res;\r\n        }\r\n        \r\n        var steps = Math.ceil(Math.max(Math.abs(vx), Math.abs(vy)) / this.tilesize);\r\n\r\n        if (steps > 1)\r\n        {\r\n            var sx = vx / steps;\r\n            var sy = vy / steps;\r\n            \r\n            for (var i = 0; i < steps && (sx || sy); i++)\r\n            {\r\n                this.step(res, x, y, sx, sy, objectWidth, objectHeight, vx, vy, i);\r\n                \r\n                x = res.pos.x;\r\n                y = res.pos.y;\r\n\r\n                if (res.collision.x)\r\n                {\r\n                    sx = 0;\r\n                    vx = 0;\r\n                }\r\n\r\n                if (res.collision.y)\r\n                {\r\n                    sy = 0;\r\n                    vy = 0;\r\n                }\r\n\r\n                if (res.collision.slope)\r\n                {\r\n                    break;\r\n                }\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.step(res, x, y, vx, vy, objectWidth, objectHeight, vx, vy, 0);\r\n        }\r\n        \r\n        return res;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.CollisionMap#step\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} res - [description]\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} vx - [description]\r\n     * @param {number} vy - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {number} rvx - [description]\r\n     * @param {number} rvy - [description]\r\n     * @param {number} step - [description]\r\n     */\r\n    step: function (res, x, y, vx, vy, width, height, rvx, rvy, step)\r\n    {\r\n        var t = 0;\r\n        var tileX;\r\n        var tileY;\r\n        var tilesize = this.tilesize;\r\n        var mapWidth = this.width;\r\n        var mapHeight = this.height;\r\n        \r\n        //  Horizontal\r\n        if (vx)\r\n        {\r\n            var pxOffsetX = (vx > 0 ? width : 0);\r\n            var tileOffsetX = (vx < 0 ? tilesize : 0);\r\n            \r\n            var firstTileY = Math.max(Math.floor(y / tilesize), 0);\r\n            var lastTileY = Math.min(Math.ceil((y + height) / tilesize), mapHeight);\r\n            \r\n            tileX = Math.floor((res.pos.x + pxOffsetX) / tilesize);\r\n\r\n            var prevTileX = Math.floor((x + pxOffsetX) / tilesize);\r\n\r\n            if (step > 0 || tileX === prevTileX || prevTileX < 0 || prevTileX >= mapWidth)\r\n            {\r\n                prevTileX = -1;\r\n            }\r\n           \r\n            if (tileX >= 0 && tileX < mapWidth)\r\n            {\r\n                for (tileY = firstTileY; tileY < lastTileY; tileY++)\r\n                {\r\n                    if (prevTileX !== -1)\r\n                    {\r\n                        t = this.data[tileY][prevTileX];\r\n\r\n                        if (t > 1 && t <= this.lastSlope && this.checkDef(res, t, x, y, rvx, rvy, width, height, prevTileX, tileY))\r\n                        {\r\n                            break;\r\n                        }\r\n                    }\r\n                    \r\n                    t = this.data[tileY][tileX];\r\n\r\n                    if (t === 1 || t > this.lastSlope || (t > 1 && this.checkDef(res, t, x, y, rvx, rvy, width, height, tileX, tileY)))\r\n                    {\r\n                        if (t > 1 && t <= this.lastSlope && res.collision.slope)\r\n                        {\r\n                            break;\r\n                        }\r\n                        \r\n                        res.collision.x = true;\r\n                        res.tile.x = t;\r\n                        res.pos.x = (tileX * tilesize) - pxOffsetX + tileOffsetX;\r\n                        x = res.pos.x;\r\n                        rvx = 0;\r\n\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n        \r\n        //  Vertical\r\n        if (vy)\r\n        {\r\n            var pxOffsetY = (vy > 0 ? height : 0);\r\n            var tileOffsetY = (vy < 0 ? tilesize : 0);\r\n            \r\n            var firstTileX = Math.max(Math.floor(res.pos.x / tilesize), 0);\r\n            var lastTileX = Math.min(Math.ceil((res.pos.x + width) / tilesize), mapWidth);\r\n            \r\n            tileY = Math.floor((res.pos.y + pxOffsetY) / tilesize);\r\n            \r\n            var prevTileY = Math.floor((y + pxOffsetY) / tilesize);\r\n\r\n            if (step > 0 || tileY === prevTileY || prevTileY < 0 || prevTileY >= mapHeight)\r\n            {\r\n                prevTileY = -1;\r\n            }\r\n            \r\n            if (tileY >= 0 && tileY < mapHeight)\r\n            {\r\n                for (tileX = firstTileX; tileX < lastTileX; tileX++)\r\n                {\r\n                    if (prevTileY !== -1)\r\n                    {\r\n                        t = this.data[prevTileY][tileX];\r\n\r\n                        if (t > 1 && t <= this.lastSlope && this.checkDef(res, t, x, y, rvx, rvy, width, height, tileX, prevTileY))\r\n                        {\r\n                            break;\r\n                        }\r\n                    }\r\n                    \r\n                    t = this.data[tileY][tileX];\r\n\r\n                    if (t === 1 || t > this.lastSlope || (t > 1 && this.checkDef(res, t, x, y, rvx, rvy, width, height, tileX, tileY)))\r\n                    {\r\n                        if (t > 1 && t <= this.lastSlope && res.collision.slope)\r\n                        {\r\n                            break;\r\n                        }\r\n                        \r\n                        res.collision.y = true;\r\n                        res.tile.y = t;\r\n                        res.pos.y = tileY * tilesize - pxOffsetY + tileOffsetY;\r\n\r\n                        break;\r\n                    }\r\n                }\r\n            }\r\n        }\r\n    },\r\n    \r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.CollisionMap#checkDef\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} res - [description]\r\n     * @param {number} t - [description]\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} vx - [description]\r\n     * @param {number} vy - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     * @param {number} tileX - [description]\r\n     * @param {number} tileY - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */\r\n    checkDef: function (res, t, x, y, vx, vy, width, height, tileX, tileY)\r\n    {\r\n        var def = this.tiledef[t];\r\n\r\n        if (!def)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var tilesize = this.tilesize;\r\n        \r\n        var lx = (tileX + def[0]) * tilesize;\r\n        var ly = (tileY + def[1]) * tilesize;\r\n        var lvx = (def[2] - def[0]) * tilesize;\r\n        var lvy = (def[3] - def[1]) * tilesize;\r\n        var solid = def[4];\r\n        \r\n        var tx = x + vx + (lvy < 0 ? width : 0) - lx;\r\n        var ty = y + vy + (lvx > 0 ? height : 0) - ly;\r\n        \r\n        if (lvx * ty - lvy * tx > 0)\r\n        {\r\n            if (vx * -lvy + vy * lvx < 0)\r\n            {\r\n                return solid;\r\n            }\r\n            \r\n            var length = Math.sqrt(lvx * lvx + lvy * lvy);\r\n            var nx = lvy / length;\r\n            var ny = -lvx / length;\r\n            \r\n            var proj = tx * nx + ty * ny;\r\n            var px = nx * proj;\r\n            var py = ny * proj;\r\n            \r\n            if (px * px + py * py >= vx * vx + vy * vy)\r\n            {\r\n                return solid || (lvx * (ty - vy) - lvy * (tx - vx) < 0.5);\r\n            }\r\n            \r\n            res.pos.x = x + vx - px;\r\n            res.pos.y = y + vy - py;\r\n            res.collision.slope = { x: lvx, y: lvy, nx: nx, ny: ny };\r\n\r\n            return true;\r\n        }\r\n        \r\n        return false;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = CollisionMap;\r\n"},"sourceMaps":null,"error":null,"hash":"5a838b664f19f7ac0b8ba943dec51b8d","cacheData":{"env":{}}}