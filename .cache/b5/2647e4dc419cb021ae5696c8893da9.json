{"id":"../../node_modules/phaser/src/physics/matter-js/MatterTileBody.js","dependencies":[{"name":"C:\\Users\\Admin\\Desktop\\pmm\\package.json","includedInParent":true,"mtime":1560952935180},{"name":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\package.json","includedInParent":true,"mtime":1561134727120},{"name":"./lib/factory/Bodies","loc":{"line":7,"column":21},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\MatterTileBody.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\lib\\factory\\Bodies.js"},{"name":"./lib/body/Body","loc":{"line":8,"column":19},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\MatterTileBody.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\lib\\body\\Body.js"},{"name":"../../utils/Class","loc":{"line":9,"column":20},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\MatterTileBody.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\Class.js"},{"name":"./components","loc":{"line":10,"column":25},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\MatterTileBody.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\components\\index.js"},{"name":"../../utils/object/GetFastValue","loc":{"line":11,"column":27},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\MatterTileBody.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\object\\GetFastValue.js"},{"name":"../../utils/object/HasValue","loc":{"line":12,"column":23},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\MatterTileBody.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\object\\HasValue.js"},{"name":"./lib/geometry/Vertices","loc":{"line":13,"column":23},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\MatterTileBody.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\lib\\geometry\\Vertices.js"}],"generated":{"js":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Bodies = require('./lib/factory/Bodies');\r\nvar Body = require('./lib/body/Body');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('./components');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar HasValue = require('../../utils/object/HasValue');\r\nvar Vertices = require('./lib/geometry/Vertices');\r\n\r\n/**\r\n * @classdesc\r\n * A wrapper around a Tile that provides access to a corresponding Matter body. A tile can only\r\n * have one Matter body associated with it. You can either pass in an existing Matter body for\r\n * the tile or allow the constructor to create the corresponding body for you. If the Tile has a\r\n * collision group (defined in Tiled), those shapes will be used to create the body. If not, the\r\n * tile's rectangle bounding box will be used.\r\n *\r\n * The corresponding body will be accessible on the Tile itself via Tile.physics.matterBody.\r\n *\r\n * Note: not all Tiled collision shapes are supported. See\r\n * Phaser.Physics.Matter.TileBody#setFromTileCollision for more information.\r\n *\r\n * @class TileBody\r\n * @memberof Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @extends Phaser.Physics.Matter.Components.Bounce\r\n * @extends Phaser.Physics.Matter.Components.Collision\r\n * @extends Phaser.Physics.Matter.Components.Friction\r\n * @extends Phaser.Physics.Matter.Components.Gravity\r\n * @extends Phaser.Physics.Matter.Components.Mass\r\n * @extends Phaser.Physics.Matter.Components.Sensor\r\n * @extends Phaser.Physics.Matter.Components.Sleep\r\n * @extends Phaser.Physics.Matter.Components.Static\r\n *\r\n * @param {Phaser.Physics.Matter.World} world - [description]\r\n * @param {Phaser.Tilemaps.Tile} tile - The target tile that should have a Matter body.\r\n * @param {Phaser.Types.Physics.Matter.MatterTileOptions} [options] - Options to be used when creating the Matter body.\r\n */\r\nvar MatterTileBody = new Class({\r\n\r\n    Mixins: [\r\n        Components.Bounce,\r\n        Components.Collision,\r\n        Components.Friction,\r\n        Components.Gravity,\r\n        Components.Mass,\r\n        Components.Sensor,\r\n        Components.Sleep,\r\n        Components.Static\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function MatterTileBody (world, tile, options)\r\n    {\r\n        /**\r\n         * The tile object the body is associated with.\r\n         *\r\n         * @name Phaser.Physics.Matter.TileBody#tile\r\n         * @type {Phaser.Tilemaps.Tile}\r\n         * @since 3.0.0\r\n         */\r\n        this.tile = tile;\r\n\r\n        /**\r\n         * The Matter world the body exists within.\r\n         *\r\n         * @name Phaser.Physics.Matter.TileBody#world\r\n         * @type {Phaser.Physics.Matter.World}\r\n         * @since 3.0.0\r\n         */\r\n        this.world = world;\r\n\r\n        // Install a reference to 'this' on the tile and ensure there can only be one matter body\r\n        // associated with the tile\r\n        if (tile.physics.matterBody)\r\n        {\r\n            tile.physics.matterBody.destroy();\r\n        }\r\n\r\n        tile.physics.matterBody = this;\r\n\r\n        // Set the body either from an existing body (if provided), the shapes in the tileset\r\n        // collision layer (if it exists) or a rectangle matching the tile.\r\n        var body = GetFastValue(options, 'body', null);\r\n\r\n        var addToWorld = GetFastValue(options, 'addToWorld', true);\r\n\r\n        if (!body)\r\n        {\r\n            var collisionGroup = tile.getCollisionGroup();\r\n            var collisionObjects = GetFastValue(collisionGroup, 'objects', []);\r\n\r\n            if (collisionObjects.length > 0)\r\n            {\r\n                this.setFromTileCollision(options);\r\n            }\r\n            else\r\n            {\r\n                this.setFromTileRectangle(options);\r\n            }\r\n        }\r\n        else\r\n        {\r\n            this.setBody(body, addToWorld);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the current body to a rectangle that matches the bounds of the tile.\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#setFromTileRectangle\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBodyTileOptions} [options] - Options to be used when creating the Matter body. See MatterJS.Body for a list of what Matter accepts.\r\n     * \r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */\r\n    setFromTileRectangle: function (options)\r\n    {\r\n        if (options === undefined) { options = {}; }\r\n        if (!HasValue(options, 'isStatic')) { options.isStatic = true; }\r\n        if (!HasValue(options, 'addToWorld')) { options.addToWorld = true; }\r\n\r\n        var bounds = this.tile.getBounds();\r\n        var cx = bounds.x + (bounds.width / 2);\r\n        var cy = bounds.y + (bounds.height / 2);\r\n        var body = Bodies.rectangle(cx, cy, bounds.width, bounds.height, options);\r\n\r\n        this.setBody(body, options.addToWorld);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the current body from the collision group associated with the Tile. This is typically\r\n     * set up in Tiled's collision editor.\r\n     *\r\n     * Note: Matter doesn't support all shapes from Tiled. Rectangles and polygons are directly\r\n     * supported. Ellipses are converted into circle bodies. Polylines are treated as if they are\r\n     * closed polygons. If a tile has multiple shapes, a multi-part body will be created. Concave\r\n     * shapes are supported if poly-decomp library is included. Decomposition is not guaranteed to\r\n     * work for complex shapes (e.g. holes), so it's often best to manually decompose a concave\r\n     * polygon into multiple convex polygons yourself.\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#setFromTileCollision\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Physics.Matter.MatterBodyTileOptions} [options] - Options to be used when creating the Matter body. See MatterJS.Body for a list of what Matter accepts.\r\n     * \r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */\r\n    setFromTileCollision: function (options)\r\n    {\r\n        if (options === undefined) { options = {}; }\r\n        if (!HasValue(options, 'isStatic')) { options.isStatic = true; }\r\n        if (!HasValue(options, 'addToWorld')) { options.addToWorld = true; }\r\n\r\n        var sx = this.tile.tilemapLayer.scaleX;\r\n        var sy = this.tile.tilemapLayer.scaleY;\r\n        var tileX = this.tile.getLeft();\r\n        var tileY = this.tile.getTop();\r\n        var collisionGroup = this.tile.getCollisionGroup();\r\n        var collisionObjects = GetFastValue(collisionGroup, 'objects', []);\r\n\r\n        var parts = [];\r\n\r\n        for (var i = 0; i < collisionObjects.length; i++)\r\n        {\r\n            var object = collisionObjects[i];\r\n            var ox = tileX + (object.x * sx);\r\n            var oy = tileY + (object.y * sy);\r\n            var ow = object.width * sx;\r\n            var oh = object.height * sy;\r\n            var body = null;\r\n\r\n            if (object.rectangle)\r\n            {\r\n                body = Bodies.rectangle(ox + ow / 2, oy + oh / 2, ow, oh, options);\r\n            }\r\n            else if (object.ellipse)\r\n            {\r\n                body = Bodies.circle(ox + ow / 2, oy + oh / 2, ow / 2, options);\r\n            }\r\n            else if (object.polygon || object.polyline)\r\n            {\r\n                // Polygons and polylines are both treated as closed polygons\r\n                var originalPoints = object.polygon ? object.polygon : object.polyline;\r\n\r\n                var points = originalPoints.map(function (p)\r\n                {\r\n                    return { x: p.x * sx, y: p.y * sy };\r\n                });\r\n\r\n                var vertices = Vertices.create(points);\r\n\r\n                // Points are relative to the object's origin (first point placed in Tiled), but\r\n                // matter expects points to be relative to the center of mass. This only applies to\r\n                // convex shapes. When a concave shape is decomposed, multiple parts are created and\r\n                // the individual parts are positioned relative to (ox, oy).\r\n                //\r\n                //  Update: 8th January 2019 - the latest version of Matter needs the Vertices adjusted,\r\n                //  regardless if convex or concave.\r\n\r\n                var center = Vertices.centre(vertices);\r\n\r\n                ox += center.x;\r\n                oy += center.y;\r\n\r\n                body = Bodies.fromVertices(ox, oy, vertices, options);\r\n            }\r\n\r\n            if (body)\r\n            {\r\n                parts.push(body);\r\n            }\r\n        }\r\n\r\n        if (parts.length === 1)\r\n        {\r\n            this.setBody(parts[0], options.addToWorld);\r\n        }\r\n        else if (parts.length > 1)\r\n        {\r\n            options.parts = parts;\r\n            this.setBody(Body.create(options), options.addToWorld);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the current body to the given body. This will remove the previous body, if one already\r\n     * exists.\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#setBody\r\n     * @since 3.0.0\r\n     *\r\n     * @param {MatterJS.Body} body - The new Matter body to use.\r\n     * @param {boolean} [addToWorld=true] - Whether or not to add the body to the Matter world.\r\n     * \r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */\r\n    setBody: function (body, addToWorld)\r\n    {\r\n        if (addToWorld === undefined) { addToWorld = true; }\r\n\r\n        if (this.body)\r\n        {\r\n            this.removeBody();\r\n        }\r\n\r\n        this.body = body;\r\n        this.body.gameObject = this;\r\n\r\n        if (addToWorld)\r\n        {\r\n            this.world.add(this.body);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the current body from the TileBody and from the Matter world\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#removeBody\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */\r\n    removeBody: function ()\r\n    {\r\n        if (this.body)\r\n        {\r\n            this.world.remove(this.body);\r\n            this.body.gameObject = undefined;\r\n            this.body = undefined;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Removes the current body from the tile and the world.\r\n     *\r\n     * @method Phaser.Physics.Matter.TileBody#destroy\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Matter.TileBody} This TileBody object.\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.removeBody();\r\n        this.tile.physics.matterBody = undefined;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = MatterTileBody;\r\n"},"sourceMaps":null,"error":null,"hash":"99c9df03fa44aaaa6907c061211ca3e6","cacheData":{"env":{}}}