{"id":"../../node_modules/phaser/src/physics/impact/World.js","dependencies":[{"name":"C:\\Users\\דור\\Desktop\\pmm\\package.json","includedInParent":true,"mtime":1560952935180},{"name":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\package.json","includedInParent":true,"mtime":1561396619369},{"name":"./Body","loc":{"line":7,"column":19},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\impact\\World.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\impact\\Body.js"},{"name":"../../utils/Class","loc":{"line":8,"column":20},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\impact\\World.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\Class.js"},{"name":"./COLLIDES","loc":{"line":9,"column":23},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\impact\\World.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\impact\\COLLIDES.js"},{"name":"./CollisionMap","loc":{"line":10,"column":27},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\impact\\World.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\impact\\CollisionMap.js"},{"name":"eventemitter3","loc":{"line":11,"column":27},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\impact\\World.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\eventemitter3\\index.js"},{"name":"./events","loc":{"line":12,"column":21},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\impact\\World.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\impact\\events\\index.js"},{"name":"../../utils/object/GetFastValue","loc":{"line":13,"column":27},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\impact\\World.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\object\\GetFastValue.js"},{"name":"../../utils/object/HasValue","loc":{"line":14,"column":23},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\impact\\World.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\object\\HasValue.js"},{"name":"../../structs/Set","loc":{"line":15,"column":18},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\impact\\World.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\structs\\Set.js"},{"name":"./Solver","loc":{"line":16,"column":21},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\impact\\World.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\impact\\Solver.js"},{"name":"../../tilemaps/Formats","loc":{"line":17,"column":30},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\impact\\World.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\tilemaps\\Formats.js"},{"name":"./TYPE","loc":{"line":18,"column":19},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\impact\\World.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\impact\\TYPE.js"}],"generated":{"js":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Body = require('./Body');\r\nvar Class = require('../../utils/Class');\r\nvar COLLIDES = require('./COLLIDES');\r\nvar CollisionMap = require('./CollisionMap');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar GetFastValue = require('../../utils/object/GetFastValue');\r\nvar HasValue = require('../../utils/object/HasValue');\r\nvar Set = require('../../structs/Set');\r\nvar Solver = require('./Solver');\r\nvar TILEMAP_FORMATS = require('../../tilemaps/Formats');\r\nvar TYPE = require('./TYPE');\r\n\r\n/**\r\n * @classdesc\r\n * [description]\r\n *\r\n * @class World\r\n * @extends Phaser.Events.EventEmitter\r\n * @memberof Phaser.Physics.Impact\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Impact World instance belongs.\r\n * @param {Phaser.Types.Physics.Impact.WorldConfig} config - [description]\r\n */\r\nvar World = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function World (scene, config)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#bodies\r\n         * @type {Phaser.Structs.Set.<Phaser.Physics.Impact.Body>}\r\n         * @since 3.0.0\r\n         */\r\n        this.bodies = new Set();\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#gravity\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.gravity = GetFastValue(config, 'gravity', 0);\r\n\r\n        /**\r\n         * Spatial hash cell dimensions\r\n         *\r\n         * @name Phaser.Physics.Impact.World#cellSize\r\n         * @type {integer}\r\n         * @default 64\r\n         * @since 3.0.0\r\n         */\r\n        this.cellSize = GetFastValue(config, 'cellSize', 64);\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#collisionMap\r\n         * @type {Phaser.Physics.Impact.CollisionMap}\r\n         * @since 3.0.0\r\n         */\r\n        this.collisionMap = new CollisionMap();\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#timeScale\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.timeScale = GetFastValue(config, 'timeScale', 1);\r\n\r\n        /**\r\n         * Impacts maximum time step is 20 fps.\r\n         *\r\n         * @name Phaser.Physics.Impact.World#maxStep\r\n         * @type {number}\r\n         * @default 0.05\r\n         * @since 3.0.0\r\n         */\r\n        this.maxStep = GetFastValue(config, 'maxStep', 0.05);\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#enabled\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.enabled = true;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#drawDebug\r\n         * @type {boolean}\r\n         * @since 3.0.0\r\n         */\r\n        this.drawDebug = GetFastValue(config, 'debug', false);\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#debugGraphic\r\n         * @type {Phaser.GameObjects.Graphics}\r\n         * @since 3.0.0\r\n         */\r\n        this.debugGraphic;\r\n\r\n        var _maxVelocity = GetFastValue(config, 'maxVelocity', 100);\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#defaults\r\n         * @type {Phaser.Types.Physics.Impact.WorldDefaults}\r\n         * @since 3.0.0\r\n         */\r\n        this.defaults = {\r\n            debugShowBody: GetFastValue(config, 'debugShowBody', true),\r\n            debugShowVelocity: GetFastValue(config, 'debugShowVelocity', true),\r\n            bodyDebugColor: GetFastValue(config, 'debugBodyColor', 0xff00ff),\r\n            velocityDebugColor: GetFastValue(config, 'debugVelocityColor', 0x00ff00),\r\n            maxVelocityX: GetFastValue(config, 'maxVelocityX', _maxVelocity),\r\n            maxVelocityY: GetFastValue(config, 'maxVelocityY', _maxVelocity),\r\n            minBounceVelocity: GetFastValue(config, 'minBounceVelocity', 40),\r\n            gravityFactor: GetFastValue(config, 'gravityFactor', 1),\r\n            bounciness: GetFastValue(config, 'bounciness', 0)\r\n        };\r\n\r\n        /**\r\n         * An object containing the 4 wall bodies that bound the physics world.\r\n         *\r\n         * @name Phaser.Physics.Impact.World#walls\r\n         * @type {Phaser.Types.Physics.Impact.WorldWalls}\r\n         * @since 3.0.0\r\n         */\r\n        this.walls = { left: null, right: null, top: null, bottom: null };\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#delta\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.delta = 0;\r\n\r\n        /**\r\n         * [description]\r\n         *\r\n         * @name Phaser.Physics.Impact.World#_lastId\r\n         * @type {number}\r\n         * @private\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this._lastId = 0;\r\n\r\n        if (GetFastValue(config, 'setBounds', false))\r\n        {\r\n            var boundsConfig = config['setBounds'];\r\n\r\n            if (typeof boundsConfig === 'boolean')\r\n            {\r\n                this.setBounds();\r\n            }\r\n            else\r\n            {\r\n                var x = GetFastValue(boundsConfig, 'x', 0);\r\n                var y = GetFastValue(boundsConfig, 'y', 0);\r\n                var width = GetFastValue(boundsConfig, 'width', scene.sys.scale.width);\r\n                var height = GetFastValue(boundsConfig, 'height', scene.sys.scale.height);\r\n                var thickness = GetFastValue(boundsConfig, 'thickness', 64);\r\n                var left = GetFastValue(boundsConfig, 'left', true);\r\n                var right = GetFastValue(boundsConfig, 'right', true);\r\n                var top = GetFastValue(boundsConfig, 'top', true);\r\n                var bottom = GetFastValue(boundsConfig, 'bottom', true);\r\n\r\n                this.setBounds(x, y, width, height, thickness, left, right, top, bottom);\r\n            }\r\n        }\r\n\r\n        if (this.drawDebug)\r\n        {\r\n            this.createDebugGraphic();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets the collision map for the world either from a Weltmeister JSON level in the cache or from\r\n     * a 2D array. If loading from a Weltmeister level, the map must have a layer called \"collision\".\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setCollisionMap\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(string|integer[][])} key - Either a string key that corresponds to a Weltmeister level\r\n     * in the cache, or a 2D array of collision IDs.\r\n     * @param {integer} tileSize - The size of a tile. This is optional if loading from a Weltmeister\r\n     * level in the cache.\r\n     *\r\n     * @return {?Phaser.Physics.Impact.CollisionMap} The newly created CollisionMap, or null if the method failed to\r\n     * create the CollisionMap.\r\n     */\r\n    setCollisionMap: function (key, tileSize)\r\n    {\r\n        if (typeof key === 'string')\r\n        {\r\n            var tilemapData = this.scene.cache.tilemap.get(key);\r\n\r\n            if (!tilemapData || tilemapData.format !== TILEMAP_FORMATS.WELTMEISTER)\r\n            {\r\n                console.warn('The specified key does not correspond to a Weltmeister tilemap: ' + key);\r\n                return null;\r\n            }\r\n\r\n            var layers = tilemapData.data.layer;\r\n            var collisionLayer;\r\n            for (var i = 0; i < layers.length; i++)\r\n            {\r\n                if (layers[i].name === 'collision')\r\n                {\r\n                    collisionLayer = layers[i];\r\n                    break;\r\n                }\r\n            }\r\n\r\n            if (tileSize === undefined) { tileSize = collisionLayer.tilesize; }\r\n\r\n            this.collisionMap = new CollisionMap(tileSize, collisionLayer.data);\r\n        }\r\n        else if (Array.isArray(key))\r\n        {\r\n            this.collisionMap = new CollisionMap(tileSize, key);\r\n        }\r\n        else\r\n        {\r\n            console.warn('Invalid Weltmeister collision map data: ' + key);\r\n        }\r\n\r\n        return this.collisionMap;\r\n    },\r\n\r\n    /**\r\n     * Sets the collision map for the world from a tilemap layer. Only tiles that are marked as\r\n     * colliding will be used. You can specify the mapping from tiles to slope IDs in a couple of\r\n     * ways. The easiest is to use Tiled and the slopeTileProperty option. Alternatively, you can\r\n     * manually create a slopeMap that stores the mapping between tile indices and slope IDs.\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setCollisionMapFromTilemapLayer\r\n     * @since 3.0.0\r\n     *\r\n     * @param {(Phaser.Tilemaps.DynamicTilemapLayer|Phaser.Tilemaps.StaticTilemapLayer)} tilemapLayer - The tilemap layer to use.\r\n     * @param {Phaser.Types.Physics.Impact.CollisionOptions} [options] - Options for controlling the mapping from tiles to slope IDs.\r\n     *\r\n     * @return {Phaser.Physics.Impact.CollisionMap} The newly created CollisionMap.\r\n     */\r\n    setCollisionMapFromTilemapLayer: function (tilemapLayer, options)\r\n    {\r\n        if (options === undefined) { options = {}; }\r\n        var slopeProperty = GetFastValue(options, 'slopeProperty', null);\r\n        var slopeMap = GetFastValue(options, 'slopeMap', null);\r\n        var collidingSlope = GetFastValue(options, 'defaultCollidingSlope', null);\r\n        var nonCollidingSlope = GetFastValue(options, 'defaultNonCollidingSlope', 0);\r\n\r\n        var layerData = tilemapLayer.layer;\r\n        var tileSize = layerData.baseTileWidth;\r\n        var collisionData = [];\r\n\r\n        for (var ty = 0; ty < layerData.height; ty++)\r\n        {\r\n            collisionData[ty] = [];\r\n\r\n            for (var tx = 0; tx < layerData.width; tx++)\r\n            {\r\n                var tile = layerData.data[ty][tx];\r\n\r\n                if (tile && tile.collides)\r\n                {\r\n                    if (slopeProperty !== null && HasValue(tile.properties, slopeProperty))\r\n                    {\r\n                        collisionData[ty][tx] = parseInt(tile.properties[slopeProperty], 10);\r\n                    }\r\n                    else if (slopeMap !== null && HasValue(slopeMap, tile.index))\r\n                    {\r\n                        collisionData[ty][tx] = slopeMap[tile.index];\r\n                    }\r\n                    else if (collidingSlope !== null)\r\n                    {\r\n                        collisionData[ty][tx] = collidingSlope;\r\n                    }\r\n                    else\r\n                    {\r\n                        collisionData[ty][tx] = tile.index;\r\n                    }\r\n                }\r\n                else\r\n                {\r\n                    collisionData[ty][tx] = nonCollidingSlope;\r\n                }\r\n            }\r\n        }\r\n\r\n        this.collisionMap = new CollisionMap(tileSize, collisionData);\r\n\r\n        return this.collisionMap;\r\n    },\r\n\r\n    /**\r\n     * Sets the bounds of the Physics world to match the given world pixel dimensions.\r\n     * You can optionally set which 'walls' to create: left, right, top or bottom.\r\n     * If none of the walls are given it will default to use the walls settings it had previously.\r\n     * I.e. if you previously told it to not have the left or right walls, and you then adjust the world size\r\n     * the newly created bounds will also not have the left and right walls.\r\n     * Explicitly state them in the parameters to override this.\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setBounds\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [x] - The x coordinate of the top-left corner of the bounds.\r\n     * @param {number} [y] - The y coordinate of the top-left corner of the bounds.\r\n     * @param {number} [width] - The width of the bounds.\r\n     * @param {number} [height] - The height of the bounds.\r\n     * @param {number} [thickness=64] - [description]\r\n     * @param {boolean} [left=true] - If true will create the left bounds wall.\r\n     * @param {boolean} [right=true] - If true will create the right bounds wall.\r\n     * @param {boolean} [top=true] - If true will create the top bounds wall.\r\n     * @param {boolean} [bottom=true] - If true will create the bottom bounds wall.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setBounds: function (x, y, width, height, thickness, left, right, top, bottom)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = this.scene.sys.scale.width; }\r\n        if (height === undefined) { height = this.scene.sys.scale.height; }\r\n        if (thickness === undefined) { thickness = 64; }\r\n        if (left === undefined) { left = true; }\r\n        if (right === undefined) { right = true; }\r\n        if (top === undefined) { top = true; }\r\n        if (bottom === undefined) { bottom = true; }\r\n\r\n        this.updateWall(left, 'left', x - thickness, y, thickness, height);\r\n        this.updateWall(right, 'right', x + width, y, thickness, height);\r\n        this.updateWall(top, 'top', x, y - thickness, width, thickness);\r\n        this.updateWall(bottom, 'bottom', x, y + height, width, thickness);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * position = 'left', 'right', 'top' or 'bottom'\r\n     *\r\n     * @method Phaser.Physics.Impact.World#updateWall\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} add - [description]\r\n     * @param {string} position - [description]\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} width - [description]\r\n     * @param {number} height - [description]\r\n     */\r\n    updateWall: function (add, position, x, y, width, height)\r\n    {\r\n        var wall = this.walls[position];\r\n\r\n        if (add)\r\n        {\r\n            if (wall)\r\n            {\r\n                wall.resetSize(x, y, width, height);\r\n            }\r\n            else\r\n            {\r\n                this.walls[position] = this.create(x, y, width, height);\r\n                this.walls[position].name = position;\r\n                this.walls[position].gravityFactor = 0;\r\n                this.walls[position].collides = COLLIDES.FIXED;\r\n            }\r\n        }\r\n        else\r\n        {\r\n            if (wall)\r\n            {\r\n                this.bodies.remove(wall);\r\n            }\r\n\r\n            this.walls[position] = null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Creates a Graphics Game Object used for debug display and enables the world for debug drawing.\r\n     *\r\n     * @method Phaser.Physics.Impact.World#createDebugGraphic\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.GameObjects.Graphics} The Graphics object created that will have the debug visuals drawn to it.\r\n     */\r\n    createDebugGraphic: function ()\r\n    {\r\n        var graphic = this.scene.sys.add.graphics({ x: 0, y: 0 });\r\n\r\n        graphic.setDepth(Number.MAX_VALUE);\r\n\r\n        this.debugGraphic = graphic;\r\n\r\n        this.drawDebug = true;\r\n\r\n        return graphic;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#getNextID\r\n     * @since 3.0.0\r\n     *\r\n     * @return {integer} [description]\r\n     */\r\n    getNextID: function ()\r\n    {\r\n        return this._lastId++;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#create\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} x - [description]\r\n     * @param {number} y - [description]\r\n     * @param {number} sizeX - [description]\r\n     * @param {number} sizeY - [description]\r\n     *\r\n     * @return {Phaser.Physics.Impact.Body} The Body that was added to this World.\r\n     */\r\n    create: function (x, y, sizeX, sizeY)\r\n    {\r\n        var body = new Body(this, x, y, sizeX, sizeY);\r\n\r\n        this.bodies.set(body);\r\n\r\n        return body;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#remove\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body} object - The Body to remove from this World.\r\n     */\r\n    remove: function (object)\r\n    {\r\n        this.bodies.delete(object);\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#pause\r\n     * @fires Phaser.Physics.Impact.Events#PAUSE\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    pause: function ()\r\n    {\r\n        this.enabled = false;\r\n\r\n        this.emit(Events.PAUSE);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#resume\r\n     * @fires Phaser.Physics.Impact.Events#RESUME\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    resume: function ()\r\n    {\r\n        this.enabled = true;\r\n\r\n        this.emit(Events.RESUME);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#update\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} time - The current time. Either a High Resolution Timer value if it comes from Request Animation Frame, or Date.now if using SetTimeout.\r\n     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n     */\r\n    update: function (time, delta)\r\n    {\r\n        if (!this.enabled || this.bodies.size === 0)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //  Impact uses a divided delta value that is clamped to the maxStep (20fps) maximum\r\n\r\n        var clampedDelta = Math.min(delta / 1000, this.maxStep) * this.timeScale;\r\n\r\n        this.delta = clampedDelta;\r\n\r\n        //  Update all active bodies\r\n\r\n        var i;\r\n        var body;\r\n        var bodies = this.bodies.entries;\r\n        var len = bodies.length;\r\n        var hash = {};\r\n        var size = this.cellSize;\r\n\r\n        for (i = 0; i < len; i++)\r\n        {\r\n            body = bodies[i];\r\n\r\n            if (body.enabled)\r\n            {\r\n                body.update(clampedDelta);\r\n            }\r\n        }\r\n\r\n        //  Run collision against them all now they're in the new positions from the update\r\n\r\n        for (i = 0; i < len; i++)\r\n        {\r\n            body = bodies[i];\r\n\r\n            if (body && !body.skipHash())\r\n            {\r\n                this.checkHash(body, hash, size);\r\n            }\r\n        }\r\n\r\n        if (this.drawDebug)\r\n        {\r\n            var graphics = this.debugGraphic;\r\n\r\n            graphics.clear();\r\n\r\n            for (i = 0; i < len; i++)\r\n            {\r\n                body = bodies[i];\r\n\r\n                if (body && body.willDrawDebug())\r\n                {\r\n                    body.drawDebug(graphics);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Check the body against the spatial hash.\r\n     *\r\n     * @method Phaser.Physics.Impact.World#checkHash\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body} body - [description]\r\n     * @param {object} hash - [description]\r\n     * @param {number} size - [description]\r\n     */\r\n    checkHash: function (body, hash, size)\r\n    {\r\n        var checked = {};\r\n\r\n        var xmin = Math.floor(body.pos.x / size);\r\n        var ymin = Math.floor(body.pos.y / size);\r\n        var xmax = Math.floor((body.pos.x + body.size.x) / size) + 1;\r\n        var ymax = Math.floor((body.pos.y + body.size.y) / size) + 1;\r\n\r\n        for (var x = xmin; x < xmax; x++)\r\n        {\r\n            for (var y = ymin; y < ymax; y++)\r\n            {\r\n                if (!hash[x])\r\n                {\r\n                    hash[x] = {};\r\n                    hash[x][y] = [ body ];\r\n                }\r\n                else if (!hash[x][y])\r\n                {\r\n                    hash[x][y] = [ body ];\r\n                }\r\n                else\r\n                {\r\n                    var cell = hash[x][y];\r\n\r\n                    for (var c = 0; c < cell.length; c++)\r\n                    {\r\n                        if (body.touches(cell[c]) && !checked[cell[c].id])\r\n                        {\r\n                            checked[cell[c].id] = true;\r\n\r\n                            this.checkBodies(body, cell[c]);\r\n                        }\r\n                    }\r\n\r\n                    cell.push(body);\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#checkBodies\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body} bodyA - [description]\r\n     * @param {Phaser.Physics.Impact.Body} bodyB - [description]\r\n     */\r\n    checkBodies: function (bodyA, bodyB)\r\n    {\r\n        //  2 fixed bodies won't do anything\r\n        if (bodyA.collides === COLLIDES.FIXED && bodyB.collides === COLLIDES.FIXED)\r\n        {\r\n            return;\r\n        }\r\n\r\n        //  bitwise checks\r\n        if (bodyA.checkAgainst & bodyB.type)\r\n        {\r\n            bodyA.check(bodyB);\r\n        }\r\n\r\n        if (bodyB.checkAgainst & bodyA.type)\r\n        {\r\n            bodyB.check(bodyA);\r\n        }\r\n\r\n        if (bodyA.collides && bodyB.collides && bodyA.collides + bodyB.collides > COLLIDES.ACTIVE)\r\n        {\r\n            Solver(this, bodyA, bodyB);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setCollidesNever\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setCollidesNever: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].collides = COLLIDES.NEVER;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setLite\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setLite: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].collides = COLLIDES.LITE;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setPassive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setPassive: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].collides = COLLIDES.PASSIVE;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setActive\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setActive: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].collides = COLLIDES.ACTIVE;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setFixed\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the collides value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setFixed: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].collides = COLLIDES.FIXED;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setTypeNone\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setTypeNone: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].type = TYPE.NONE;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setTypeA\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setTypeA: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].type = TYPE.A;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setTypeB\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setTypeB: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].type = TYPE.B;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setAvsB\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setAvsB: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].type = TYPE.A;\r\n            bodies[i].checkAgainst = TYPE.B;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setBvsA\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setBvsA: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].type = TYPE.B;\r\n            bodies[i].checkAgainst = TYPE.A;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setCheckAgainstNone\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setCheckAgainstNone: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].checkAgainst = TYPE.NONE;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setCheckAgainstA\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setCheckAgainstA: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].checkAgainst = TYPE.A;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#setCheckAgainstB\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Physics.Impact.Body[]} bodies - An Array of Impact Bodies to set the type value on.\r\n     *\r\n     * @return {Phaser.Physics.Impact.World} This World object.\r\n     */\r\n    setCheckAgainstB: function (bodies)\r\n    {\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            bodies[i].checkAgainst = TYPE.B;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#shutdown\r\n     * @since 3.0.0\r\n     */\r\n    shutdown: function ()\r\n    {\r\n        this.removeAllListeners();\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Physics.Impact.World#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.removeAllListeners();\r\n\r\n        this.scene = null;\r\n\r\n        this.bodies.clear();\r\n\r\n        this.bodies = null;\r\n\r\n        this.collisionMap = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = World;\r\n"},"sourceMaps":null,"error":null,"hash":"c4e4502a7eee847df578c98bd66eaf94","cacheData":{"env":{}}}