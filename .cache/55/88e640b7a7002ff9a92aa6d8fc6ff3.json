{"id":"../../node_modules/phaser/src/physics/matter-js/PointerConstraint.js","dependencies":[{"name":"C:\\Users\\דור\\Desktop\\pmm\\package.json","includedInParent":true,"mtime":1560952935180},{"name":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\package.json","includedInParent":true,"mtime":1561396619369},{"name":"./lib/geometry/Bounds","loc":{"line":7,"column":21},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\PointerConstraint.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\lib\\geometry\\Bounds.js"},{"name":"../../utils/Class","loc":{"line":8,"column":20},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\PointerConstraint.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\Class.js"},{"name":"./lib/body/Composite","loc":{"line":9,"column":24},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\PointerConstraint.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\lib\\body\\Composite.js"},{"name":"./lib/constraint/Constraint","loc":{"line":10,"column":25},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\PointerConstraint.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\lib\\constraint\\Constraint.js"},{"name":"./lib/collision/Detector","loc":{"line":11,"column":23},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\PointerConstraint.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\lib\\collision\\Detector.js"},{"name":"./events","loc":{"line":12,"column":21},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\PointerConstraint.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\events\\index.js"},{"name":"../../input/events","loc":{"line":13,"column":26},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\PointerConstraint.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\input\\events\\index.js"},{"name":"../../utils/object/Merge","loc":{"line":14,"column":20},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\PointerConstraint.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\object\\Merge.js"},{"name":"./lib/core/Sleeping","loc":{"line":15,"column":23},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\PointerConstraint.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\lib\\core\\Sleeping.js"},{"name":"../../math/Vector2","loc":{"line":16,"column":22},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\PointerConstraint.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\math\\Vector2.js"},{"name":"./lib/geometry/Vertices","loc":{"line":17,"column":23},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\PointerConstraint.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\matter-js\\lib\\geometry\\Vertices.js"}],"generated":{"js":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Bounds = require('./lib/geometry/Bounds');\r\nvar Class = require('../../utils/Class');\r\nvar Composite = require('./lib/body/Composite');\r\nvar Constraint = require('./lib/constraint/Constraint');\r\nvar Detector = require('./lib/collision/Detector');\r\nvar Events = require('./events');\r\nvar InputEvents = require('../../input/events');\r\nvar Merge = require('../../utils/object/Merge');\r\nvar Sleeping = require('./lib/core/Sleeping');\r\nvar Vector2 = require('../../math/Vector2');\r\nvar Vertices = require('./lib/geometry/Vertices');\r\n\r\n/**\r\n * @classdesc\r\n * A Pointer Constraint is a special type of constraint that allows you to click\r\n * and drag bodies in a Matter World. It monitors the active Pointers in a Scene,\r\n * and when one is pressed down it checks to see if that hit any part of any active\r\n * body in the world. If it did, and the body has input enabled, it will begin to\r\n * drag it until either released, or you stop it via the `stopDrag` method.\r\n * \r\n * You can adjust the stiffness, length and other properties of the constraint via\r\n * the `options` object on creation.\r\n *\r\n * @class PointerConstraint\r\n * @memberof Phaser.Physics.Matter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Scene} scene - A reference to the Scene to which this Pointer Constraint belongs.\r\n * @param {Phaser.Physics.Matter.World} world - A reference to the Matter World instance to which this Constraint belongs.\r\n * @param {object} [options] - A Constraint configuration object.\r\n */\r\nvar PointerConstraint = new Class({\r\n\r\n    initialize:\r\n\r\n    function PointerConstraint (scene, world, options)\r\n    {\r\n        if (options === undefined) { options = {}; }\r\n\r\n        //  Defaults\r\n        var defaults = {\r\n            label: 'Pointer Constraint',\r\n            pointA: { x: 0, y: 0 },\r\n            pointB: { x: 0, y: 0 },\r\n            damping: 0,\r\n            length: 0.01,\r\n            stiffness: 0.1,\r\n            angularStiffness: 1,\r\n            collisionFilter: {\r\n                category: 0x0001,\r\n                mask: 0xFFFFFFFF,\r\n                group: 0\r\n            }\r\n        };\r\n\r\n        /**\r\n         * A reference to the Scene to which this Pointer Constraint belongs.\r\n         * This is the same Scene as the Matter World instance.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#scene\r\n         * @type {Phaser.Scene}\r\n         * @since 3.0.0\r\n         */\r\n        this.scene = scene;\r\n\r\n        /**\r\n         * A reference to the Matter World instance to which this Constraint belongs.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#world\r\n         * @type {Phaser.Physics.Matter.World}\r\n         * @since 3.0.0\r\n         */\r\n        this.world = world;\r\n\r\n        /**\r\n         * The Camera the Pointer was interacting with when the input\r\n         * down event was processed.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#camera\r\n         * @type {Phaser.Cameras.Scene2D.Camera}\r\n         * @since 3.0.0\r\n         */\r\n        this.camera = null;\r\n\r\n        /**\r\n         * A reference to the Input Pointer that activated this Constraint.\r\n         * This is set in the `onDown` handler.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#pointer\r\n         * @type {Phaser.Input.Pointer}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.pointer = null;\r\n\r\n        /**\r\n         * Is this Constraint active or not?\r\n         * \r\n         * An active constraint will be processed each update. An inactive one will be skipped.\r\n         * Use this to toggle a Pointer Constraint on and off.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#active\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.active = true;\r\n\r\n        /**\r\n         * The internal transformed position.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#position\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.0.0\r\n         */\r\n        this.position = new Vector2();\r\n\r\n        /**\r\n         * The body that is currently being dragged, if any.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#body\r\n         * @type {?MatterJS.Body}\r\n         * @since 3.16.2\r\n         */\r\n        this.body = null;\r\n\r\n        /**\r\n         * The part of the body that was clicked on to start the drag.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#part\r\n         * @type {?MatterJS.Body}\r\n         * @since 3.16.2\r\n         */\r\n        this.part = null;\r\n\r\n        /**\r\n         * The native Matter Constraint that is used to attach to bodies.\r\n         *\r\n         * @name Phaser.Physics.Matter.PointerConstraint#constraint\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.constraint = Constraint.create(Merge(options, defaults));\r\n\r\n        this.world.on(Events.BEFORE_UPDATE, this.update, this);\r\n\r\n        scene.sys.input.on(InputEvents.POINTER_DOWN, this.onDown, this);\r\n    },\r\n\r\n    /**\r\n     * A Pointer has been pressed down onto the Scene.\r\n     * \r\n     * If this Constraint doesn't have an active Pointer then a hit test is\r\n     * run against all active bodies in the world. If one is found it is bound\r\n     * to this constraint and the drag begins.\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#onDown\r\n     * @fires Phaser.Physics.Matter.Events#DRAG_START\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Input.Pointer} pointer - A reference to the Pointer that was pressed.\r\n     */\r\n    onDown: function (pointer)\r\n    {\r\n        if (!this.pointer)\r\n        {\r\n            if (this.getBody(pointer))\r\n            {\r\n                this.pointer = pointer;\r\n\r\n                this.camera = pointer.camera;\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Scans all active bodies in the current Matter World to see if any of them\r\n     * are hit by the Pointer. The _first one_ found to hit is set as the active contraint\r\n     * body.\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#getBody\r\n     * @since 3.16.2\r\n     * \r\n     * @return {boolean} `true` if a body was found and set, otherwise `false`.\r\n     */\r\n    getBody: function (pointer)\r\n    {\r\n        var pos = this.position;\r\n        var constraint = this.constraint;\r\n\r\n        pointer.camera.getWorldPoint(pointer.x, pointer.y, pos);\r\n\r\n        var bodies = Composite.allBodies(this.world.localWorld);\r\n\r\n        for (var i = 0; i < bodies.length; i++)\r\n        {\r\n            var body = bodies[i];\r\n\r\n            if (!body.ignorePointer &&\r\n                Bounds.contains(body.bounds, pos) &&\r\n                Detector.canCollide(body.collisionFilter, constraint.collisionFilter))\r\n            {\r\n                if (this.hitTestBody(body, pos))\r\n                {\r\n                    this.world.emit(Events.DRAG_START, this.body, this.part, this);\r\n\r\n                    return true;\r\n                }\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Scans the current body to determine if a part of it was clicked on.\r\n     * If a part is found the body is set as the `constraint.bodyB` property,\r\n     * as well as the `body` property of this class. The part is also set.\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#hitTestBody\r\n     * @since 3.16.2\r\n     *\r\n     * @param {MatterJS.Body} body - The Matter Body to check.\r\n     * @param {Phaser.Math.Vector2} position - A translated hit test position.\r\n     *\r\n     * @return {boolean} `true` if a part of the body was hit, otherwise `false`.\r\n     */\r\n    hitTestBody: function (body, position)\r\n    {\r\n        var constraint = this.constraint;\r\n\r\n        var start = (body.parts.length > 1) ? 1 : 0;\r\n\r\n        for (var i = start; i < body.parts.length; i++)\r\n        {\r\n            var part = body.parts[i];\r\n\r\n            if (Vertices.contains(part.vertices, position))\r\n            {\r\n                constraint.bodyB = body;\r\n\r\n                constraint.pointA.x = position.x;\r\n                constraint.pointA.y = position.y;\r\n\r\n                constraint.pointB.x = position.x - body.position.x;\r\n                constraint.pointB.y = position.y - body.position.y;\r\n\r\n                constraint.angleB = body.angle;\r\n\r\n                Sleeping.set(body, false);\r\n\r\n                this.part = part;\r\n                this.body = body;\r\n\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Internal update handler. Called in the Matter BEFORE_UPDATE step.\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#update\r\n     * @fires Phaser.Physics.Matter.Events#DRAG\r\n     * @since 3.0.0\r\n     */\r\n    update: function ()\r\n    {\r\n        var body = this.body;\r\n        var pointer = this.pointer;\r\n\r\n        if (!this.active || !pointer || !body)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (pointer.isDown)\r\n        {\r\n            var pos = this.position;\r\n            var constraint = this.constraint;\r\n    \r\n            this.camera.getWorldPoint(pointer.x, pointer.y, pos);\r\n    \r\n            Sleeping.set(body, false);\r\n    \r\n            constraint.pointA.x = pos.x;\r\n            constraint.pointA.y = pos.y;\r\n    \r\n            this.world.emit(Events.DRAG, body, this);\r\n        }\r\n        else\r\n        {\r\n            //  Pointer has been released since the last world step\r\n            this.stopDrag();\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Stops the Pointer Constraint from dragging the body any further.\r\n     * \r\n     * This is called automatically if the Pointer is released while actively\r\n     * dragging a body. Or, you can call it manually to release a body from a\r\n     * constraint without having to first release the pointer.\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#stopDrag\r\n     * @fires Phaser.Physics.Matter.Events#DRAG_END\r\n     * @since 3.16.2\r\n     */\r\n    stopDrag: function ()\r\n    {\r\n        var body = this.body;\r\n        var constraint = this.constraint;\r\n\r\n        if (body)\r\n        {\r\n            this.world.emit(Events.DRAG_END, body, this);\r\n\r\n            this.pointer = null;\r\n            this.body = null;\r\n            this.part = null;\r\n\r\n            constraint.bodyB = null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Destroys this Pointer Constraint instance and all of its references.\r\n     *\r\n     * @method Phaser.Physics.Matter.PointerConstraint#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.world.removeConstraint(this.constraint);\r\n\r\n        this.pointer = null;\r\n        this.constraint = null;\r\n        this.body = null;\r\n        this.part = null;\r\n\r\n        this.world.off(Events.BEFORE_UPDATE, this.update);\r\n\r\n        this.scene.sys.input.off(InputEvents.POINTER_DOWN, this.onDown, this);\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = PointerConstraint;\r\n"},"sourceMaps":null,"error":null,"hash":"da21a9557f6c66a361d9b3582882f443","cacheData":{"env":{}}}