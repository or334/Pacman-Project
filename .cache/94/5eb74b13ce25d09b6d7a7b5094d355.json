{"id":"../../node_modules/phaser/src/tweens/Timeline.js","dependencies":[{"name":"C:\\Users\\Admin\\Desktop\\pmm\\package.json","includedInParent":true,"mtime":1560952935180},{"name":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\package.json","includedInParent":true,"mtime":1561134727120},{"name":"../utils/Class","loc":{"line":7,"column":20},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\tweens\\Timeline.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\Class.js"},{"name":"eventemitter3","loc":{"line":8,"column":27},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\tweens\\Timeline.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\eventemitter3\\index.js"},{"name":"./events","loc":{"line":9,"column":21},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\tweens\\Timeline.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\tweens\\events\\index.js"},{"name":"./builders/TweenBuilder","loc":{"line":10,"column":27},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\tweens\\Timeline.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\tweens\\builders\\TweenBuilder.js"},{"name":"./tween/const","loc":{"line":11,"column":26},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\tweens\\Timeline.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\tweens\\tween\\const.js"}],"generated":{"js":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar Class = require('../utils/Class');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar TweenBuilder = require('./builders/TweenBuilder');\r\nvar TWEEN_CONST = require('./tween/const');\r\n\r\n/**\r\n * @classdesc\r\n * A Timeline combines multiple Tweens into one. Its overall behavior is otherwise similar to a single Tween.\r\n *\r\n * The Timeline updates all of its Tweens simultaneously. Its methods allow you to easily build a sequence of Tweens (each one starting after the previous one) or run multiple Tweens at once during given parts of the Timeline.\r\n *\r\n * @class Timeline\r\n * @memberof Phaser.Tweens\r\n * @extends Phaser.Events.EventEmitter\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Tweens.TweenManager} manager - The Tween Manager which owns this Timeline.\r\n */\r\nvar Timeline = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function Timeline (manager)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * The Tween Manager which owns this Timeline.\r\n         *\r\n         * @name Phaser.Tweens.Timeline#manager\r\n         * @type {Phaser.Tweens.TweenManager}\r\n         * @since 3.0.0\r\n         */\r\n        this.manager = manager;\r\n\r\n        /**\r\n         * A constant value which allows this Timeline to be easily identified as one.\r\n         *\r\n         * @name Phaser.Tweens.Timeline#isTimeline\r\n         * @type {boolean}\r\n         * @default true\r\n         * @since 3.0.0\r\n         */\r\n        this.isTimeline = true;\r\n\r\n        /**\r\n         * An array of Tween objects, each containing a unique property and target being tweened.\r\n         *\r\n         * @name Phaser.Tweens.Timeline#data\r\n         * @type {array}\r\n         * @default []\r\n         * @since 3.0.0\r\n         */\r\n        this.data = [];\r\n\r\n        /**\r\n         * data array doesn't usually change, so we can cache the length\r\n         *\r\n         * @name Phaser.Tweens.Timeline#totalData\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.totalData = 0;\r\n\r\n        /**\r\n         * If true then duration, delay, etc values are all frame totals.\r\n         *\r\n         * @name Phaser.Tweens.Timeline#useFrames\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.useFrames = false;\r\n\r\n        /**\r\n         * Scales the time applied to this Tween. A value of 1 runs in real-time. A value of 0.5 runs 50% slower, and so on.\r\n         * Value isn't used when calculating total duration of the tween, it's a run-time delta adjustment only.\r\n         *\r\n         * @name Phaser.Tweens.Timeline#timeScale\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.0.0\r\n         */\r\n        this.timeScale = 1;\r\n\r\n        /**\r\n         * Loop this tween? Can be -1 for an infinite loop, or an integer.\r\n         * When enabled it will play through ALL TweenDatas again (use TweenData.repeat to loop a single TD)\r\n         *\r\n         * @name Phaser.Tweens.Timeline#loop\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.loop = 0;\r\n\r\n        /**\r\n         * Time in ms/frames before the tween loops.\r\n         *\r\n         * @name Phaser.Tweens.Timeline#loopDelay\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.loopDelay = 0;\r\n\r\n        /**\r\n         * How many loops are left to run?\r\n         *\r\n         * @name Phaser.Tweens.Timeline#loopCounter\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.loopCounter = 0;\r\n\r\n        /**\r\n         * Time in ms/frames before the 'onComplete' event fires. This never fires if loop = true (as it never completes)\r\n         *\r\n         * @name Phaser.Tweens.Timeline#completeDelay\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.completeDelay = 0;\r\n\r\n        /**\r\n         * Countdown timer (used by loopDelay and completeDelay)\r\n         *\r\n         * @name Phaser.Tweens.Timeline#countdown\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.countdown = 0;\r\n\r\n        /**\r\n         * The current state of the tween\r\n         *\r\n         * @name Phaser.Tweens.Timeline#state\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.state = TWEEN_CONST.PENDING_ADD;\r\n\r\n        /**\r\n         * The state of the tween when it was paused (used by Resume)\r\n         *\r\n         * @name Phaser.Tweens.Timeline#_pausedState\r\n         * @type {integer}\r\n         * @private\r\n         * @since 3.0.0\r\n         */\r\n        this._pausedState = TWEEN_CONST.PENDING_ADD;\r\n\r\n        /**\r\n         * Does the Tween start off paused? (if so it needs to be started with Tween.play)\r\n         *\r\n         * @name Phaser.Tweens.Timeline#paused\r\n         * @type {boolean}\r\n         * @default false\r\n         * @since 3.0.0\r\n         */\r\n        this.paused = false;\r\n\r\n        /**\r\n         * Elapsed time in ms/frames of this run through the Tween.\r\n         *\r\n         * @name Phaser.Tweens.Timeline#elapsed\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.elapsed = 0;\r\n\r\n        /**\r\n         * Total elapsed time in ms/frames of the entire Tween, including looping.\r\n         *\r\n         * @name Phaser.Tweens.Timeline#totalElapsed\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.totalElapsed = 0;\r\n\r\n        /**\r\n         * Time in ms/frames for the whole Tween to play through once, excluding loop amounts and loop delays.\r\n         *\r\n         * @name Phaser.Tweens.Timeline#duration\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.duration = 0;\r\n\r\n        /**\r\n         * Value between 0 and 1. The amount through the Tween, excluding loops.\r\n         *\r\n         * @name Phaser.Tweens.Timeline#progress\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.progress = 0;\r\n\r\n        /**\r\n         * Time in ms/frames for all Tweens to complete (including looping)\r\n         *\r\n         * @name Phaser.Tweens.Timeline#totalDuration\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.totalDuration = 0;\r\n\r\n        /**\r\n         * Value between 0 and 1. The amount through the entire Tween, including looping.\r\n         *\r\n         * @name Phaser.Tweens.Timeline#totalProgress\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.totalProgress = 0;\r\n\r\n        this.callbacks = {\r\n            onComplete: null,\r\n            onLoop: null,\r\n            onStart: null,\r\n            onUpdate: null,\r\n            onYoyo: null\r\n        };\r\n\r\n        this.callbackScope;\r\n    },\r\n\r\n    /**\r\n     * Sets the value of the time scale applied to this Timeline. A value of 1 runs in real-time. A value of 0.5 runs 50% slower, and so on.\r\n     * Value isn't used when calculating total duration of the tween, it's a run-time delta adjustment only.\r\n     *\r\n     * @method Phaser.Tweens.Timeline#setTimeScale\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The time scale value to set.\r\n     *\r\n     * @return {Phaser.Tweens.Timeline} This Timeline object.\r\n     */\r\n    setTimeScale: function (value)\r\n    {\r\n        this.timeScale = value;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Gets the value of the time scale applied to this Timeline. A value of 1 runs in real-time. A value of 0.5 runs 50% slower, and so on. \r\n     *\r\n     * @method Phaser.Tweens.Timeline#getTimeScale\r\n     * @since 3.0.0\r\n     *\r\n     * @return {number} The value of the time scale applied to this Tween.\r\n     */\r\n    getTimeScale: function ()\r\n    {\r\n        return this.timeScale;\r\n    },\r\n\r\n    /**\r\n     * Check whether or not the Timeline is playing.\r\n     *\r\n     * @method Phaser.Tweens.Timeline#isPlaying\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} `true` if this Timeline is active, otherwise `false`.\r\n     */\r\n    isPlaying: function ()\r\n    {\r\n        return (this.state === TWEEN_CONST.ACTIVE);\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Timeline#add\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} config - [description]\r\n     *\r\n     * @return {Phaser.Tweens.Timeline} This Timeline object.\r\n     */\r\n    add: function (config)\r\n    {\r\n        return this.queue(TweenBuilder(this, config));\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Timeline#queue\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tweens.Tween} tween - [description]\r\n     *\r\n     * @return {Phaser.Tweens.Timeline} This Timeline object.\r\n     */\r\n    queue: function (tween)\r\n    {\r\n        if (!this.isPlaying())\r\n        {\r\n            tween.parent = this;\r\n            tween.parentIsTimeline = true;\r\n\r\n            this.data.push(tween);\r\n\r\n            this.totalData = this.data.length;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Timeline#hasOffset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Tweens.Tween} tween - [description]\r\n     *\r\n     * @return {boolean} [description]\r\n     */\r\n    hasOffset: function (tween)\r\n    {\r\n        return (tween.offset !== null);\r\n    },\r\n\r\n    /**\r\n     * Checks whether the offset value is a number or a directive that is relative to previous tweens.\r\n     *\r\n     * @method Phaser.Tweens.Timeline#isOffsetAbsolute\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} value - The offset value to be evaluated\r\n     *\r\n     * @return {boolean} True if the result is a number, false if it is a directive like \" -= 1000\"\r\n     */\r\n    isOffsetAbsolute: function (value)\r\n    {\r\n        return (typeof(value) === 'number');\r\n    },\r\n\r\n    /**\r\n     * Checks if the offset is a relative value rather than an absolute one. If the value is just a number, this returns false.\r\n     *\r\n     * @method Phaser.Tweens.Timeline#isOffsetRelative\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} value - The offset value to be evaluated\r\n     *\r\n     * @return {boolean} Returns true if the value is relative, i.e \" -= 1000\". If false, the offset is absolute.\r\n     */\r\n    isOffsetRelative: function (value)\r\n    {\r\n        var t = typeof(value);\r\n\r\n        if (t === 'string')\r\n        {\r\n            var op = value[0];\r\n\r\n            if (op === '-' || op === '+')\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Parses the relative offset value, returning a positive or negative number.\r\n     *\r\n     * @method Phaser.Tweens.Timeline#getRelativeOffset\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} value - The relative offset, in the format of '-=500', for example. The first character determines whether it will be a positive or negative number. Spacing matters here.\r\n     * @param {number} base - The value to use as the offset.\r\n     *\r\n     * @return {number} The returned number value.\r\n     */\r\n    getRelativeOffset: function (value, base)\r\n    {\r\n        var op = value[0];\r\n        var num = parseFloat(value.substr(2));\r\n        var result = base;\r\n\r\n        switch (op)\r\n        {\r\n            case '+':\r\n                result += num;\r\n                break;\r\n\r\n            case '-':\r\n                result -= num;\r\n                break;\r\n        }\r\n\r\n        //  Cannot ever be < 0\r\n        return Math.max(0, result);\r\n    },\r\n\r\n    /**\r\n     * Calculates the total duration of the timeline.  Computes all tween's durations and returns the full duration of the timeline. The resulting number is stored in the timeline, not as a return value.\r\n     *\r\n     * @method Phaser.Tweens.Timeline#calcDuration\r\n     * @since 3.0.0\r\n     */\r\n    calcDuration: function ()\r\n    {\r\n        var prevEnd = 0;\r\n        var totalDuration = 0;\r\n        var offsetDuration = 0;\r\n\r\n        for (var i = 0; i < this.totalData; i++)\r\n        {\r\n            var tween = this.data[i];\r\n\r\n            tween.init();\r\n\r\n            if (this.hasOffset(tween))\r\n            {\r\n                if (this.isOffsetAbsolute(tween.offset))\r\n                {\r\n                    //  An actual number, so it defines the start point from the beginning of the timeline\r\n                    tween.calculatedOffset = tween.offset;\r\n\r\n                    if (tween.offset === 0)\r\n                    {\r\n                        offsetDuration = 0;\r\n                    }\r\n                }\r\n                else if (this.isOffsetRelative(tween.offset))\r\n                {\r\n                    //  A relative offset (i.e. '-=1000', so starts at 'offset' ms relative to the PREVIOUS Tweens ending time)\r\n                    tween.calculatedOffset = this.getRelativeOffset(tween.offset, prevEnd);\r\n                }\r\n            }\r\n            else\r\n            {\r\n                //  Sequential\r\n                tween.calculatedOffset = offsetDuration;\r\n            }\r\n\r\n            prevEnd = tween.totalDuration + tween.calculatedOffset;\r\n\r\n            totalDuration += tween.totalDuration;\r\n            offsetDuration += tween.totalDuration;\r\n        }\r\n\r\n        //  Excludes loop values\r\n        this.duration = totalDuration;\r\n\r\n        this.loopCounter = (this.loop === -1) ? 999999999999 : this.loop;\r\n\r\n        if (this.loopCounter > 0)\r\n        {\r\n            this.totalDuration = this.duration + this.completeDelay + ((this.duration + this.loopDelay) * this.loopCounter);\r\n        }\r\n        else\r\n        {\r\n            this.totalDuration = this.duration + this.completeDelay;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Initializes the timeline, which means all Tweens get their init() called, and the total duration will be computed. Returns a boolean indicating whether the timeline is auto-started or not.\r\n     *\r\n     * @method Phaser.Tweens.Timeline#init\r\n     * @since 3.0.0\r\n     *\r\n     * @return {boolean} Returns true if the timeline is started. False if it is paused.\r\n     */\r\n    init: function ()\r\n    {\r\n        this.calcDuration();\r\n\r\n        this.progress = 0;\r\n        this.totalProgress = 0;\r\n\r\n        if (this.paused)\r\n        {\r\n            this.state = TWEEN_CONST.PAUSED;\r\n\r\n            return false;\r\n        }\r\n        else\r\n        {\r\n            return true;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Resets all of the timeline's tweens back to their initial states.  The boolean parameter indicates whether tweens that are looping should reset as well, or not.\r\n     *\r\n     * @method Phaser.Tweens.Timeline#resetTweens\r\n     * @since 3.0.0\r\n     *\r\n     * @param {boolean} resetFromLoop - If true, resets all looping tweens to their initial values.\r\n     */\r\n    resetTweens: function (resetFromLoop)\r\n    {\r\n        for (var i = 0; i < this.totalData; i++)\r\n        {\r\n            var tween = this.data[i];\r\n\r\n            tween.play(resetFromLoop);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Sets a callback for the Timeline.\r\n     *\r\n     * @method Phaser.Tweens.Timeline#setCallback\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} type - The internal type of callback to set.\r\n     * @param {function} callback - Timeline allows multiple tweens to be linked together to create a streaming sequence.\r\n     * @param {array} [params] - The parameters to pass to the callback.\r\n     * @param {object} [scope] - The context scope of the callback.\r\n     *\r\n     * @return {Phaser.Tweens.Timeline} This Timeline object.\r\n     */\r\n    setCallback: function (type, callback, params, scope)\r\n    {\r\n        if (Timeline.TYPES.indexOf(type) !== -1)\r\n        {\r\n            this.callbacks[type] = { func: callback, scope: scope, params: params };\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Delegates #makeActive to the Tween manager.\r\n     *\r\n     * @method Phaser.Tweens.Timeline#makeActive\r\n     * @since 3.3.0\r\n     *\r\n     * @param {Phaser.Tweens.Tween} tween - The tween object to make active.\r\n     *\r\n     * @return {Phaser.Tweens.TweenManager} The Timeline's Tween Manager object.\r\n     */\r\n    makeActive: function (tween)\r\n    {\r\n        return this.manager.makeActive(tween);\r\n    },\r\n\r\n    /**\r\n     * Starts playing the timeline.\r\n     *\r\n     * @method Phaser.Tweens.Timeline#play\r\n     * @fires Phaser.Tweens.Events#TIMELINE_START\r\n     * @since 3.0.0\r\n     */\r\n    play: function ()\r\n    {\r\n        if (this.state === TWEEN_CONST.ACTIVE)\r\n        {\r\n            return;\r\n        }\r\n\r\n        if (this.paused)\r\n        {\r\n            this.paused = false;\r\n\r\n            this.manager.makeActive(this);\r\n\r\n            return;\r\n        }\r\n        else\r\n        {\r\n            this.resetTweens(false);\r\n\r\n            this.state = TWEEN_CONST.ACTIVE;\r\n        }\r\n\r\n        var onStart = this.callbacks.onStart;\r\n\r\n        if (onStart)\r\n        {\r\n            onStart.func.apply(onStart.scope, onStart.params);\r\n        }\r\n\r\n        this.emit(Events.TIMELINE_START, this);\r\n    },\r\n\r\n    /**\r\n     * [description]\r\n     *\r\n     * @method Phaser.Tweens.Timeline#nextState\r\n     * @fires Phaser.Tweens.Events#TIMELINE_COMPLETE\r\n     * @fires Phaser.Tweens.Events#TIMELINE_LOOP\r\n     * @since 3.0.0\r\n     */\r\n    nextState: function ()\r\n    {\r\n        if (this.loopCounter > 0)\r\n        {\r\n            //  Reset the elapsed time\r\n            //  TODO: Probably ought to be set to the remainder from elapsed - duration\r\n            //  as the tweens nearly always over-run by a few ms due to rAf\r\n\r\n            this.elapsed = 0;\r\n            this.progress = 0;\r\n\r\n            this.loopCounter--;\r\n\r\n            var onLoop = this.callbacks.onLoop;\r\n\r\n            if (onLoop)\r\n            {\r\n                onLoop.func.apply(onLoop.scope, onLoop.params);\r\n            }\r\n\r\n            this.emit(Events.TIMELINE_LOOP, this, this.loopCounter);\r\n\r\n            this.resetTweens(true);\r\n\r\n            if (this.loopDelay > 0)\r\n            {\r\n                this.countdown = this.loopDelay;\r\n                this.state = TWEEN_CONST.LOOP_DELAY;\r\n            }\r\n            else\r\n            {\r\n                this.state = TWEEN_CONST.ACTIVE;\r\n            }\r\n        }\r\n        else if (this.completeDelay > 0)\r\n        {\r\n            this.countdown = this.completeDelay;\r\n            this.state = TWEEN_CONST.COMPLETE_DELAY;\r\n        }\r\n        else\r\n        {\r\n            this.state = TWEEN_CONST.PENDING_REMOVE;\r\n\r\n            var onComplete = this.callbacks.onComplete;\r\n\r\n            if (onComplete)\r\n            {\r\n                onComplete.func.apply(onComplete.scope, onComplete.params);\r\n            }\r\n\r\n            this.emit(Events.TIMELINE_COMPLETE, this);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Returns 'true' if this Timeline has finished and should be removed from the Tween Manager.\r\n     * Otherwise, returns false.\r\n     *\r\n     * @method Phaser.Tweens.Timeline#update\r\n     * @fires Phaser.Tweens.Events#TIMELINE_COMPLETE\r\n     * @fires Phaser.Tweens.Events#TIMELINE_UPDATE\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} timestamp - [description]\r\n     * @param {number} delta - The delta time in ms since the last frame. This is a smoothed and capped value based on the FPS rate.\r\n     *\r\n     * @return {boolean} Returns `true` if this Timeline has finished and should be removed from the Tween Manager.\r\n     */\r\n    update: function (timestamp, delta)\r\n    {\r\n        if (this.state === TWEEN_CONST.PAUSED)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var rawDelta = delta;\r\n\r\n        if (this.useFrames)\r\n        {\r\n            delta = 1 * this.manager.timeScale;\r\n        }\r\n\r\n        delta *= this.timeScale;\r\n\r\n        this.elapsed += delta;\r\n        this.progress = Math.min(this.elapsed / this.duration, 1);\r\n\r\n        this.totalElapsed += delta;\r\n        this.totalProgress = Math.min(this.totalElapsed / this.totalDuration, 1);\r\n\r\n        switch (this.state)\r\n        {\r\n            case TWEEN_CONST.ACTIVE:\r\n\r\n                var stillRunning = this.totalData;\r\n\r\n                for (var i = 0; i < this.totalData; i++)\r\n                {\r\n                    var tween = this.data[i];\r\n\r\n                    if (tween.update(timestamp, rawDelta))\r\n                    {\r\n                        stillRunning--;\r\n                    }\r\n                }\r\n\r\n                var onUpdate = this.callbacks.onUpdate;\r\n\r\n                if (onUpdate)\r\n                {\r\n                    onUpdate.func.apply(onUpdate.scope, onUpdate.params);\r\n                }\r\n\r\n                this.emit(Events.TIMELINE_UPDATE, this);\r\n\r\n                //  Anything still running? If not, we're done\r\n                if (stillRunning === 0)\r\n                {\r\n                    this.nextState();\r\n                }\r\n\r\n                break;\r\n\r\n            case TWEEN_CONST.LOOP_DELAY:\r\n\r\n                this.countdown -= delta;\r\n\r\n                if (this.countdown <= 0)\r\n                {\r\n                    this.state = TWEEN_CONST.ACTIVE;\r\n                }\r\n\r\n                break;\r\n\r\n            case TWEEN_CONST.COMPLETE_DELAY:\r\n\r\n                this.countdown -= delta;\r\n\r\n                if (this.countdown <= 0)\r\n                {\r\n                    this.state = TWEEN_CONST.PENDING_REMOVE;\r\n\r\n                    var onComplete = this.callbacks.onComplete;\r\n\r\n                    if (onComplete)\r\n                    {\r\n                        onComplete.func.apply(onComplete.scope, onComplete.params);\r\n                    }\r\n\r\n                    this.emit(Events.TIMELINE_COMPLETE, this);\r\n                }\r\n\r\n                break;\r\n        }\r\n\r\n        return (this.state === TWEEN_CONST.PENDING_REMOVE);\r\n    },\r\n\r\n    /**\r\n     * Stops the Tween immediately, whatever stage of progress it is at and flags it for removal by the TweenManager.\r\n     *\r\n     * @method Phaser.Tweens.Timeline#stop\r\n     * @since 3.0.0\r\n     */\r\n    stop: function ()\r\n    {\r\n        this.state = TWEEN_CONST.PENDING_REMOVE;\r\n    },\r\n\r\n    /**\r\n     * Pauses the timeline, retaining its internal state.\r\n     *\r\n     * @method Phaser.Tweens.Timeline#pause\r\n     * @fires Phaser.Tweens.Events#TIMELINE_PAUSE\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Tweens.Timeline} This Timeline object.\r\n     */\r\n    pause: function ()\r\n    {\r\n        if (this.state === TWEEN_CONST.PAUSED)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this.paused = true;\r\n\r\n        this._pausedState = this.state;\r\n\r\n        this.state = TWEEN_CONST.PAUSED;\r\n\r\n        this.emit(Events.TIMELINE_PAUSE, this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Resumes the timeline from where it was when it was paused.\r\n     *\r\n     * @method Phaser.Tweens.Timeline#resume\r\n     * @fires Phaser.Tweens.Events#TIMELINE_RESUME\r\n     * @since 3.0.0\r\n     *\r\n     * @return {Phaser.Tweens.Timeline} This Timeline object.\r\n     */\r\n    resume: function ()\r\n    {\r\n        if (this.state === TWEEN_CONST.PAUSED)\r\n        {\r\n            this.paused = false;\r\n\r\n            this.state = this._pausedState;\r\n        }\r\n\r\n        this.emit(Events.TIMELINE_RESUME, this);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Checks if any of the tweens has the target as the object they are operating on. Retuns false if no tweens operate on the target object.\r\n     *\r\n     * @method Phaser.Tweens.Timeline#hasTarget\r\n     * @since 3.0.0\r\n     *\r\n     * @param {object} target - The target to check all tweens against.\r\n     *\r\n     * @return {boolean} True if there at least a single tween that operates on the target object. False otherwise.\r\n     */\r\n    hasTarget: function (target)\r\n    {\r\n        for (var i = 0; i < this.data.length; i++)\r\n        {\r\n            if (this.data[i].hasTarget(target))\r\n            {\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * Stops all the Tweens in the Timeline immediately, whatever stage of progress they are at and flags them for removal by the TweenManager.\r\n     *\r\n     * @method Phaser.Tweens.Timeline#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        for (var i = 0; i < this.data.length; i++)\r\n        {\r\n            this.data[i].stop();\r\n        }\r\n\r\n    }\r\n});\r\n\r\nTimeline.TYPES = [ 'onStart', 'onUpdate', 'onLoop', 'onComplete', 'onYoyo' ];\r\n\r\nmodule.exports = Timeline;\r\n"},"sourceMaps":null,"error":null,"hash":"9169e50bd9d5aeb1a59699fb8131fd9b","cacheData":{"env":{}}}