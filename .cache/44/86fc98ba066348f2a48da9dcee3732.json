{"id":"../../node_modules/phaser/src/physics/arcade/Factory.js","dependencies":[{"name":"C:\\Users\\Admin\\Desktop\\pmm\\package.json","includedInParent":true,"mtime":1560952935180},{"name":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\package.json","includedInParent":true,"mtime":1561134727120},{"name":"./ArcadeImage","loc":{"line":7,"column":26},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\Factory.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\ArcadeImage.js"},{"name":"./ArcadeSprite","loc":{"line":8,"column":27},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\Factory.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\ArcadeSprite.js"},{"name":"../../utils/Class","loc":{"line":9,"column":20},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\Factory.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\Class.js"},{"name":"./const","loc":{"line":10,"column":20},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\Factory.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\const.js"},{"name":"./PhysicsGroup","loc":{"line":11,"column":27},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\Factory.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\PhysicsGroup.js"},{"name":"./StaticPhysicsGroup","loc":{"line":12,"column":33},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\Factory.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\StaticPhysicsGroup.js"}],"generated":{"js":"/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar ArcadeImage = require('./ArcadeImage');\nvar ArcadeSprite = require('./ArcadeSprite');\nvar Class = require('../../utils/Class');\nvar CONST = require('./const');\nvar PhysicsGroup = require('./PhysicsGroup');\nvar StaticPhysicsGroup = require('./StaticPhysicsGroup');\n\n/**\n * @classdesc\n * The Arcade Physics Factory allows you to easily create Arcade Physics enabled Game Objects.\n * Objects that are created by this Factory are automatically added to the physics world.\n *\n * @class Factory\n * @memberof Phaser.Physics.Arcade\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.Physics.Arcade.World} world - The Arcade Physics World instance.\n */\nvar Factory = new Class({\n\n    initialize:\n\n    function Factory (world)\n    {\n        /**\n         * A reference to the Arcade Physics World.\n         *\n         * @name Phaser.Physics.Arcade.Factory#world\n         * @type {Phaser.Physics.Arcade.World}\n         * @since 3.0.0\n         */\n        this.world = world;\n\n        /**\n         * A reference to the Scene this Arcade Physics instance belongs to.\n         *\n         * @name Phaser.Physics.Arcade.Factory#scene\n         * @type {Phaser.Scene}\n         * @since 3.0.0\n         */\n        this.scene = world.scene;\n\n        /**\n         * A reference to the Scene.Systems this Arcade Physics instance belongs to.\n         *\n         * @name Phaser.Physics.Arcade.Factory#sys\n         * @type {Phaser.Scenes.Systems}\n         * @since 3.0.0\n         */\n        this.sys = world.scene.sys;\n    },\n\n    /**\n     * Creates a new Arcade Physics Collider object.\n     *\n     * @method Phaser.Physics.Arcade.Factory#collider\n     * @since 3.0.0\n     *\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object1 - The first object to check for collision.\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object2 - The second object to check for collision.\n     * @param {ArcadePhysicsCallback} [collideCallback] - The callback to invoke when the two objects collide.\n     * @param {ArcadePhysicsCallback} [processCallback] - The callback to invoke when the two objects collide. Must return a boolean.\n     * @param {*} [callbackContext] - The scope in which to call the callbacks.\n     *\n     * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.\n     */\n    collider: function (object1, object2, collideCallback, processCallback, callbackContext)\n    {\n        return this.world.addCollider(object1, object2, collideCallback, processCallback, callbackContext);\n    },\n\n    /**\n     * Creates a new Arcade Physics Collider Overlap object.\n     *\n     * @method Phaser.Physics.Arcade.Factory#overlap\n     * @since 3.0.0\n     *\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object1 - The first object to check for overlap.\n     * @param {(Phaser.GameObjects.GameObject|Phaser.GameObjects.GameObject[]|Phaser.GameObjects.Group|Phaser.GameObjects.Group[])} object2 - The second object to check for overlap.\n     * @param {ArcadePhysicsCallback} [collideCallback] - The callback to invoke when the two objects collide.\n     * @param {ArcadePhysicsCallback} [processCallback] - The callback to invoke when the two objects collide. Must return a boolean.\n     * @param {*} [callbackContext] - The scope in which to call the callbacks.\n     *\n     * @return {Phaser.Physics.Arcade.Collider} The Collider that was created.\n     */\n    overlap: function (object1, object2, collideCallback, processCallback, callbackContext)\n    {\n        return this.world.addOverlap(object1, object2, collideCallback, processCallback, callbackContext);\n    },\n\n    /**\n     * Adds an Arcade Physics Body to the given Game Object.\n     *\n     * @method Phaser.Physics.Arcade.Factory#existing\n     * @since 3.0.0\n     *\n     * @param {Phaser.GameObjects.GameObject} gameObject - A Game Object.\n     * @param {boolean} [isStatic=false] - Create a Static body (true) or Dynamic body (false).\n     *\n     * @return {Phaser.GameObjects.GameObject} The Game Object.\n     */\n    existing: function (gameObject, isStatic)\n    {\n        var type = (isStatic) ? CONST.STATIC_BODY : CONST.DYNAMIC_BODY;\n\n        this.world.enableBody(gameObject, type);\n\n        return gameObject;\n    },\n\n    /**\n     * Creates a new Arcade Image object with a Static body.\n     *\n     * @method Phaser.Physics.Arcade.Factory#staticImage\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal position of this Game Object in the world.\n     * @param {number} y - The vertical position of this Game Object in the world.\n     * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n     * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n     *\n     * @return {Phaser.Physics.Arcade.Image} The Image object that was created.\n     */\n    staticImage: function (x, y, key, frame)\n    {\n        var image = new ArcadeImage(this.scene, x, y, key, frame);\n\n        this.sys.displayList.add(image);\n\n        this.world.enableBody(image, CONST.STATIC_BODY);\n\n        return image;\n    },\n\n    /**\n     * Creates a new Arcade Image object with a Dynamic body.\n     *\n     * @method Phaser.Physics.Arcade.Factory#image\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal position of this Game Object in the world.\n     * @param {number} y - The vertical position of this Game Object in the world.\n     * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n     * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n     *\n     * @return {Phaser.Physics.Arcade.Image} The Image object that was created.\n     */\n    image: function (x, y, key, frame)\n    {\n        var image = new ArcadeImage(this.scene, x, y, key, frame);\n\n        this.sys.displayList.add(image);\n\n        this.world.enableBody(image, CONST.DYNAMIC_BODY);\n\n        return image;\n    },\n\n    /**\n     * Creates a new Arcade Sprite object with a Static body.\n     *\n     * @method Phaser.Physics.Arcade.Factory#staticSprite\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal position of this Game Object in the world.\n     * @param {number} y - The vertical position of this Game Object in the world.\n     * @param {string} texture - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n     * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n     *\n     * @return {Phaser.Physics.Arcade.Sprite} The Sprite object that was created.\n     */\n    staticSprite: function (x, y, key, frame)\n    {\n        var sprite = new ArcadeSprite(this.scene, x, y, key, frame);\n\n        this.sys.displayList.add(sprite);\n        this.sys.updateList.add(sprite);\n\n        this.world.enableBody(sprite, CONST.STATIC_BODY);\n\n        return sprite;\n    },\n\n    /**\n     * Creates a new Arcade Sprite object with a Dynamic body.\n     *\n     * @method Phaser.Physics.Arcade.Factory#sprite\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal position of this Game Object in the world.\n     * @param {number} y - The vertical position of this Game Object in the world.\n     * @param {string} key - The key of the Texture this Game Object will use to render with, as stored in the Texture Manager.\n     * @param {(string|integer)} [frame] - An optional frame from the Texture this Game Object is rendering with.\n     *\n     * @return {Phaser.Physics.Arcade.Sprite} The Sprite object that was created.\n     */\n    sprite: function (x, y, key, frame)\n    {\n        var sprite = new ArcadeSprite(this.scene, x, y, key, frame);\n\n        this.sys.displayList.add(sprite);\n        this.sys.updateList.add(sprite);\n\n        this.world.enableBody(sprite, CONST.DYNAMIC_BODY);\n\n        return sprite;\n    },\n\n    /**\n     * Creates a Static Physics Group object.\n     * All Game Objects created by this Group will automatically be static Arcade Physics objects.\n     *\n     * @method Phaser.Physics.Arcade.Factory#staticGroup\n     * @since 3.0.0\n     *\n     * @param {(Phaser.GameObjects.GameObject[]|Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig)} [children] - Game Objects to add to this group; or the `config` argument.\n     * @param {Phaser.Types.GameObjects.Group.GroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig} [config] - Settings for this group.\n     *\n     * @return {Phaser.Physics.Arcade.StaticGroup} The Static Group object that was created.\n     */\n    staticGroup: function (children, config)\n    {\n        return this.sys.updateList.add(new StaticPhysicsGroup(this.world, this.world.scene, children, config));\n    },\n\n    /**\n     * Creates a Physics Group object.\n     * All Game Objects created by this Group will automatically be dynamic Arcade Physics objects.\n     *\n     * @method Phaser.Physics.Arcade.Factory#group\n     * @since 3.0.0\n     *\n     * @param {(Phaser.GameObjects.GameObject[]|Phaser.Types.Physics.Arcade.PhysicsGroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig)} [children] - Game Objects to add to this group; or the `config` argument.\n     * @param {Phaser.Types.Physics.Arcade.PhysicsGroupConfig|Phaser.Types.GameObjects.Group.GroupCreateConfig} [config] - Settings for this group.\n     *\n     * @return {Phaser.Physics.Arcade.Group} The Group object that was created.\n     */\n    group: function (children, config)\n    {\n        return this.sys.updateList.add(new PhysicsGroup(this.world, this.world.scene, children, config));\n    },\n\n    /**\n     * Destroys this Factory.\n     *\n     * @method Phaser.Physics.Arcade.Factory#destroy\n     * @since 3.5.0\n     */\n    destroy: function ()\n    {\n        this.world = null;\n        this.scene = null;\n        this.sys = null;\n    }\n\n});\n\nmodule.exports = Factory;\n"},"sourceMaps":null,"error":null,"hash":"0a1c3eb62de85d9230d10e8063193163","cacheData":{"env":{}}}