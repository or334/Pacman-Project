{"id":"../../node_modules/phaser/src/scale/ScaleManager.js","dependencies":[{"name":"C:\\Users\\Admin\\Desktop\\pmm\\package.json","includedInParent":true,"mtime":1560952935180},{"name":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\package.json","includedInParent":true,"mtime":1561134727120},{"name":"./const","loc":{"line":7,"column":20},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\scale\\ScaleManager.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\scale\\const\\index.js"},{"name":"../utils/Class","loc":{"line":8,"column":20},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\scale\\ScaleManager.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\Class.js"},{"name":"eventemitter3","loc":{"line":9,"column":27},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\scale\\ScaleManager.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\eventemitter3\\index.js"},{"name":"./events","loc":{"line":10,"column":21},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\scale\\ScaleManager.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\scale\\events\\index.js"},{"name":"../core/events","loc":{"line":11,"column":25},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\scale\\ScaleManager.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\core\\events\\index.js"},{"name":"../dom/GetInnerHeight","loc":{"line":12,"column":29},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\scale\\ScaleManager.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\dom\\GetInnerHeight.js"},{"name":"../dom/GetTarget","loc":{"line":13,"column":24},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\scale\\ScaleManager.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\dom\\GetTarget.js"},{"name":"../dom/GetScreenOrientation","loc":{"line":14,"column":35},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\scale\\ScaleManager.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\dom\\GetScreenOrientation.js"},{"name":"../utils/NOOP","loc":{"line":15,"column":19},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\scale\\ScaleManager.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\NOOP.js"},{"name":"../geom/rectangle/Rectangle","loc":{"line":16,"column":24},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\scale\\ScaleManager.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\geom\\rectangle\\Rectangle.js"},{"name":"../structs/Size","loc":{"line":17,"column":19},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\scale\\ScaleManager.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\structs\\Size.js"},{"name":"../math/snap/SnapFloor","loc":{"line":18,"column":24},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\scale\\ScaleManager.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\math\\snap\\SnapFloor.js"},{"name":"../math/Vector2","loc":{"line":19,"column":22},"parent":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\scale\\ScaleManager.js","resolved":"C:\\Users\\Admin\\Desktop\\pmm\\node_modules\\phaser\\src\\math\\Vector2.js"}],"generated":{"js":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CONST = require('./const');\r\nvar Class = require('../utils/Class');\r\nvar EventEmitter = require('eventemitter3');\r\nvar Events = require('./events');\r\nvar GameEvents = require('../core/events');\r\nvar GetInnerHeight = require('../dom/GetInnerHeight');\r\nvar GetTarget = require('../dom/GetTarget');\r\nvar GetScreenOrientation = require('../dom/GetScreenOrientation');\r\nvar NOOP = require('../utils/NOOP');\r\nvar Rectangle = require('../geom/rectangle/Rectangle');\r\nvar Size = require('../structs/Size');\r\nvar SnapFloor = require('../math/snap/SnapFloor');\r\nvar Vector2 = require('../math/Vector2');\r\n\r\n/**\r\n * @classdesc\r\n * The Scale Manager handles the scaling, resizing and alignment of the game canvas.\r\n * \r\n * The way scaling is handled is by setting the game canvas to a fixed size, which is defined in the\r\n * game configuration. You also define the parent container in the game config. If no parent is given,\r\n * it will default to using the document body. The Scale Manager will then look at the available space\r\n * within the _parent_ and scale the canvas accordingly. Scaling is handled by setting the canvas CSS\r\n * width and height properties, leaving the width and height of the canvas element itself untouched.\r\n * Scaling is therefore achieved by keeping the core canvas the same size and 'stretching'\r\n * it via its CSS properties. This gives the same result and speed as using the `transform-scale` CSS\r\n * property, without the need for browser prefix handling.\r\n * \r\n * The calculations for the scale are heavily influenced by the bounding parent size, which is the computed\r\n * dimensions of the canvas's parent. The CSS rules of the parent element play an important role in the\r\n * operation of the Scale Manager. For example, if the parent has no defined width or height, then actions\r\n * like auto-centering will fail to achieve the required result. The Scale Manager works in tandem with the\r\n * CSS you set-up on the page hosting your game, rather than taking control of it.\r\n * \r\n * #### Parent and Display canvas containment guidelines:\r\n *\r\n * - Style the Parent element (of the game canvas) to control the Parent size and thus the games size and layout.\r\n *\r\n * - The Parent element's CSS styles should _effectively_ apply maximum (and minimum) bounding behavior.\r\n *\r\n * - The Parent element should _not_ apply a padding as this is not accounted for.\r\n *   If a padding is required apply it to the Parent's parent or apply a margin to the Parent.\r\n *   If you need to add a border, margin or any other CSS around your game container, then use a parent element and\r\n *   apply the CSS to this instead, otherwise you'll be constantly resizing the shape of the game container.\r\n *\r\n * - The Display canvas layout CSS styles (i.e. margins, size) should not be altered / specified as\r\n *   they may be updated by the Scale Manager.\r\n *\r\n * #### Scale Modes\r\n * \r\n * The way the scaling is handled is determined by the `scaleMode` property. The default is `NO_SCALE`,\r\n * which prevents Phaser from scaling or touching the canvas, or its parent, at all. In this mode, you are\r\n * responsible for all scaling. The other scaling modes afford you automatic scaling.\r\n * \r\n * If you wish to scale your game so that it always fits into the available space within the parent, you\r\n * should use the scale mode `FIT`. Look at the documentation for other scale modes to see what options are\r\n * available. Here is a basic config showing how to set this scale mode:\r\n * \r\n * ```javascript\r\n * scale: {\r\n *     parent: 'yourgamediv',\r\n *     mode: Phaser.Scale.FIT,\r\n *     width: 800,\r\n *     height: 600\r\n * }\r\n * ```\r\n * \r\n * Place the `scale` config object within your game config.\r\n * \r\n * If you wish for the canvas to be resized directly, so that the canvas itself fills the available space\r\n * (i.e. it isn't scaled, it's resized) then use the `RESIZE` scale mode. This will give you a 1:1 mapping\r\n * of canvas pixels to game size. In this mode CSS isn't used to scale the canvas, it's literally adjusted\r\n * to fill all available space within the parent. You should be extremely careful about the size of the\r\n * canvas you're creating when doing this, as the larger the area, the more work the GPU has to do and it's\r\n * very easy to hit fill-rate limits quickly.\r\n * \r\n * For complex, custom-scaling requirements, you should probably consider using the `RESIZE` scale mode,\r\n * with your own limitations in place re: canvas dimensions and managing the scaling with the game scenes\r\n * yourself. For the vast majority of games, however, the `FIT` mode is likely to be the most used.\r\n * \r\n * Please appreciate that the Scale Manager cannot perform miracles. All it does is scale your game canvas\r\n * as best it can, based on what it can infer from its surrounding area. There are all kinds of environments\r\n * where it's up to you to guide and help the canvas position itself, especially when built into rendering\r\n * frameworks like React and Vue. If your page requires meta tags to prevent user scaling gestures, or such\r\n * like, then it's up to you to ensure they are present in the html.\r\n * \r\n * #### Centering\r\n * \r\n * You can also have the game canvas automatically centered. Again, this relies heavily on the parent being\r\n * properly configured and styled, as the centering offsets are based entirely on the available space\r\n * within the parent element. Centering is disabled by default, or can be applied horizontally, vertically,\r\n * or both. Here's an example:\r\n * \r\n * ```javascript\r\n * scale: {\r\n *     parent: 'yourgamediv',\r\n *     autoCenter: Phaser.Scale.CENTER_BOTH,\r\n *     width: 800,\r\n *     height: 600\r\n * }\r\n * ```\r\n * \r\n * #### Fullscreen API\r\n * \r\n * If the browser supports it, you can send your game into fullscreen mode. In this mode, the game will fill\r\n * the entire display, removing all browser UI and anything else present on the screen. It will remain in this\r\n * mode until your game either disables it, or until the user tabs out or presses ESCape if on desktop. It's a\r\n * great way to achieve a desktop-game like experience from the browser, but it does require a modern browser\r\n * to handle it. Some mobile browsers also support this.\r\n *\r\n * @class ScaleManager\r\n * @memberof Phaser.Scale\r\n * @extends Phaser.Events.EventEmitter\r\n * @constructor\r\n * @since 3.16.0\r\n *\r\n * @param {Phaser.Game} game - A reference to the Phaser.Game instance.\r\n */\r\nvar ScaleManager = new Class({\r\n\r\n    Extends: EventEmitter,\r\n\r\n    initialize:\r\n\r\n    function ScaleManager (game)\r\n    {\r\n        EventEmitter.call(this);\r\n\r\n        /**\r\n         * A reference to the Phaser.Game instance.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#game\r\n         * @type {Phaser.Game}\r\n         * @readonly\r\n         * @since 3.15.0\r\n         */\r\n        this.game = game;\r\n\r\n        /**\r\n         * A reference to the HTML Canvas Element that Phaser uses to render the game.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#canvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.16.0\r\n         */\r\n        this.canvas;\r\n\r\n        /**\r\n         * The DOM bounds of the canvas element.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#canvasBounds\r\n         * @type {Phaser.Geom.Rectangle}\r\n         * @since 3.16.0\r\n         */\r\n        this.canvasBounds = new Rectangle();\r\n\r\n        /**\r\n         * The parent object of the Canvas. Often a div, or the browser window, or nothing in non-browser environments.\r\n         * \r\n         * This is set in the Game Config as the `parent` property. If undefined (or just not present), it will default\r\n         * to use the document body. If specifically set to `null` Phaser will ignore all parent operations.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#parent\r\n         * @type {?any}\r\n         * @since 3.16.0\r\n         */\r\n        this.parent = null;\r\n\r\n        /**\r\n         * Is the parent element the browser window?\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#parentIsWindow\r\n         * @type {boolean}\r\n         * @since 3.16.0\r\n         */\r\n        this.parentIsWindow = false;\r\n\r\n        /**\r\n         * The Parent Size component.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#parentSize\r\n         * @type {Phaser.Structs.Size}\r\n         * @since 3.16.0\r\n         */\r\n        this.parentSize = new Size();\r\n\r\n        /**\r\n         * The Game Size component.\r\n         * \r\n         * The un-modified game size, as requested in the game config (the raw width / height),\r\n         * as used for world bounds, cameras, etc\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#gameSize\r\n         * @type {Phaser.Structs.Size}\r\n         * @since 3.16.0\r\n         */\r\n        this.gameSize = new Size();\r\n\r\n        /**\r\n         * The Base Size component.\r\n         * \r\n         * The modified game size, which is the gameSize * resolution, used to set the canvas width and height\r\n         * (but not the CSS style)\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#baseSize\r\n         * @type {Phaser.Structs.Size}\r\n         * @since 3.16.0\r\n         */\r\n        this.baseSize = new Size();\r\n\r\n        /**\r\n         * The Display Size component.\r\n         * \r\n         * The size used for the canvas style, factoring in the scale mode, parent and other values.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#displaySize\r\n         * @type {Phaser.Structs.Size}\r\n         * @since 3.16.0\r\n         */\r\n        this.displaySize = new Size();\r\n\r\n        /**\r\n         * The game scale mode.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#scaleMode\r\n         * @type {Phaser.Scale.ScaleModeType}\r\n         * @since 3.16.0\r\n         */\r\n        this.scaleMode = CONST.SCALE_MODE.NONE;\r\n\r\n        /**\r\n         * The canvas resolution.\r\n         * \r\n         * This is hard-coded to a value of 1 in the 3.16 release of Phaser and will be enabled at a later date.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#resolution\r\n         * @type {number}\r\n         * @since 3.16.0\r\n         */\r\n        this.resolution = 1;\r\n\r\n        /**\r\n         * The game zoom factor.\r\n         * \r\n         * This value allows you to multiply your games base size by the given zoom factor.\r\n         * This is then used when calculating the display size, even in `NO_SCALE` situations.\r\n         * If you don't want Phaser to touch the canvas style at all, this value should be 1.\r\n         * \r\n         * Can also be set to `MAX_ZOOM` in which case the zoom value will be derived based\r\n         * on the game size and available space within the parent.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#zoom\r\n         * @type {number}\r\n         * @since 3.16.0\r\n         */\r\n        this.zoom = 1;\r\n\r\n        /**\r\n         * The scale factor between the baseSize and the canvasBounds.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#displayScale\r\n         * @type {Phaser.Math.Vector2}\r\n         * @since 3.16.0\r\n         */\r\n        this.displayScale = new Vector2(1, 1);\r\n\r\n        /**\r\n         * If set, the canvas sizes will be automatically passed through Math.floor.\r\n         * This results in rounded pixel display values, which is important for performance on legacy\r\n         * and low powered devices, but at the cost of not achieving a 'perfect' fit in some browser windows.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#autoRound\r\n         * @type {boolean}\r\n         * @since 3.16.0\r\n         */\r\n        this.autoRound = false;\r\n\r\n        /**\r\n         * Automatically center the canvas within the parent? The different centering modes are:\r\n         * \r\n         * 1. No centering.\r\n         * 2. Center both horizontally and vertically.\r\n         * 3. Center horizontally.\r\n         * 4. Center vertically.\r\n         * \r\n         * Please be aware that in order to center the game canvas, you must have specified a parent\r\n         * that has a size set, or the canvas parent is the document.body.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#autoCenter\r\n         * @type {Phaser.Scale.CenterType}\r\n         * @since 3.16.0\r\n         */\r\n        this.autoCenter = CONST.CENTER.NO_CENTER;\r\n\r\n        /**\r\n         * The current device orientation.\r\n         * \r\n         * Orientation events are dispatched via the Device Orientation API, typically only on mobile browsers.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#orientation\r\n         * @type {Phaser.Scale.OrientationType}\r\n         * @since 3.16.0\r\n         */\r\n        this.orientation = CONST.ORIENTATION.LANDSCAPE;\r\n\r\n        /**\r\n         * A reference to the Device.Fullscreen object.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#fullscreen\r\n         * @type {Phaser.Device.Fullscreen}\r\n         * @since 3.16.0\r\n         */\r\n        this.fullscreen;\r\n\r\n        /**\r\n         * The DOM Element which is sent into fullscreen mode.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#fullscreenTarget\r\n         * @type {?any}\r\n         * @since 3.16.0\r\n         */\r\n        this.fullscreenTarget = null;\r\n\r\n        /**\r\n         * Did Phaser create the fullscreen target div, or was it provided in the game config?\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#_createdFullscreenTarget\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.16.0\r\n         */\r\n        this._createdFullscreenTarget = false;\r\n\r\n        /**\r\n         * Internal var that keeps track of the user, or the browser, requesting fullscreen changes.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#_requestedFullscreenChange\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.16.2\r\n         */\r\n        this._requestedFullscreenChange = false;\r\n\r\n        /**\r\n         * The dirty state of the Scale Manager.\r\n         * Set if there is a change between the parent size and the current size.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#dirty\r\n         * @type {boolean}\r\n         * @since 3.16.0\r\n         */\r\n        this.dirty = false;\r\n\r\n        /**\r\n         * How many milliseconds should elapse before checking if the browser size has changed?\r\n         * \r\n         * Most modern browsers dispatch a 'resize' event, which the Scale Manager will listen for.\r\n         * However, older browsers fail to do this, or do it consistently, so we fall back to a\r\n         * more traditional 'size check' based on a time interval. You can control how often it is\r\n         * checked here.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#resizeInterval\r\n         * @type {integer}\r\n         * @since 3.16.0\r\n         */\r\n        this.resizeInterval = 500;\r\n\r\n        /**\r\n         * Internal size interval tracker.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#_lastCheck\r\n         * @type {integer}\r\n         * @private\r\n         * @since 3.16.0\r\n         */\r\n        this._lastCheck = 0;\r\n\r\n        /**\r\n         * Internal flag to check orientation state.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#_checkOrientation\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.16.0\r\n         */\r\n        this._checkOrientation = false;\r\n\r\n        /**\r\n         * Internal object containing our defined event listeners.\r\n         *\r\n         * @name Phaser.Scale.ScaleManager#listeners\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.16.0\r\n         */\r\n        this.listeners = {\r\n\r\n            orientationChange: NOOP,\r\n            windowResize: NOOP,\r\n            fullScreenChange: NOOP,\r\n            fullScreenError: NOOP\r\n\r\n        };\r\n    },\r\n\r\n    /**\r\n     * Called _before_ the canvas object is created and added to the DOM.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#preBoot\r\n     * @protected\r\n     * @listens Phaser.Core.Events#BOOT\r\n     * @since 3.16.0\r\n     */\r\n    preBoot: function ()\r\n    {\r\n        //  Parse the config to get the scaling values we need\r\n        this.parseConfig(this.game.config);\r\n\r\n        this.game.events.once('boot', this.boot, this);\r\n    },\r\n\r\n    /**\r\n     * The Boot handler is called by Phaser.Game when it first starts up.\r\n     * The renderer is available by now and the canvas has been added to the DOM.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#boot\r\n     * @protected\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     */\r\n    boot: function ()\r\n    {\r\n        var game = this.game;\r\n\r\n        this.canvas = game.canvas;\r\n\r\n        this.fullscreen = game.device.fullscreen;\r\n\r\n        if (this.scaleMode !== CONST.SCALE_MODE.RESIZE)\r\n        {\r\n            this.displaySize.setAspectMode(this.scaleMode);\r\n        }\r\n\r\n        if (this.scaleMode === CONST.SCALE_MODE.NONE)\r\n        {\r\n            this.resize(this.width, this.height);\r\n        }\r\n        else\r\n        {\r\n            this.getParentBounds();\r\n\r\n            //  Only set the parent bounds if the parent has an actual size\r\n            if (this.parentSize.width > 0 && this.parentSize.height > 0)\r\n            {\r\n                this.displaySize.setParent(this.parentSize);\r\n            }\r\n\r\n            this.refresh();\r\n        }\r\n\r\n        game.events.on(GameEvents.PRE_STEP, this.step, this);\r\n\r\n        this.startListeners();\r\n    },\r\n\r\n    /**\r\n     * Parses the game configuration to set-up the scale defaults.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#parseConfig\r\n     * @protected\r\n     * @since 3.16.0\r\n     * \r\n     * @param {Phaser.Types.Core.GameConfig} config - The Game configuration object.\r\n     */\r\n    parseConfig: function (config)\r\n    {\r\n        //  Get the parent element, if any\r\n        this.getParent(config);\r\n        \r\n        //  Get the size of the parent element\r\n        //  This can often set a height of zero (especially for un-styled divs)\r\n        this.getParentBounds();\r\n\r\n        var width = config.width;\r\n        var height = config.height;\r\n        var scaleMode = config.scaleMode;\r\n        var resolution = config.resolution;\r\n        var zoom = config.zoom;\r\n        var autoRound = config.autoRound;\r\n\r\n        //  If width = '100%', or similar value\r\n        if (typeof width === 'string')\r\n        {\r\n            //  If we have a parent with a height, we'll work it out from that\r\n            var parentWidth = this.parentSize.width;\r\n\r\n            if (parentWidth === 0)\r\n            {\r\n                parentWidth = window.innerWidth;\r\n            }\r\n\r\n            var parentScaleX = parseInt(width, 10) / 100;\r\n\r\n            width = Math.floor(parentWidth * parentScaleX);\r\n        }\r\n\r\n        //  If height = '100%', or similar value\r\n        if (typeof height === 'string')\r\n        {\r\n            //  If we have a parent with a height, we'll work it out from that\r\n            var parentHeight = this.parentSize.height;\r\n\r\n            if (parentHeight === 0)\r\n            {\r\n                parentHeight = window.innerHeight;\r\n            }\r\n\r\n            var parentScaleY = parseInt(height, 10) / 100;\r\n\r\n            height = Math.floor(parentHeight * parentScaleY);\r\n        }\r\n\r\n        //  This is fixed at 1 on purpose.\r\n        //  Changing it will break all user input.\r\n        //  Wait for another release to solve this issue.\r\n        this.resolution = 1;\r\n\r\n        this.scaleMode = scaleMode;\r\n\r\n        this.autoRound = autoRound;\r\n\r\n        this.autoCenter = config.autoCenter;\r\n\r\n        this.resizeInterval = config.resizeInterval;\r\n\r\n        if (autoRound)\r\n        {\r\n            width = Math.floor(width);\r\n            height = Math.floor(height);\r\n        }\r\n\r\n        //  The un-modified game size, as requested in the game config (the raw width / height) as used for world bounds, etc\r\n        this.gameSize.setSize(width, height);\r\n\r\n        if (zoom === CONST.ZOOM.MAX_ZOOM)\r\n        {\r\n            zoom = this.getMaxZoom();\r\n        }\r\n\r\n        this.zoom = zoom;\r\n\r\n        //  The modified game size, which is the w/h * resolution\r\n        this.baseSize.setSize(width * resolution, height * resolution);\r\n\r\n        if (autoRound)\r\n        {\r\n            this.baseSize.width = Math.floor(this.baseSize.width);\r\n            this.baseSize.height = Math.floor(this.baseSize.height);\r\n        }\r\n\r\n        if (config.minWidth > 0)\r\n        {\r\n            this.displaySize.setMin(config.minWidth * zoom, config.minHeight * zoom);\r\n        }\r\n\r\n        if (config.maxWidth > 0)\r\n        {\r\n            this.displaySize.setMax(config.maxWidth * zoom, config.maxHeight * zoom);\r\n        }\r\n\r\n        //  The size used for the canvas style, factoring in the scale mode and parent and zoom value\r\n        //  We just use the w/h here as this is what sets the aspect ratio (which doesn't then change)\r\n        this.displaySize.setSize(width, height);\r\n\r\n        this.orientation = GetScreenOrientation(width, height);\r\n    },\r\n\r\n    /**\r\n     * Determines the parent element of the game canvas, if any, based on the game configuration.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#getParent\r\n     * @since 3.16.0\r\n     * \r\n     * @param {Phaser.Types.Core.GameConfig} config - The Game configuration object.\r\n     */\r\n    getParent: function (config)\r\n    {\r\n        var parent = config.parent;\r\n\r\n        if (parent === null)\r\n        {\r\n            //  User is responsible for managing the parent\r\n            return;\r\n        }\r\n\r\n        this.parent = GetTarget(parent);\r\n        this.parentIsWindow = (this.parent === document.body);\r\n\r\n        if (config.expandParent && config.scaleMode !== CONST.SCALE_MODE.NONE)\r\n        {\r\n            var DOMRect = this.parent.getBoundingClientRect();\r\n\r\n            if (this.parentIsWindow || DOMRect.height === 0)\r\n            {\r\n                document.documentElement.style.height = '100%';\r\n                document.body.style.height = '100%';\r\n\r\n                DOMRect = this.parent.getBoundingClientRect();\r\n\r\n                //  The parent STILL has no height, clearly no CSS\r\n                //  has been set on it even though we fixed the body :(\r\n                if (!this.parentIsWindow && DOMRect.height === 0)\r\n                {\r\n                    this.parent.style.overflow = 'hidden';\r\n                    this.parent.style.width = '100%';\r\n                    this.parent.style.height = '100%';\r\n                }\r\n            }\r\n        }\r\n\r\n        //  And now get the fullscreenTarget\r\n        if (config.fullscreenTarget && !this.fullscreenTarget)\r\n        {\r\n            this.fullscreenTarget = GetTarget(config.fullscreenTarget);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Calculates the size of the parent bounds and updates the `parentSize` component, if the canvas has a dom parent.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#getParentBounds\r\n     * @since 3.16.0\r\n     * \r\n     * @return {boolean} `true` if the parent bounds have changed size, otherwise `false`.\r\n     */\r\n    getParentBounds: function ()\r\n    {\r\n        if (!this.parent)\r\n        {\r\n            return false;\r\n        }\r\n\r\n        var parentSize = this.parentSize;\r\n\r\n        // Ref. http://msdn.microsoft.com/en-us/library/hh781509(v=vs.85).aspx for getBoundingClientRect\r\n\r\n        var DOMRect = this.parent.getBoundingClientRect();\r\n\r\n        if (this.parentIsWindow && this.game.device.os.iOS)\r\n        {\r\n            DOMRect.height = GetInnerHeight(true);\r\n        }\r\n\r\n        var resolution = this.resolution;\r\n        var newWidth = DOMRect.width * resolution;\r\n        var newHeight = DOMRect.height * resolution;\r\n\r\n        if (parentSize.width !== newWidth || parentSize.height !== newHeight)\r\n        {\r\n            parentSize.setSize(newWidth, newHeight);\r\n\r\n            return true;\r\n        }\r\n        else\r\n        {\r\n            return false;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Attempts to lock the orientation of the web browser using the Screen Orientation API.\r\n     * \r\n     * This API is only available on modern mobile browsers.\r\n     * See https://developer.mozilla.org/en-US/docs/Web/API/Screen/lockOrientation for details.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#lockOrientation\r\n     * @since 3.16.0\r\n     * \r\n     * @param {string} orientation - The orientation you'd like to lock the browser in. Should be an API string such as 'landscape', 'landscape-primary', 'portrait', etc.\r\n     * \r\n     * @return {boolean} `true` if the orientation was successfully locked, otherwise `false`.\r\n     */\r\n    lockOrientation: function (orientation)\r\n    {\r\n        var lock = screen.lockOrientation || screen.mozLockOrientation || screen.msLockOrientation;\r\n\r\n        if (lock)\r\n        {\r\n            return lock(orientation);\r\n        }\r\n\r\n        return false;\r\n    },\r\n\r\n    /**\r\n     * This method will set the size of the Parent Size component, which is used in scaling\r\n     * and centering calculations. You only need to call this method if you have explicitly\r\n     * disabled the use of a parent in your game config, but still wish to take advantage of\r\n     * other Scale Manager features.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#setParentSize\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     * \r\n     * @param {number} width - The new width of the parent.\r\n     * @param {number} height - The new height of the parent.\r\n     * \r\n     * @return {this} The Scale Manager instance.\r\n     */\r\n    setParentSize: function (width, height)\r\n    {\r\n        this.parentSize.setSize(width, height);\r\n\r\n        return this.refresh();\r\n    },\r\n\r\n    /**\r\n     * This method will set a new size for your game.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#setGameSize\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     * \r\n     * @param {number} width - The new width of the game.\r\n     * @param {number} height - The new height of the game.\r\n     * \r\n     * @return {this} The Scale Manager instance.\r\n     */\r\n    setGameSize: function (width, height)\r\n    {\r\n        var autoRound = this.autoRound;\r\n        var resolution = this.resolution;\r\n\r\n        if (autoRound)\r\n        {\r\n            width = Math.floor(width);\r\n            height = Math.floor(height);\r\n        }\r\n\r\n        this.gameSize.resize(width, height);\r\n        this.baseSize.resize(width * resolution, height * resolution);\r\n\r\n        this.updateBounds();\r\n\r\n        this.displayScale.set(width / this.canvasBounds.width, height / this.canvasBounds.height);\r\n\r\n        this.emit(Events.RESIZE, this.gameSize, this.baseSize, this.displaySize, this.resolution);\r\n\r\n        this.updateOrientation();\r\n\r\n        return this.refresh();\r\n    },\r\n\r\n    /**\r\n     * Call this to modify the size of the Phaser canvas element directly.\r\n     * You should only use this if you are using the `NO_SCALE` scale mode,\r\n     * it will update all internal components completely.\r\n     * \r\n     * If all you want to do is change the size of the parent, see the `setParentSize` method.\r\n     * \r\n     * If all you want is to change the base size of the game, but still have the Scale Manager\r\n     * manage all the scaling, then see the `setGameSize` method.\r\n     * \r\n     * This method will set the `gameSize`, `baseSize` and `displaySize` components to the given\r\n     * dimensions. It will then resize the canvas width and height to the values given, by\r\n     * directly setting the properties. Finally, if you have set the Scale Manager zoom value\r\n     * to anything other than 1 (the default), it will set the canvas CSS width and height to\r\n     * be the given size multiplied by the zoom factor (the canvas pixel size remains untouched).\r\n     * \r\n     * If you have enabled `autoCenter`, it is then passed to the `updateCenter` method and\r\n     * the margins are set, allowing the canvas to be centered based on its parent element\r\n     * alone. Finally, the `displayScale` is adjusted and the RESIZE event dispatched.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#resize\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     * \r\n     * @param {number} width - The new width of the game.\r\n     * @param {number} height - The new height of the game.\r\n     * \r\n     * @return {this} The Scale Manager instance.\r\n     */\r\n    resize: function (width, height)\r\n    {\r\n        var zoom = this.zoom;\r\n        var resolution = this.resolution;\r\n        var autoRound = this.autoRound;\r\n\r\n        if (autoRound)\r\n        {\r\n            width = Math.floor(width);\r\n            height = Math.floor(height);\r\n        }\r\n\r\n        this.gameSize.resize(width, height);\r\n\r\n        this.baseSize.resize(width * resolution, height * resolution);\r\n\r\n        this.displaySize.setSize((width * zoom) * resolution, (height * zoom) * resolution);\r\n\r\n        this.canvas.width = this.baseSize.width;\r\n        this.canvas.height = this.baseSize.height;\r\n\r\n        var style = this.canvas.style;\r\n\r\n        var styleWidth = width * zoom;\r\n        var styleHeight = height * zoom;\r\n\r\n        if (autoRound)\r\n        {\r\n            styleWidth = Math.floor(styleWidth);\r\n            styleHeight = Math.floor(styleHeight);\r\n        }\r\n\r\n        if (styleWidth !== width || styleHeight !== height)\r\n        {\r\n            style.width = styleWidth + 'px';\r\n            style.height = styleHeight + 'px';\r\n        }\r\n\r\n        this.getParentBounds();\r\n\r\n        this.updateCenter();\r\n\r\n        this.updateBounds();\r\n\r\n        this.displayScale.set(width / this.canvasBounds.width, height / this.canvasBounds.height);\r\n\r\n        this.emit(Events.RESIZE, this.gameSize, this.baseSize, this.displaySize, this.resolution);\r\n\r\n        this.updateOrientation();\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the zoom value of the Scale Manager.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#setZoom\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     * \r\n     * @param {integer} value - The new zoom value of the game.\r\n     * \r\n     * @return {this} The Scale Manager instance.\r\n     */\r\n    setZoom: function (value)\r\n    {\r\n        this.zoom = value;\r\n\r\n        return this.refresh();\r\n    },\r\n\r\n    /**\r\n     * Sets the zoom to be the maximum possible based on the _current_ parent size.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#setMaxZoom\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     * \r\n     * @return {this} The Scale Manager instance.\r\n     */\r\n    setMaxZoom: function ()\r\n    {\r\n        this.zoom = this.getMaxZoom();\r\n\r\n        return this.refresh();\r\n    },\r\n\r\n    /**\r\n     * Refreshes the internal scale values, bounds sizes and orientation checks.\r\n     * \r\n     * Once finished, dispatches the resize event.\r\n     * \r\n     * This is called automatically by the Scale Manager when the browser window size changes,\r\n     * as long as it is using a Scale Mode other than 'NONE'.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#refresh\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     * \r\n     * @return {this} The Scale Manager instance.\r\n     */\r\n    refresh: function ()\r\n    {\r\n        this.updateScale();\r\n        this.updateBounds();\r\n        this.updateOrientation();\r\n\r\n        this.displayScale.set(this.baseSize.width / this.canvasBounds.width, this.baseSize.height / this.canvasBounds.height);\r\n\r\n        var domContainer = this.game.domContainer;\r\n\r\n        if (domContainer)\r\n        {\r\n            this.baseSize.setCSS(domContainer);\r\n\r\n            var canvasStyle = this.canvas.style;\r\n            var domStyle = domContainer.style;\r\n\r\n            domStyle.transform = 'scale(' + this.displaySize.width / this.baseSize.width + ',' + this.displaySize.height / this.baseSize.height + ')';\r\n\r\n            domStyle.marginLeft = canvasStyle.marginLeft;\r\n            domStyle.marginTop = canvasStyle.marginTop;\r\n        }\r\n\r\n        this.emit(Events.RESIZE, this.gameSize, this.baseSize, this.displaySize, this.resolution);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal method that checks the current screen orientation, only if the internal check flag is set.\r\n     * \r\n     * If the orientation has changed it updates the orientation property and then dispatches the orientation change event.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#updateOrientation\r\n     * @fires Phaser.Scale.Events#ORIENTATION_CHANGE\r\n     * @since 3.16.0\r\n     */\r\n    updateOrientation: function ()\r\n    {\r\n        if (this._checkOrientation)\r\n        {\r\n            this._checkOrientation = false;\r\n\r\n            var newOrientation = GetScreenOrientation(this.width, this.height);\r\n\r\n            if (newOrientation !== this.orientation)\r\n            {\r\n                this.orientation = newOrientation;\r\n    \r\n                this.emit(Events.ORIENTATION_CHANGE, newOrientation);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method that manages updating the size components based on the scale mode.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#updateScale\r\n     * @since 3.16.0\r\n     */\r\n    updateScale: function ()\r\n    {\r\n        var style = this.canvas.style;\r\n\r\n        var width = this.gameSize.width;\r\n        var height = this.gameSize.height;\r\n\r\n        var styleWidth;\r\n        var styleHeight;\r\n\r\n        var zoom = this.zoom;\r\n        var autoRound = this.autoRound;\r\n        var resolution = 1;\r\n\r\n        if (this.scaleMode === CONST.SCALE_MODE.NONE)\r\n        {\r\n            //  No scale\r\n            this.displaySize.setSize((width * zoom) * resolution, (height * zoom) * resolution);\r\n\r\n            styleWidth = this.displaySize.width / resolution;\r\n            styleHeight = this.displaySize.height / resolution;\r\n\r\n            if (autoRound)\r\n            {\r\n                styleWidth = Math.floor(styleWidth);\r\n                styleHeight = Math.floor(styleHeight);\r\n            }\r\n\r\n            if (zoom > 1)\r\n            {\r\n                style.width = styleWidth + 'px';\r\n                style.height = styleHeight + 'px';\r\n            }\r\n        }\r\n        else if (this.scaleMode === CONST.SCALE_MODE.RESIZE)\r\n        {\r\n            //  Resize to match parent\r\n\r\n            //  This will constrain using min/max\r\n            this.displaySize.setSize(this.parentSize.width, this.parentSize.height);\r\n\r\n            this.gameSize.setSize(this.displaySize.width, this.displaySize.height);\r\n\r\n            this.baseSize.setSize(this.displaySize.width * resolution, this.displaySize.height * resolution);\r\n\r\n            styleWidth = this.displaySize.width / resolution;\r\n            styleHeight = this.displaySize.height / resolution;\r\n\r\n            if (autoRound)\r\n            {\r\n                styleWidth = Math.floor(styleWidth);\r\n                styleHeight = Math.floor(styleHeight);\r\n            }\r\n\r\n            this.canvas.width = styleWidth;\r\n            this.canvas.height = styleHeight;\r\n        }\r\n        else\r\n        {\r\n            //  All other scale modes\r\n            this.displaySize.setSize(this.parentSize.width, this.parentSize.height);\r\n\r\n            styleWidth = this.displaySize.width / resolution;\r\n            styleHeight = this.displaySize.height / resolution;\r\n\r\n            if (autoRound)\r\n            {\r\n                styleWidth = Math.floor(styleWidth);\r\n                styleHeight = Math.floor(styleHeight);\r\n            }\r\n\r\n            style.width = styleWidth + 'px';\r\n            style.height = styleHeight + 'px';\r\n        }\r\n\r\n        //  Update the parentSize incase the canvas / style change modified it\r\n        this.getParentBounds();\r\n\r\n        //  Finally, update the centering\r\n        this.updateCenter();\r\n    },\r\n\r\n    /**\r\n     * Calculates and returns the largest possible zoom factor, based on the current\r\n     * parent and game sizes. If the parent has no dimensions (i.e. an unstyled div),\r\n     * or is smaller than the un-zoomed game, then this will return a value of 1 (no zoom)\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#getMaxZoom\r\n     * @since 3.16.0\r\n     * \r\n     * @return {integer} The maximum possible zoom factor. At a minimum this value is always at least 1.\r\n     */\r\n    getMaxZoom: function ()\r\n    {\r\n        var zoomH = SnapFloor(this.parentSize.width, this.gameSize.width, 0, true);\r\n        var zoomV = SnapFloor(this.parentSize.height, this.gameSize.height, 0, true);\r\n    \r\n        return Math.max(Math.min(zoomH, zoomV), 1);\r\n    },\r\n\r\n    /**\r\n     * Calculates and updates the canvas CSS style in order to center it within the\r\n     * bounds of its parent. If you have explicitly set parent to be `null` in your\r\n     * game config then this method will likely give incorrect results unless you have called the\r\n     * `setParentSize` method first.\r\n     * \r\n     * It works by modifying the canvas CSS `marginLeft` and `marginTop` properties.\r\n     * \r\n     * If they have already been set by your own style sheet, or code, this will overwrite them.\r\n     * \r\n     * To prevent the Scale Manager from centering the canvas, either do not set the\r\n     * `autoCenter` property in your game config, or make sure it is set to `NO_CENTER`.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#updateCenter\r\n     * @since 3.16.0\r\n     */\r\n    updateCenter: function ()\r\n    {\r\n        var autoCenter = this.autoCenter;\r\n\r\n        if (autoCenter === CONST.CENTER.NO_CENTER)\r\n        {\r\n            return;\r\n        }\r\n\r\n        var canvas = this.canvas;\r\n\r\n        var style = canvas.style;\r\n\r\n        var bounds = canvas.getBoundingClientRect();\r\n\r\n        // var width = parseInt(canvas.style.width, 10) || canvas.width;\r\n        // var height = parseInt(canvas.style.height, 10) || canvas.height;\r\n\r\n        var width = bounds.width;\r\n        var height = bounds.height;\r\n\r\n        var offsetX = Math.floor((this.parentSize.width - width) / 2);\r\n        var offsetY = Math.floor((this.parentSize.height - height) / 2);\r\n\r\n        if (autoCenter === CONST.CENTER.CENTER_HORIZONTALLY)\r\n        {\r\n            offsetY = 0;\r\n        }\r\n        else if (autoCenter === CONST.CENTER.CENTER_VERTICALLY)\r\n        {\r\n            offsetX = 0;\r\n        }\r\n\r\n        style.marginLeft = offsetX + 'px';\r\n        style.marginTop = offsetY + 'px';\r\n    },\r\n\r\n    /**\r\n     * Updates the `canvasBounds` rectangle to match the bounding client rectangle of the\r\n     * canvas element being used to track input events.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#updateBounds\r\n     * @since 3.16.0\r\n     */\r\n    updateBounds: function ()\r\n    {\r\n        var bounds = this.canvasBounds;\r\n        var clientRect = this.canvas.getBoundingClientRect();\r\n\r\n        bounds.x = clientRect.left + (window.pageXOffset || 0) - (document.documentElement.clientLeft || 0);\r\n        bounds.y = clientRect.top + (window.pageYOffset || 0) - (document.documentElement.clientTop || 0);\r\n        bounds.width = clientRect.width;\r\n        bounds.height = clientRect.height;\r\n    },\r\n\r\n    /**\r\n     * Transforms the pageX value into the scaled coordinate space of the Scale Manager.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#transformX\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} pageX - The DOM pageX value.\r\n     *\r\n     * @return {number} The translated value.\r\n     */\r\n    transformX: function (pageX)\r\n    {\r\n        return (pageX - this.canvasBounds.left) * this.displayScale.x;\r\n    },\r\n\r\n    /**\r\n     * Transforms the pageY value into the scaled coordinate space of the Scale Manager.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#transformY\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} pageY - The DOM pageY value.\r\n     *\r\n     * @return {number} The translated value.\r\n     */\r\n    transformY: function (pageY)\r\n    {\r\n        return (pageY - this.canvasBounds.top) * this.displayScale.y;\r\n    },\r\n\r\n    /**\r\n     * Sends a request to the browser to ask it to go in to full screen mode, using the {@link https://developer.mozilla.org/en-US/docs/Web/API/Fullscreen_API Fullscreen API}.\r\n     * \r\n     * If the browser does not support this, a `FULLSCREEN_UNSUPPORTED` event will be emitted.\r\n     * \r\n     * This method _must_ be called from a user-input gesture, such as `pointerup`. You cannot launch\r\n     * games fullscreen without this, as most browsers block it. Games within an iframe will also be blocked\r\n     * from fullscreen unless the iframe has the `allowfullscreen` attribute.\r\n     * \r\n     * On touch devices, such as Android and iOS Safari, you should always use `pointerup` and NOT `pointerdown`,\r\n     * otherwise the request will fail unless the document in which your game is embedded has already received\r\n     * some form of touch input, which you cannot guarantee. Activating fullscreen via `pointerup` circumvents\r\n     * this issue.\r\n     * \r\n     * Performing an action that navigates to another page, or opens another tab, will automatically cancel\r\n     * fullscreen mode, as will the user pressing the ESC key. To cancel fullscreen mode directly from your game,\r\n     * i.e. by clicking an icon, call the `stopFullscreen` method.\r\n     * \r\n     * A browser can only send one DOM element into fullscreen. You can control which element this is by\r\n     * setting the `fullscreenTarget` property in your game config, or changing the property in the Scale Manager.\r\n     * Note that the game canvas _must_ be a child of the target. If you do not give a target, Phaser will\r\n     * automatically create a blank `<div>` element and move the canvas into it, before going fullscreen.\r\n     * When it leaves fullscreen, the div will be removed.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#startFullscreen\r\n     * @fires Phaser.Scale.Events#ENTER_FULLSCREEN\r\n     * @fires Phaser.Scale.Events#FULLSCREEN_FAILED\r\n     * @fires Phaser.Scale.Events#FULLSCREEN_UNSUPPORTED\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     * \r\n     * @param {object} [fullscreenOptions] - The FullscreenOptions dictionary is used to provide configuration options when entering full screen.\r\n     */\r\n    startFullscreen: function (fullscreenOptions)\r\n    {\r\n        if (fullscreenOptions === undefined) { fullscreenOptions = { navigationUI: 'hide' }; }\r\n\r\n        var fullscreen = this.fullscreen;\r\n\r\n        if (!fullscreen.available)\r\n        {\r\n            this.emit(Events.FULLSCREEN_UNSUPPORTED);\r\n\r\n            return;\r\n        }\r\n\r\n        if (!fullscreen.active)\r\n        {\r\n            var fsTarget = this.getFullscreenTarget();\r\n\r\n            this._requestedFullscreenChange = true;\r\n            \r\n            if (typeof Promise !== 'undefined')\r\n            {\r\n                if (fullscreen.keyboard)\r\n                {\r\n                    //  eslint-disable-next-line es5/no-arrow-functions\r\n                    fsTarget[fullscreen.request](Element.ALLOW_KEYBOARD_INPUT).then(() => this.fullscreenSuccessHandler()).catch((error) => this.fullscreenErrorHandler(error));\r\n                }\r\n                else\r\n                {\r\n                    //  eslint-disable-next-line es5/no-arrow-functions\r\n                    fsTarget[fullscreen.request](fullscreenOptions).then(() => this.fullscreenSuccessHandler()).catch((error) => this.fullscreenErrorHandler(error));\r\n                }\r\n            }\r\n            else\r\n            {\r\n                if (fullscreen.keyboard)\r\n                {\r\n                    fsTarget[fullscreen.request](Element.ALLOW_KEYBOARD_INPUT);\r\n                }\r\n                else\r\n                {\r\n                    fsTarget[fullscreen.request](fullscreenOptions);\r\n                }\r\n\r\n                if (fullscreen.active)\r\n                {\r\n                    this.fullscreenSuccessHandler();\r\n                }\r\n                else\r\n                {\r\n                    this.fullscreenErrorHandler();\r\n                }\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * The browser has successfully entered fullscreen mode.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#fullscreenSuccessHandler\r\n     * @private\r\n     * @fires Phaser.Scale.Events#ENTER_FULLSCREEN\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.17.0\r\n     */\r\n    fullscreenSuccessHandler: function ()\r\n    {\r\n        this.getParentBounds();\r\n\r\n        this.refresh();\r\n\r\n        this.emit(Events.ENTER_FULLSCREEN);\r\n    },\r\n\r\n    /**\r\n     * The browser failed to enter fullscreen mode.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#fullscreenErrorHandler\r\n     * @private\r\n     * @fires Phaser.Scale.Events#FULLSCREEN_FAILED\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.17.0\r\n     * \r\n     * @param {any} error - The DOM error event.\r\n     */\r\n    fullscreenErrorHandler: function (error)\r\n    {\r\n        this.removeFullscreenTarget();\r\n\r\n        this.emit(Events.FULLSCREEN_FAILED, error);\r\n    },\r\n\r\n    /**\r\n     * An internal method that gets the target element that is used when entering fullscreen mode.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#getFullscreenTarget\r\n     * @since 3.16.0\r\n     * \r\n     * @return {object} The fullscreen target element.\r\n     */\r\n    getFullscreenTarget: function ()\r\n    {\r\n        if (!this.fullscreenTarget)\r\n        {\r\n            var fsTarget = document.createElement('div');\r\n\r\n            fsTarget.style.margin = '0';\r\n            fsTarget.style.padding = '0';\r\n            fsTarget.style.width = '100%';\r\n            fsTarget.style.height = '100%';\r\n\r\n            this.fullscreenTarget = fsTarget;\r\n\r\n            this._createdFullscreenTarget = true;\r\n        }\r\n\r\n        if (this._createdFullscreenTarget)\r\n        {\r\n            var canvasParent = this.canvas.parentNode;\r\n\r\n            canvasParent.insertBefore(this.fullscreenTarget, this.canvas);\r\n\r\n            this.fullscreenTarget.appendChild(this.canvas);\r\n        }\r\n\r\n        return this.fullscreenTarget;\r\n    },\r\n\r\n    /**\r\n     * Removes the fullscreen target that was added to the DOM.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#removeFullscreenTarget\r\n     * @since 3.17.0\r\n     */\r\n    removeFullscreenTarget: function ()\r\n    {\r\n        if (this._createdFullscreenTarget)\r\n        {\r\n            var fsTarget = this.fullscreenTarget;\r\n\r\n            if (fsTarget && fsTarget.parentNode)\r\n            {\r\n                var parent = fsTarget.parentNode;\r\n\r\n                parent.insertBefore(this.canvas, fsTarget);\r\n\r\n                parent.removeChild(fsTarget);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Calling this method will cancel fullscreen mode, if the browser has entered it.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#stopFullscreen\r\n     * @fires Phaser.Scale.Events#LEAVE_FULLSCREEN\r\n     * @fires Phaser.Scale.Events#FULLSCREEN_UNSUPPORTED\r\n     * @since 3.16.0\r\n     */\r\n    stopFullscreen: function ()\r\n    {\r\n        var fullscreen = this.fullscreen;\r\n\r\n        if (!fullscreen.available)\r\n        {\r\n            this.emit(Events.FULLSCREEN_UNSUPPORTED);\r\n\r\n            return false;\r\n        }\r\n\r\n        if (fullscreen.active)\r\n        {\r\n            this._requestedFullscreenChange = true;\r\n\r\n            document[fullscreen.cancel]();\r\n        }\r\n\r\n        this.removeFullscreenTarget();\r\n\r\n        //  Get the parent size again as it will have changed\r\n        this.getParentBounds();\r\n\r\n        this.emit(Events.LEAVE_FULLSCREEN);\r\n\r\n        this.refresh();\r\n    },\r\n\r\n    /**\r\n     * Toggles the fullscreen mode. If already in fullscreen, calling this will cancel it.\r\n     * If not in fullscreen, this will request the browser to enter fullscreen mode.\r\n     * \r\n     * If the browser does not support this, a `FULLSCREEN_UNSUPPORTED` event will be emitted.\r\n     * \r\n     * This method _must_ be called from a user-input gesture, such as `pointerdown`. You cannot launch\r\n     * games fullscreen without this, as most browsers block it. Games within an iframe will also be blocked\r\n     * from fullscreen unless the iframe has the `allowfullscreen` attribute.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#toggleFullscreen\r\n     * @fires Phaser.Scale.Events#ENTER_FULLSCREEN\r\n     * @fires Phaser.Scale.Events#LEAVE_FULLSCREEN\r\n     * @fires Phaser.Scale.Events#FULLSCREEN_UNSUPPORTED\r\n     * @fires Phaser.Scale.Events#RESIZE\r\n     * @since 3.16.0\r\n     * \r\n     * @param {object} [fullscreenOptions] - The FullscreenOptions dictionary is used to provide configuration options when entering full screen.\r\n     */\r\n    toggleFullscreen: function (fullscreenOptions)\r\n    {\r\n        if (this.fullscreen.active)\r\n        {\r\n            this.stopFullscreen();\r\n        }\r\n        else\r\n        {\r\n            this.startFullscreen(fullscreenOptions);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * An internal method that starts the different DOM event listeners running.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#startListeners\r\n     * @since 3.16.0\r\n     */\r\n    startListeners: function ()\r\n    {\r\n        var _this = this;\r\n        var listeners = this.listeners;\r\n\r\n        listeners.orientationChange = function ()\r\n        {\r\n            _this._checkOrientation = true;\r\n            _this.dirty = true;\r\n        };\r\n\r\n        listeners.windowResize = function ()\r\n        {\r\n            _this.dirty = true;\r\n        };\r\n\r\n        //  Only dispatched on mobile devices\r\n        window.addEventListener('orientationchange', listeners.orientationChange, false);\r\n\r\n        window.addEventListener('resize', listeners.windowResize, false);\r\n\r\n        if (this.fullscreen.available)\r\n        {\r\n            listeners.fullScreenChange = function (event)\r\n            {\r\n                return _this.onFullScreenChange(event);\r\n            };\r\n\r\n            listeners.fullScreenError = function (event)\r\n            {\r\n                return _this.onFullScreenError(event);\r\n            };\r\n\r\n            var vendors = [ 'webkit', 'moz', '' ];\r\n\r\n            vendors.forEach(function (prefix)\r\n            {\r\n                document.addEventListener(prefix + 'fullscreenchange', listeners.fullScreenChange, false);\r\n                document.addEventListener(prefix + 'fullscreenerror', listeners.fullScreenError, false);\r\n            });\r\n\r\n            //  MS Specific\r\n            document.addEventListener('MSFullscreenChange', listeners.fullScreenChange, false);\r\n            document.addEventListener('MSFullscreenError', listeners.fullScreenError, false);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Triggered when a fullscreenchange event is dispatched by the DOM.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#onFullScreenChange\r\n     * @since 3.16.0\r\n     */\r\n    onFullScreenChange: function ()\r\n    {\r\n        //  They pressed ESC while in fullscreen mode\r\n        if (!this._requestedFullscreenChange)\r\n        {\r\n            this.stopFullscreen();\r\n        }\r\n\r\n        this._requestedFullscreenChange = false;\r\n    },\r\n\r\n    /**\r\n     * Triggered when a fullscreenerror event is dispatched by the DOM.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#onFullScreenError\r\n     * @since 3.16.0\r\n     */\r\n    onFullScreenError: function ()\r\n    {\r\n        this.removeFullscreenTarget();\r\n    },\r\n\r\n    /**\r\n     * Internal method, called automatically by the game step.\r\n     * Monitors the elapsed time and resize interval to see if a parent bounds check needs to take place.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#step\r\n     * @since 3.16.0\r\n     *\r\n     * @param {number} time - The time value from the most recent Game step. Typically a high-resolution timer value, or Date.now().\r\n     * @param {number} delta - The delta value since the last frame. This is smoothed to avoid delta spikes by the TimeStep class.\r\n     */\r\n    step: function (time, delta)\r\n    {\r\n        if (!this.parent)\r\n        {\r\n            return;\r\n        }\r\n\r\n        this._lastCheck += delta;\r\n\r\n        if (this.dirty || this._lastCheck > this.resizeInterval)\r\n        {\r\n            //  Returns true if the parent bounds have changed size\r\n            if (this.getParentBounds())\r\n            {\r\n                this.refresh();\r\n            }\r\n\r\n            this.dirty = false;\r\n            this._lastCheck = 0;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Stops all DOM event listeners.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#stopListeners\r\n     * @since 3.16.0\r\n     */\r\n    stopListeners: function ()\r\n    {\r\n        var listeners = this.listeners;\r\n\r\n        window.removeEventListener('orientationchange', listeners.orientationChange, false);\r\n        window.removeEventListener('resize', listeners.windowResize, false);\r\n\r\n        var vendors = [ 'webkit', 'moz', '' ];\r\n\r\n        vendors.forEach(function (prefix)\r\n        {\r\n            document.removeEventListener(prefix + 'fullscreenchange', listeners.fullScreenChange, false);\r\n            document.removeEventListener(prefix + 'fullscreenerror', listeners.fullScreenError, false);\r\n        });\r\n\r\n        //  MS Specific\r\n        document.removeEventListener('MSFullscreenChange', listeners.fullScreenChange, false);\r\n        document.removeEventListener('MSFullscreenError', listeners.fullScreenError, false);\r\n    },\r\n\r\n    /**\r\n     * Destroys this Scale Manager, releasing all references to external resources.\r\n     * Once destroyed, the Scale Manager cannot be used again.\r\n     *\r\n     * @method Phaser.Scale.ScaleManager#destroy\r\n     * @since 3.16.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.removeAllListeners();\r\n\r\n        this.stopListeners();\r\n\r\n        this.game = null;\r\n        this.canvas = null;\r\n        this.canvasBounds = null;\r\n        this.parent = null;\r\n        this.parentSize.destroy();\r\n        this.gameSize.destroy();\r\n        this.baseSize.destroy();\r\n        this.displaySize.destroy();\r\n        this.fullscreenTarget = null;\r\n    },\r\n\r\n    /**\r\n     * Is the browser currently in fullscreen mode or not?\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#isFullscreen\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    isFullscreen: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.fullscreen.active;\r\n        }\r\n    \r\n    },\r\n\r\n    /**\r\n     * The game width.\r\n     * \r\n     * This is typically the size given in the game configuration.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#width\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    width: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.gameSize.width;\r\n        }\r\n    \r\n    },\r\n\r\n    /**\r\n     * The game height.\r\n     * \r\n     * This is typically the size given in the game configuration.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#height\r\n     * @type {number}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    height: {\r\n\r\n        get: function ()\r\n        {\r\n            return this.gameSize.height;\r\n        }\r\n    \r\n    },\r\n\r\n    /**\r\n     * Is the device in a portrait orientation as reported by the Orientation API?\r\n     * This value is usually only available on mobile devices.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#isPortrait\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    isPortrait: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this.orientation === CONST.ORIENTATION.PORTRAIT);\r\n        }\r\n    \r\n    },\r\n\r\n    /**\r\n     * Is the device in a landscape orientation as reported by the Orientation API?\r\n     * This value is usually only available on mobile devices.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#isLandscape\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    isLandscape: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this.orientation === CONST.ORIENTATION.LANDSCAPE);\r\n        }\r\n    \r\n    },\r\n\r\n    /**\r\n     * Are the game dimensions portrait? (i.e. taller than they are wide)\r\n     * \r\n     * This is different to the device itself being in a portrait orientation.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#isGamePortrait\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    isGamePortrait: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this.height > this.width);\r\n        }\r\n    \r\n    },\r\n\r\n    /**\r\n     * Are the game dimensions landscape? (i.e. wider than they are tall)\r\n     * \r\n     * This is different to the device itself being in a landscape orientation.\r\n     *\r\n     * @name Phaser.Scale.ScaleManager#isGameLandscape\r\n     * @type {boolean}\r\n     * @readonly\r\n     * @since 3.16.0\r\n     */\r\n    isGameLandscape: {\r\n\r\n        get: function ()\r\n        {\r\n            return (this.width > this.height);\r\n        }\r\n    \r\n    }\r\n\r\n});\r\n\r\nmodule.exports = ScaleManager;\r\n"},"sourceMaps":null,"error":null,"hash":"3f56cd9cc101356ac636c0bca9d4d26f","cacheData":{"env":{}}}