{"id":"../../node_modules/phaser/src/gameobjects/rendertexture/RenderTexture.js","dependencies":[{"name":"C:\\Users\\דור\\Desktop\\pmm\\package.json","includedInParent":true,"mtime":1560952935180},{"name":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\package.json","includedInParent":true,"mtime":1561396619369},{"name":"../../renderer/BlendModes","loc":{"line":7,"column":25},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\rendertexture\\RenderTexture.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\BlendModes.js"},{"name":"../../cameras/2d/BaseCamera","loc":{"line":8,"column":21},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\rendertexture\\RenderTexture.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\cameras\\2d\\BaseCamera.js"},{"name":"../../display/canvas/CanvasPool","loc":{"line":9,"column":25},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\rendertexture\\RenderTexture.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\display\\canvas\\CanvasPool.js"},{"name":"../../utils/Class","loc":{"line":10,"column":20},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\rendertexture\\RenderTexture.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\Class.js"},{"name":"../components","loc":{"line":11,"column":25},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\rendertexture\\RenderTexture.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\components\\index.js"},{"name":"../../const","loc":{"line":12,"column":20},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\rendertexture\\RenderTexture.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\const.js"},{"name":"../../textures/Frame","loc":{"line":13,"column":20},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\rendertexture\\RenderTexture.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\textures\\Frame.js"},{"name":"../GameObject","loc":{"line":14,"column":25},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\rendertexture\\RenderTexture.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\GameObject.js"},{"name":"./RenderTextureRender","loc":{"line":15,"column":21},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\rendertexture\\RenderTexture.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\rendertexture\\RenderTextureRender.js"},{"name":"../../renderer/webgl/Utils","loc":{"line":16,"column":20},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\rendertexture\\RenderTexture.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\webgl\\Utils.js"},{"name":"../../utils/string/UUID","loc":{"line":17,"column":19},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\rendertexture\\RenderTexture.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\string\\UUID.js"}],"generated":{"js":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar BlendModes = require('../../renderer/BlendModes');\r\nvar Camera = require('../../cameras/2d/BaseCamera');\r\nvar CanvasPool = require('../../display/canvas/CanvasPool');\r\nvar Class = require('../../utils/Class');\r\nvar Components = require('../components');\r\nvar CONST = require('../../const');\r\nvar Frame = require('../../textures/Frame');\r\nvar GameObject = require('../GameObject');\r\nvar Render = require('./RenderTextureRender');\r\nvar Utils = require('../../renderer/webgl/Utils');\r\nvar UUID = require('../../utils/string/UUID');\r\n\r\n/**\r\n * @classdesc\r\n * A Render Texture.\r\n * \r\n * A Render Texture is a special texture that allows any number of Game Objects to be drawn to it. You can take many complex objects and\r\n * draw them all to this one texture, which can they be used as the texture for other Game Object's. It's a way to generate dynamic\r\n * textures at run-time that are WebGL friendly and don't invoke expensive GPU uploads.\r\n * \r\n * Note that under WebGL a FrameBuffer, which is what the Render Texture uses internally, cannot be anti-aliased. This means\r\n * that when drawing objects such as Shapes to a Render Texture they will appear to be drawn with no aliasing, however this\r\n * is a technical limitation of WebGL. To get around it, create your shape as a texture in an art package, then draw that\r\n * to the Render Texture.\r\n *\r\n * @class RenderTexture\r\n * @extends Phaser.GameObjects.GameObject\r\n * @memberof Phaser.GameObjects\r\n * @constructor\r\n * @since 3.2.0\r\n *\r\n * @extends Phaser.GameObjects.Components.Alpha\r\n * @extends Phaser.GameObjects.Components.BlendMode\r\n * @extends Phaser.GameObjects.Components.ComputedSize\r\n * @extends Phaser.GameObjects.Components.Depth\r\n * @extends Phaser.GameObjects.Components.Flip\r\n * @extends Phaser.GameObjects.Components.GetBounds\r\n * @extends Phaser.GameObjects.Components.Mask\r\n * @extends Phaser.GameObjects.Components.Origin\r\n * @extends Phaser.GameObjects.Components.Pipeline\r\n * @extends Phaser.GameObjects.Components.ScrollFactor\r\n * @extends Phaser.GameObjects.Components.Tint\r\n * @extends Phaser.GameObjects.Components.Transform\r\n * @extends Phaser.GameObjects.Components.Visible\r\n *\r\n * @param {Phaser.Scene} scene - The Scene to which this Game Object belongs. A Game Object can only belong to one Scene at a time.\r\n * @param {number} [x=0] - The horizontal position of this Game Object in the world.\r\n * @param {number} [y=0] - The vertical position of this Game Object in the world.\r\n * @param {integer} [width=32] - The width of the Render Texture.\r\n * @param {integer} [height=32] - The height of the Render Texture.\r\n * @property {string} [key] - The texture key to make the RenderTexture from.\r\n * @property {string} [frame] - the frame to make the RenderTexture from.\r\n */\r\nvar RenderTexture = new Class({\r\n\r\n    Extends: GameObject,\r\n\r\n    Mixins: [\r\n        Components.Alpha,\r\n        Components.BlendMode,\r\n        Components.ComputedSize,\r\n        Components.Crop,\r\n        Components.Depth,\r\n        Components.Flip,\r\n        Components.GetBounds,\r\n        Components.Mask,\r\n        Components.Origin,\r\n        Components.Pipeline,\r\n        Components.ScrollFactor,\r\n        Components.Tint,\r\n        Components.Transform,\r\n        Components.Visible,\r\n        Render\r\n    ],\r\n\r\n    initialize:\r\n\r\n    function RenderTexture (scene, x, y, width, height, key, frame)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = 32; }\r\n        if (height === undefined) { height = 32; }\r\n\r\n        GameObject.call(this, scene, 'RenderTexture');\r\n\r\n        /**\r\n         * A reference to either the Canvas or WebGL Renderer that the Game instance is using.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#renderer\r\n         * @type {(Phaser.Renderer.Canvas.CanvasRenderer|Phaser.Renderer.WebGL.WebGLRenderer)}\r\n         * @since 3.2.0\r\n         */\r\n        this.renderer = scene.sys.game.renderer;\r\n\r\n        /**\r\n         * A reference to the Texture Manager.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#textureManager\r\n         * @type {Phaser.Textures.TextureManager}\r\n         * @since 3.12.0\r\n         */\r\n        this.textureManager = scene.sys.textures;\r\n\r\n        /**\r\n         * The tint of the Render Texture when rendered.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#globalTint\r\n         * @type {number}\r\n         * @default 0xffffff\r\n         * @since 3.2.0\r\n         */\r\n        this.globalTint = 0xffffff;\r\n\r\n        /**\r\n         * The alpha of the Render Texture when rendered.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#globalAlpha\r\n         * @type {number}\r\n         * @default 1\r\n         * @since 3.2.0\r\n         */\r\n        this.globalAlpha = 1;\r\n\r\n        /**\r\n         * The HTML Canvas Element that the Render Texture is drawing to when using the Canvas Renderer.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#canvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.2.0\r\n         */\r\n        this.canvas = null;\r\n\r\n        /**\r\n         * A reference to the GL Frame Buffer this Render Texture is drawing to.\r\n         * This is only set if Phaser is running with the WebGL Renderer.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#framebuffer\r\n         * @type {?WebGLFramebuffer}\r\n         * @since 3.2.0\r\n         */\r\n        this.framebuffer = null;\r\n\r\n        /**\r\n         * Is this Render Texture dirty or not? If not it won't spend time clearing or filling itself.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#dirty\r\n         * @type {boolean}\r\n         * @since 3.12.0\r\n         */\r\n        this.dirty = false;\r\n\r\n        /**\r\n         * The internal crop data object, as used by `setCrop` and passed to the `Frame.setCropUVs` method.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#_crop\r\n         * @type {object}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._crop = this.resetCropObject();\r\n\r\n        /**\r\n         * The Texture corresponding to this Render Texture.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#texture\r\n         * @type {Phaser.Textures.Texture}\r\n         * @since 3.12.0\r\n         */\r\n        this.texture = null;\r\n\r\n        /**\r\n         * The Frame corresponding to this Render Texture.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#frame\r\n         * @type {Phaser.Textures.Frame}\r\n         * @since 3.12.0\r\n         */\r\n        this.frame = null;\r\n\r\n        /**\r\n         * Internal saved texture flag.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#_saved\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.12.0\r\n         */\r\n        this._saved = false;\r\n\r\n        if (key === undefined)\r\n        {\r\n            this.canvas = CanvasPool.create2D(this, width, height);\r\n\r\n            //  Create a new Texture for this Text object\r\n            this.texture = scene.sys.textures.addCanvas(UUID(), this.canvas);\r\n            \r\n            //  Get the frame\r\n            this.frame = this.texture.get();\r\n        }\r\n        else\r\n        {\r\n            this.texture = scene.sys.textures.get(key);\r\n            \r\n            //  Get the frame\r\n            this.frame = this.texture.get(frame);\r\n\r\n            this.canvas = this.frame.source.image;\r\n            this._saved = true;\r\n\r\n            this.dirty = true;\r\n\r\n            this.width = this.frame.cutWidth;\r\n            this.height = this.frame.cutHeight;\r\n        }\r\n\r\n        /**\r\n         * A reference to the Rendering Context belonging to the Canvas Element this Render Texture is drawing to.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#context\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.2.0\r\n         */\r\n        this.context = this.canvas.getContext('2d');\r\n\r\n        /**\r\n         * Internal erase mode flag.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#_eraseMode\r\n         * @type {boolean}\r\n         * @private\r\n         * @since 3.16.0\r\n         */\r\n        this._eraseMode = false;\r\n\r\n        /**\r\n         * An internal Camera that can be used to move around the Render Texture.\r\n         * Control it just like you would any Scene Camera. The difference is that it only impacts the placement of what\r\n         * is drawn to the Render Texture. You can scroll, zoom and rotate this Camera.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#camera\r\n         * @type {Phaser.Cameras.Scene2D.BaseCamera}\r\n         * @since 3.12.0\r\n         */\r\n        this.camera = new Camera(0, 0, width, height);\r\n\r\n        /**\r\n         * A reference to the WebGL Rendering Context.\r\n         *\r\n         * @name Phaser.GameObjects.RenderTexture#gl\r\n         * @type {WebGLRenderingContext}\r\n         * @default null\r\n         * @since 3.0.0\r\n         */\r\n        this.gl = null;\r\n\r\n        var renderer = this.renderer;\r\n\r\n        if (renderer.type === CONST.WEBGL)\r\n        {\r\n            var gl = renderer.gl;\r\n\r\n            this.gl = gl;\r\n            this.drawGameObject = this.batchGameObjectWebGL;\r\n            this.framebuffer = renderer.createFramebuffer(width, height, this.frame.source.glTexture, false);\r\n        }\r\n        else if (renderer.type === CONST.CANVAS)\r\n        {\r\n            this.drawGameObject = this.batchGameObjectCanvas;\r\n        }\r\n\r\n        this.camera.setScene(scene);\r\n\r\n        this.setPosition(x, y);\r\n\r\n        if (key === undefined)\r\n        {\r\n            this.setSize(width, height);\r\n        }\r\n\r\n        this.setOrigin(0, 0);\r\n        this.initPipeline();\r\n    },\r\n\r\n    /**\r\n     * Sets the size of this Game Object.\r\n     * \r\n     * @method Phaser.GameObjects.RenderTexture#setSize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} width - The width of this Game Object.\r\n     * @param {number} height - The height of this Game Object.\r\n     * \r\n     * @return {this} This Game Object instance.\r\n     */\r\n    setSize: function (width, height)\r\n    {\r\n        return this.resize(width, height);\r\n    },\r\n\r\n    /**\r\n     * Resizes the Render Texture to the new dimensions given.\r\n     * \r\n     * If Render Texture was created from specific frame, only the size of the frame will be changed. The size of the source\r\n     * texture will not change.\r\n     *\r\n     * If Render Texture was not created from specific frame, the following will happen:\r\n     * In WebGL it will destroy and then re-create the frame buffer being used by the Render Texture.\r\n     * In Canvas it will resize the underlying canvas element.\r\n     * Both approaches will erase everything currently drawn to the Render Texture.\r\n     *\r\n     * If the dimensions given are the same as those already being used, calling this method will do nothing.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#resize\r\n     * @since 3.10.0\r\n     *\r\n     * @param {number} width - The new width of the Render Texture.\r\n     * @param {number} [height] - The new height of the Render Texture. If not specified, will be set the same as the `width`.\r\n     *\r\n     * @return {this} This Render Texture.\r\n     */\r\n    resize: function (width, height)\r\n    {\r\n        if (height === undefined) { height = width; }\r\n\r\n        if (width !== this.width || height !== this.height)\r\n        {\r\n            \r\n            if (this.frame.name === '__BASE') // resize the texture\r\n            {\r\n\r\n                this.canvas.width = width;\r\n                this.canvas.height = height;\r\n\r\n                if (this.gl)\r\n                {\r\n                    var gl = this.gl;\r\n\r\n                    this.renderer.deleteTexture(this.frame.source.glTexture);\r\n                    this.renderer.deleteFramebuffer(this.framebuffer);\r\n\r\n                    this.frame.source.glTexture = this.renderer.createTexture2D(0, gl.NEAREST, gl.NEAREST, gl.CLAMP_TO_EDGE, gl.CLAMP_TO_EDGE, gl.RGBA, null, width, height, false);\r\n                    this.framebuffer = this.renderer.createFramebuffer(width, height, this.frame.source.glTexture, false);\r\n\r\n                    this.frame.glTexture = this.frame.source.glTexture;\r\n                }\r\n\r\n                this.frame.source.width = width;\r\n                this.frame.source.height = height;\r\n\r\n                this.camera.setSize(width, height);\r\n\r\n                this.frame.setSize(width, height);\r\n\r\n                this.width = width;\r\n                this.height = height;\r\n\r\n            }\r\n        }\r\n        else // resize the frame\r\n        {\r\n            var baseFrame = this.texture.getSourceImage();\r\n            if (this.frame.cutX + width > baseFrame.width) { width = baseFrame.width - this.frame.cutX; }\r\n            if (this.frame.cutY + height > baseFrame.height) { height = baseFrame.height - this.frame.cutY; }\r\n\r\n            this.frame.setSize(width, height, this.frame.cutX, this.frame.cutY);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the tint to use when rendering this Render Texture.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#setGlobalTint\r\n     * @since 3.2.0\r\n     *\r\n     * @param {integer} tint - The tint value.\r\n     *\r\n     * @return {this} This Render Texture.\r\n     */\r\n    setGlobalTint: function (tint)\r\n    {\r\n        this.globalTint = tint;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Set the alpha to use when rendering this Render Texture.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#setGlobalAlpha\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} alpha - The alpha value.\r\n     *\r\n     * @return {this} This Render Texture.\r\n     */\r\n    setGlobalAlpha: function (alpha)\r\n    {\r\n        this.globalAlpha = alpha;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Stores a copy of this Render Texture in the Texture Manager using the given key.\r\n     * \r\n     * After doing this, any texture based Game Object, such as a Sprite, can use the contents of this\r\n     * Render Texture by using the texture key:\r\n     * \r\n     * ```javascript\r\n     * var rt = this.add.renderTexture(0, 0, 128, 128);\r\n     * \r\n     * // Draw something to the Render Texture\r\n     * \r\n     * rt.saveTexture('doodle');\r\n     * \r\n     * this.add.image(400, 300, 'doodle');\r\n     * ```\r\n     * \r\n     * Updating the contents of this Render Texture will automatically update _any_ Game Object\r\n     * that is using it as a texture. Calling `saveTexture` again will not save another copy\r\n     * of the same texture, it will just rename the key of the existing copy.\r\n     * \r\n     * By default it will create a single base texture. You can add frames to the texture\r\n     * by using the `Texture.add` method. After doing this, you can then allow Game Objects\r\n     * to use a specific frame from a Render Texture.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#saveTexture\r\n     * @since 3.12.0\r\n     *\r\n     * @param {string} key - The unique key to store the texture as within the global Texture Manager.\r\n     *\r\n     * @return {Phaser.Textures.Texture} The Texture that was saved.\r\n     */\r\n    saveTexture: function (key)\r\n    {\r\n        this.textureManager.renameTexture(this.texture.key, key);\r\n        \r\n        this._saved = true;\r\n\r\n        return this.texture;\r\n    },\r\n\r\n    /**\r\n     * Fills the Render Texture with the given color.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#fill\r\n     * @since 3.2.0\r\n     *\r\n     * @param {number} rgb - The color to fill the Render Texture with.\r\n     * @param {number} [alpha=1] - The alpha value used by the fill.\r\n     * @param {number} [x=0] - The left coordinate of the fill rectangle.\r\n     * @param {number} [y=0] - The top coordinate of the fill rectangle.\r\n     * @param {number} [width=this.frame.cutWidth] - The width of the fill rectangle.\r\n     * @param {number} [height=this.frame.cutHeight] - The height of the fill rectangle.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    fill: function (rgb, alpha, x, y, width, height)\r\n    {\r\n        if (alpha === undefined) { alpha = 1; }\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (width === undefined) { width = this.frame.cutWidth; }\r\n        if (height === undefined) { height = this.frame.cutHeight; }\r\n\r\n        var r = ((rgb >> 16) | 0) & 0xff;\r\n        var g = ((rgb >> 8) | 0) & 0xff;\r\n        var b = (rgb | 0) & 0xff;\r\n\r\n        var gl = this.gl;\r\n        var frame = this.frame;\r\n\r\n        if (gl)\r\n        {\r\n            var renderer = this.renderer;\r\n   \r\n            var bounds = this.getBounds();\r\n\r\n            renderer.setFramebuffer(this.framebuffer, true);\r\n\r\n            if (width !== frame.source.width || height !== frame.source.height)\r\n            {\r\n                gl.scissor(x + frame.cutX, y + frame.cutY, width, height);\r\n            }\r\n\r\n            this.pipeline.drawFillRect(\r\n                bounds.x, bounds.y, bounds.right, bounds.bottom,\r\n                Utils.getTintFromFloats(r / 255, g / 255, b / 255, 1),\r\n                alpha\r\n            );\r\n\r\n            if (width !== frame.source.width || height !== frame.source.height)\r\n            {\r\n                gl.scissor(0, 0, frame.source.width, frame.source.height);\r\n            }\r\n    \r\n            this.renderer.setFramebuffer(null, true);\r\n        }\r\n        else\r\n        {\r\n            this.context.fillStyle = 'rgba(' + r + ',' + g + ',' + b + ',' + alpha + ')';\r\n            this.context.fillRect(x + frame.cutX, y + frame.cutY, width, height);\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Clears the Render Texture.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#clear\r\n     * @since 3.2.0\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    clear: function ()\r\n    {\r\n        if (this.dirty)\r\n        {\r\n            var gl = this.gl;\r\n\r\n            if (gl)\r\n            {\r\n                var renderer = this.renderer;\r\n\r\n                renderer.setFramebuffer(this.framebuffer, true);\r\n        \r\n                if (this.frame.cutWidth !== this.canvas.width || this.frame.cutHeight !== this.canvas.height)\r\n                {\r\n                    gl.scissor(this.frame.cutX, this.frame.cutY, this.frame.cutWidth, this.frame.cutHeight);\r\n                }\r\n\r\n                gl.clearColor(0, 0, 0, 0);\r\n                gl.clear(gl.COLOR_BUFFER_BIT);\r\n\r\n                renderer.setFramebuffer(null, true);\r\n            }\r\n            else\r\n            {\r\n                var ctx = this.context;\r\n\r\n                ctx.save();\r\n                ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n                ctx.clearRect(this.frame.cutX, this.frame.cutY, this.frame.cutWidth, this.frame.cutHeight);\r\n                ctx.restore();\r\n            }\r\n\r\n            this.dirty = false;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draws the given object, or an array of objects, to this Render Texture using a blend mode of ERASE.\r\n     * This has the effect of erasing any filled pixels in the objects from this Render Texture.\r\n     * \r\n     * It can accept any of the following:\r\n     * \r\n     * * Any renderable Game Object, such as a Sprite, Text, Graphics or TileSprite.\r\n     * * Dynamic and Static Tilemap Layers.\r\n     * * A Group. The contents of which will be iterated and drawn in turn.\r\n     * * A Container. The contents of which will be iterated fully, and drawn in turn.\r\n     * * A Scene's Display List. Pass in `Scene.children` to draw the whole list.\r\n     * * Another Render Texture.\r\n     * * A Texture Frame instance.\r\n     * * A string. This is used to look-up a texture from the Texture Manager.\r\n     * \r\n     * Note: You cannot erase a Render Texture from itself.\r\n     * \r\n     * If passing in a Group or Container it will only draw children that return `true`\r\n     * when their `willRender()` method is called. I.e. a Container with 10 children,\r\n     * 5 of which have `visible=false` will only draw the 5 visible ones.\r\n     * \r\n     * If passing in an array of Game Objects it will draw them all, regardless if\r\n     * they pass a `willRender` check or not.\r\n     * \r\n     * You can pass in a string in which case it will look for a texture in the Texture\r\n     * Manager matching that string, and draw the base frame.\r\n     * \r\n     * You can pass in the `x` and `y` coordinates to draw the objects at. The use of\r\n     * the coordinates differ based on what objects are being drawn. If the object is\r\n     * a Group, Container or Display List, the coordinates are _added_ to the positions\r\n     * of the children. For all other types of object, the coordinates are exact.\r\n     * \r\n     * Calling this method causes the WebGL batch to flush, so it can write the texture\r\n     * data to the framebuffer being used internally. The batch is flushed at the end,\r\n     * after the entries have been iterated. So if you've a bunch of objects to draw,\r\n     * try and pass them in an array in one single call, rather than making lots of\r\n     * separate calls.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#erase\r\n     * @since 3.16.0\r\n     *\r\n     * @param {any} entries - Any renderable Game Object, or Group, Container, Display List, other Render Texture, Texture Frame or an array of any of these.\r\n     * @param {number} [x] - The x position to draw the Frame at, or the offset applied to the object.\r\n     * @param {number} [y] - The y position to draw the Frame at, or the offset applied to the object.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    erase: function (entries, x, y)\r\n    {\r\n        this._eraseMode = true;\r\n\r\n        var blendMode = this.renderer.currentBlendMode;\r\n\r\n        this.renderer.setBlendMode(BlendModes.ERASE);\r\n\r\n        this.draw(entries, x, y, 1, 16777215);\r\n\r\n        this.renderer.setBlendMode(blendMode);\r\n\r\n        this._eraseMode = false;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draws the given object, or an array of objects, to this Render Texture.\r\n     * \r\n     * It can accept any of the following:\r\n     * \r\n     * * Any renderable Game Object, such as a Sprite, Text, Graphics or TileSprite.\r\n     * * Dynamic and Static Tilemap Layers.\r\n     * * A Group. The contents of which will be iterated and drawn in turn.\r\n     * * A Container. The contents of which will be iterated fully, and drawn in turn.\r\n     * * A Scene's Display List. Pass in `Scene.children` to draw the whole list.\r\n     * * Another Render Texture.\r\n     * * A Texture Frame instance.\r\n     * * A string. This is used to look-up a texture from the Texture Manager.\r\n     * \r\n     * Note: You cannot draw a Render Texture to itself.\r\n     * \r\n     * If passing in a Group or Container it will only draw children that return `true`\r\n     * when their `willRender()` method is called. I.e. a Container with 10 children,\r\n     * 5 of which have `visible=false` will only draw the 5 visible ones.\r\n     * \r\n     * If passing in an array of Game Objects it will draw them all, regardless if\r\n     * they pass a `willRender` check or not.\r\n     * \r\n     * You can pass in a string in which case it will look for a texture in the Texture\r\n     * Manager matching that string, and draw the base frame. If you need to specify\r\n     * exactly which frame to draw then use the method `drawFrame` instead.\r\n     * \r\n     * You can pass in the `x` and `y` coordinates to draw the objects at. The use of\r\n     * the coordinates differ based on what objects are being drawn. If the object is\r\n     * a Group, Container or Display List, the coordinates are _added_ to the positions\r\n     * of the children. For all other types of object, the coordinates are exact.\r\n     * \r\n     * The `alpha` and `tint` values are only used by Texture Frames.\r\n     * Game Objects use their own alpha and tint values when being drawn.\r\n     * \r\n     * Calling this method causes the WebGL batch to flush, so it can write the texture\r\n     * data to the framebuffer being used internally. The batch is flushed at the end,\r\n     * after the entries have been iterated. So if you've a bunch of objects to draw,\r\n     * try and pass them in an array in one single call, rather than making lots of\r\n     * separate calls.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#draw\r\n     * @since 3.2.0\r\n     *\r\n     * @param {any} entries - Any renderable Game Object, or Group, Container, Display List, other Render Texture, Texture Frame or an array of any of these.\r\n     * @param {number} [x] - The x position to draw the Frame at, or the offset applied to the object.\r\n     * @param {number} [y] - The y position to draw the Frame at, or the offset applied to the object.\r\n     * @param {number} [alpha] -  The alpha value. Only used for Texture Frames and if not specified defaults to the `globalAlpha` property. Game Objects use their own current alpha value.\r\n     * @param {number} [tint] -  WebGL only. The tint color value. Only used for Texture Frames and if not specified defaults to the `globalTint` property. Game Objects use their own current tint value.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    draw: function (entries, x, y, alpha, tint)\r\n    {\r\n        if (alpha === undefined) { alpha = this.globalAlpha; }\r\n\r\n        if (tint === undefined)\r\n        {\r\n            tint = (this.globalTint >> 16) + (this.globalTint & 0xff00) + ((this.globalTint & 0xff) << 16);\r\n        }\r\n        else\r\n        {\r\n            tint = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16);\r\n        }\r\n\r\n        if (!Array.isArray(entries))\r\n        {\r\n            entries = [ entries ];\r\n        }\r\n\r\n        var gl = this.gl;\r\n\r\n        this.camera.preRender(1, 1);\r\n\r\n        if (gl)\r\n        {\r\n            var cx = this.camera._cx;\r\n            var cy = this.camera._cy;\r\n            var cw = this.camera._cw;\r\n            var ch = this.camera._ch;\r\n\r\n            this.renderer.setFramebuffer(this.framebuffer, false);\r\n\r\n            this.renderer.pushScissor(cx, cy, cw, ch, ch);\r\n\r\n            var pipeline = this.pipeline;\r\n    \r\n            pipeline.projOrtho(0, this.texture.width, 0, this.texture.height, -1000.0, 1000.0);\r\n\r\n            this.batchList(entries, x + this.frame.cutX, y + this.frame.cutY, alpha, tint);\r\n\r\n            pipeline.flush();\r\n\r\n            this.renderer.setFramebuffer(null, false);\r\n\r\n            this.renderer.popScissor();\r\n\r\n            pipeline.projOrtho(0, pipeline.width, pipeline.height, 0, -1000.0, 1000.0);\r\n        }\r\n        else\r\n        {\r\n            this.renderer.setContext(this.context);\r\n\r\n            this.batchList(entries, x + this.frame.cutX, y + this.frame.cutY, alpha, tint);\r\n\r\n            this.renderer.setContext();\r\n        }\r\n\r\n        this.dirty = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Draws the Texture Frame to the Render Texture at the given position.\r\n     * \r\n     * Textures are referenced by their string-based keys, as stored in the Texture Manager.\r\n     * \r\n     * ```javascript\r\n     * var rt = this.add.renderTexture(0, 0, 800, 600);\r\n     * rt.drawFrame(key, frame);\r\n     * ```\r\n     * \r\n     * You can optionally provide a position, alpha and tint value to apply to the frame\r\n     * before it is drawn.\r\n     * \r\n     * Calling this method will cause a batch flush, so if you've got a stack of things to draw\r\n     * in a tight loop, try using the `draw` method instead.\r\n     * \r\n     * If you need to draw a Sprite to this Render Texture, use the `draw` method instead.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#drawFrame\r\n     * @since 3.12.0\r\n     *\r\n     * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.\r\n     * @param {(string|integer)} [frame] - The name or index of the frame within the Texture.\r\n     * @param {number} [x=0] - The x position to draw the frame at.\r\n     * @param {number} [y=0] - The y position to draw the frame at.\r\n     * @param {number} [alpha] - The alpha to use. If not specified it uses the `globalAlpha` property.\r\n     * @param {number} [tint] - WebGL only. The tint color to use. If not specified it uses the `globalTint` property.\r\n     *\r\n     * @return {this} This Render Texture instance.\r\n     */\r\n    drawFrame: function (key, frame, x, y, alpha, tint)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n        if (alpha === undefined) { alpha = this.globalAlpha; }\r\n\r\n        if (tint === undefined)\r\n        {\r\n            tint = (this.globalTint >> 16) + (this.globalTint & 0xff00) + ((this.globalTint & 0xff) << 16);\r\n        }\r\n        else\r\n        {\r\n            tint = (tint >> 16) + (tint & 0xff00) + ((tint & 0xff) << 16);\r\n        }\r\n\r\n        var gl = this.gl;\r\n        var textureFrame = this.textureManager.getFrame(key, frame);\r\n\r\n        if (textureFrame)\r\n        {\r\n            this.camera.preRender(1, 1);\r\n\r\n            if (gl)\r\n            {\r\n                var cx = this.camera._cx;\r\n                var cy = this.camera._cy;\r\n                var cw = this.camera._cw;\r\n                var ch = this.camera._ch;\r\n    \r\n                this.renderer.setFramebuffer(this.framebuffer, false);\r\n    \r\n                this.renderer.pushScissor(cx, cy, cw, ch, ch);\r\n    \r\n                var pipeline = this.pipeline;\r\n        \r\n                pipeline.projOrtho(0, this.texture.width, 0, this.texture.height, -1000.0, 1000.0);\r\n        \r\n                pipeline.batchTextureFrame(textureFrame, x + this.frame.cutX, y + this.frame.cutY, tint, alpha, this.camera.matrix, null);\r\n            \r\n                pipeline.flush();\r\n        \r\n                this.renderer.setFramebuffer(null, false);\r\n\r\n                this.renderer.popScissor();\r\n            \r\n                pipeline.projOrtho(0, pipeline.width, pipeline.height, 0, -1000.0, 1000.0);\r\n            }\r\n            else\r\n            {\r\n                this.batchTextureFrame(textureFrame, x + this.frame.cutX, y + this.frame.cutY, alpha, tint);\r\n            }\r\n\r\n            this.dirty = true;\r\n        }\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Internal method that handles the drawing of an array of children.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchList\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {array} children - The array of Game Objects to draw.\r\n     * @param {number} x - The x position to offset the Game Object by.\r\n     * @param {number} y - The y position to offset the Game Object by.\r\n     * @param {number} [alpha] - The alpha to use. If not specified it uses the `globalAlpha` property.\r\n     * @param {number} [tint] - The tint color to use. If not specified it uses the `globalTint` property.\r\n     */\r\n    batchList: function (children, x, y, alpha, tint)\r\n    {\r\n        for (var i = 0; i < children.length; i++)\r\n        {\r\n            var entry = children[i];\r\n\r\n            if (!entry || entry === this)\r\n            {\r\n                continue;\r\n            }\r\n\r\n            if (entry.renderWebGL || entry.renderCanvas)\r\n            {\r\n                //  Game Objects\r\n                this.drawGameObject(entry, x, y);\r\n            }\r\n            else if (entry.isParent || entry.list)\r\n            {\r\n                //  Groups / Display Lists\r\n                this.batchGroup(entry.getChildren(), x, y);\r\n            }\r\n            else if (typeof entry === 'string')\r\n            {\r\n                //  Texture key\r\n                this.batchTextureFrameKey(entry, null, x, y, alpha, tint);\r\n            }\r\n            else if (entry instanceof Frame)\r\n            {\r\n                //  Texture Frame instance\r\n                this.batchTextureFrame(entry, x, y, alpha, tint);\r\n            }\r\n            else if (Array.isArray(entry))\r\n            {\r\n                //  Another Array\r\n                this.batchList(entry, x, y, alpha, tint);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method that handles the drawing a Phaser Group contents.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchGroup\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {array} children - The array of Game Objects to draw.\r\n     * @param {number} x - The x position to offset the Game Object by.\r\n     * @param {number} y - The y position to offset the Game Object by.\r\n     */\r\n    batchGroup: function (children, x, y)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        for (var i = 0; i < children.length; i++)\r\n        {\r\n            var entry = children[i];\r\n\r\n            if (entry.willRender())\r\n            {\r\n                var tx = entry.x + x;\r\n                var ty = entry.y + y;\r\n\r\n                this.drawGameObject(entry, tx, ty);\r\n            }\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method that handles drawing a single Phaser Game Object to this Render Texture using WebGL.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchGameObjectWebGL\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to draw.\r\n     * @param {number} x - The x position to draw the Game Object at.\r\n     * @param {number} y - The y position to draw the Game Object at.\r\n     */\r\n    batchGameObjectWebGL: function (gameObject, x, y)\r\n    {\r\n        if (x === undefined) { x = gameObject.x; }\r\n        if (y === undefined) { y = gameObject.y; }\r\n\r\n        var prevX = gameObject.x;\r\n        var prevY = gameObject.y;\r\n\r\n        if (!this._eraseMode)\r\n        {\r\n            this.renderer.setBlendMode(gameObject.blendMode);\r\n        }\r\n\r\n        gameObject.setPosition(x, y);\r\n\r\n        gameObject.renderWebGL(this.renderer, gameObject, 0, this.camera, null);\r\n\r\n        gameObject.setPosition(prevX, prevY);\r\n    },\r\n\r\n    /**\r\n     * Internal method that handles drawing a single Phaser Game Object to this Render Texture using Canvas.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchGameObjectCanvas\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object to draw.\r\n     * @param {number} x - The x position to draw the Game Object at.\r\n     * @param {number} y - The y position to draw the Game Object at.\r\n     */\r\n    batchGameObjectCanvas: function (gameObject, x, y)\r\n    {\r\n        if (x === undefined) { x = gameObject.x; }\r\n        if (y === undefined) { y = gameObject.y; }\r\n\r\n        var prevX = gameObject.x;\r\n        var prevY = gameObject.y;\r\n\r\n        if (this._eraseMode)\r\n        {\r\n            var blendMode = gameObject.blendMode;\r\n\r\n            gameObject.blendMode = BlendModes.ERASE;\r\n        }\r\n\r\n        gameObject.setPosition(x, y);\r\n\r\n        gameObject.renderCanvas(this.renderer, gameObject, 0, this.camera, null);\r\n\r\n        gameObject.setPosition(prevX, prevY);\r\n\r\n        if (this._eraseMode)\r\n        {\r\n            gameObject.blendMode = blendMode;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method that handles the drawing of an array of children.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchTextureFrameKey\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {string} key - The key of the texture to be used, as stored in the Texture Manager.\r\n     * @param {(string|integer)} [frame] - The name or index of the frame within the Texture.\r\n     * @param {number} x - The x position to offset the Game Object by.\r\n     * @param {number} y - The y position to offset the Game Object by.\r\n     * @param {number} [alpha] - The alpha to use. If not specified it uses the `globalAlpha` property.\r\n     * @param {number} [tint] - The tint color to use. If not specified it uses the `globalTint` property.\r\n     * \r\n     * @return {boolean} `true` if the frame was found and drawn, otherwise `false`.\r\n     */\r\n    batchTextureFrameKey: function (key, frame, x, y, alpha, tint)\r\n    {\r\n        var textureFrame = this.textureManager.getFrame(key, frame);\r\n\r\n        if (textureFrame)\r\n        {\r\n            this.batchTextureFrame(textureFrame, x, y, alpha, tint);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal method that handles the drawing of a Texture Frame to this Render Texture.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#batchTextureFrame\r\n     * @private\r\n     * @since 3.12.0\r\n     *\r\n     * @param {Phaser.Textures.Frame} textureFrame - The Texture Frame to draw.\r\n     * @param {number} x - The x position to draw the Frame at.\r\n     * @param {number} y - The y position to draw the Frame at.\r\n     * @param {number} [tint] - A tint color to be applied to the frame drawn to the Render Texture.\r\n     */\r\n    batchTextureFrame: function (textureFrame, x, y, alpha, tint)\r\n    {\r\n        if (x === undefined) { x = 0; }\r\n        if (y === undefined) { y = 0; }\r\n\r\n        if (this.gl)\r\n        {\r\n            this.pipeline.batchTextureFrame(textureFrame, x, y, tint, alpha, this.camera.matrix, null);\r\n        }\r\n        else\r\n        {\r\n            var ctx = this.context;\r\n            var cd = textureFrame.canvasData;\r\n            var source = textureFrame.source.image;\r\n    \r\n            var matrix = this.camera.matrix;\r\n    \r\n            ctx.globalAlpha = this.globalAlpha;\r\n\r\n            ctx.setTransform(matrix[0], matrix[1], matrix[2], matrix[3], matrix[4], matrix[5]);\r\n\r\n            ctx.drawImage(source, cd.x, cd.y, cd.width, cd.height, x, y, cd.width, cd.height);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Internal destroy handler, called as part of the destroy process.\r\n     *\r\n     * @method Phaser.GameObjects.RenderTexture#preDestroy\r\n     * @protected\r\n     * @since 3.9.0\r\n     */\r\n    preDestroy: function ()\r\n    {\r\n        if (!this._saved)\r\n        {\r\n            CanvasPool.remove(this.canvas);\r\n\r\n            if (this.gl)\r\n            {\r\n                this.renderer.deleteFramebuffer(this.framebuffer);\r\n            }\r\n\r\n            this.texture.destroy();\r\n            this.camera.destroy();\r\n\r\n            this.canvas = null;\r\n            this.context = null;\r\n            this.framebuffer = null;\r\n            this.texture = null;\r\n        }\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = RenderTexture;\r\n"},"sourceMaps":null,"error":null,"hash":"28643b4ff6ac486b4a5ffa7a759e1c13","cacheData":{"env":{}}}