{"id":"../../node_modules/phaser/src/renderer/canvas/CanvasRenderer.js","dependencies":[{"name":"C:\\Users\\דור\\Desktop\\pmm\\package.json","includedInParent":true,"mtime":1560952935180},{"name":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\package.json","includedInParent":true,"mtime":1561396619369},{"name":"../snapshot/CanvasSnapshot","loc":{"line":8,"column":29},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\canvas\\CanvasRenderer.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\snapshot\\CanvasSnapshot.js"},{"name":"../../cameras/2d/events","loc":{"line":9,"column":27},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\canvas\\CanvasRenderer.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\cameras\\2d\\events\\index.js"},{"name":"../../utils/Class","loc":{"line":10,"column":20},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\canvas\\CanvasRenderer.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\Class.js"},{"name":"../../const","loc":{"line":11,"column":20},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\canvas\\CanvasRenderer.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\const.js"},{"name":"./utils/GetBlendModes","loc":{"line":12,"column":28},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\canvas\\CanvasRenderer.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\canvas\\utils\\GetBlendModes.js"},{"name":"../ScaleModes","loc":{"line":13,"column":25},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\canvas\\CanvasRenderer.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\ScaleModes.js"},{"name":"../../display/canvas/Smoothing","loc":{"line":14,"column":24},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\canvas\\CanvasRenderer.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\display\\canvas\\Smoothing.js"},{"name":"../../gameobjects/components/TransformMatrix","loc":{"line":15,"column":30},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\renderer\\canvas\\CanvasRenderer.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\gameobjects\\components\\TransformMatrix.js"}],"generated":{"js":"/**\r\n * @author       Richard Davey <rich@photonstorm.com>\r\n * @author       Felipe Alfonso <@bitnenfer>\r\n * @copyright    2019 Photon Storm Ltd.\r\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\r\n */\r\n\r\nvar CanvasSnapshot = require('../snapshot/CanvasSnapshot');\r\nvar CameraEvents = require('../../cameras/2d/events');\r\nvar Class = require('../../utils/Class');\r\nvar CONST = require('../../const');\r\nvar GetBlendModes = require('./utils/GetBlendModes');\r\nvar ScaleModes = require('../ScaleModes');\r\nvar Smoothing = require('../../display/canvas/Smoothing');\r\nvar TransformMatrix = require('../../gameobjects/components/TransformMatrix');\r\n\r\n/**\r\n * @classdesc\r\n * The Canvas Renderer is responsible for managing 2D canvas rendering contexts, including the one used by the Game's canvas. It tracks the internal state of a given context and can renderer textured Game Objects to it, taking into account alpha, blending, and scaling.\r\n *\r\n * @class CanvasRenderer\r\n * @memberof Phaser.Renderer.Canvas\r\n * @constructor\r\n * @since 3.0.0\r\n *\r\n * @param {Phaser.Game} game - The Phaser Game instance that owns this renderer.\r\n */\r\nvar CanvasRenderer = new Class({\r\n\r\n    initialize:\r\n\r\n    function CanvasRenderer (game)\r\n    {\r\n        /**\r\n         * The Phaser Game instance that owns this renderer.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#game\r\n         * @type {Phaser.Game}\r\n         * @since 3.0.0\r\n         */\r\n        this.game = game;\r\n\r\n        /**\r\n         * A constant which allows the renderer to be easily identified as a Canvas Renderer.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#type\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.type = CONST.CANVAS;\r\n\r\n        /**\r\n         * The total number of Game Objects which were rendered in a frame.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#drawCount\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.drawCount = 0;\r\n\r\n        /**\r\n         * The width of the canvas being rendered to.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#width\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.width = 0;\r\n\r\n        /**\r\n         * The height of the canvas being rendered to.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#height\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.height = 0;\r\n\r\n        /**\r\n         * The local configuration settings of the CanvasRenderer.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#config\r\n         * @type {object}\r\n         * @since 3.0.0\r\n         */\r\n        this.config = {\r\n            clearBeforeRender: game.config.clearBeforeRender,\r\n            backgroundColor: game.config.backgroundColor,\r\n            resolution: game.config.resolution,\r\n            antialias: game.config.antialias,\r\n            roundPixels: game.config.roundPixels\r\n        };\r\n\r\n        /**\r\n         * The scale mode which should be used by the CanvasRenderer.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#scaleMode\r\n         * @type {integer}\r\n         * @since 3.0.0\r\n         */\r\n        this.scaleMode = (game.config.antialias) ? ScaleModes.LINEAR : ScaleModes.NEAREST;\r\n\r\n        /**\r\n         * The canvas element which the Game uses.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#gameCanvas\r\n         * @type {HTMLCanvasElement}\r\n         * @since 3.0.0\r\n         */\r\n        this.gameCanvas = game.canvas;\r\n\r\n        /**\r\n         * The canvas context used to render all Cameras in all Scenes during the game loop.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#gameContext\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.0.0\r\n         */\r\n        this.gameContext = (this.game.config.context) ? this.game.config.context : this.gameCanvas.getContext('2d');\r\n\r\n        /**\r\n         * The canvas context currently used by the CanvasRenderer for all rendering operations.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#currentContext\r\n         * @type {CanvasRenderingContext2D}\r\n         * @since 3.0.0\r\n         */\r\n        this.currentContext = this.gameContext;\r\n\r\n        /**\r\n         * The blend modes supported by the Canvas Renderer.\r\n         *\r\n         * This object maps the {@link Phaser.BlendModes} to canvas compositing operations.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#blendModes\r\n         * @type {array}\r\n         * @since 3.0.0\r\n         */\r\n        this.blendModes = GetBlendModes();\r\n\r\n        // image-rendering: optimizeSpeed;\r\n        // image-rendering: pixelated;\r\n\r\n        /**\r\n         * The scale mode currently in use by the Canvas Renderer.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#currentScaleMode\r\n         * @type {number}\r\n         * @default 0\r\n         * @since 3.0.0\r\n         */\r\n        this.currentScaleMode = 0;\r\n\r\n        /**\r\n         * Details about the currently scheduled snapshot.\r\n         * \r\n         * If a non-null `callback` is set in this object, a snapshot of the canvas will be taken after the current frame is fully rendered.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#snapshotState\r\n         * @type {Phaser.Types.Renderer.Snapshot.SnapshotState}\r\n         * @since 3.16.0\r\n         */\r\n        this.snapshotState = {\r\n            x: 0,\r\n            y: 0,\r\n            width: 1,\r\n            height: 1,\r\n            getPixel: false,\r\n            callback: null,\r\n            type: 'image/png',\r\n            encoder: 0.92\r\n        };\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#_tempMatrix1\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.12.0\r\n         */\r\n        this._tempMatrix1 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#_tempMatrix2\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.12.0\r\n         */\r\n        this._tempMatrix2 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#_tempMatrix3\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.12.0\r\n         */\r\n        this._tempMatrix3 = new TransformMatrix();\r\n\r\n        /**\r\n         * A temporary Transform Matrix, re-used internally during batching.\r\n         *\r\n         * @name Phaser.Renderer.Canvas.CanvasRenderer#_tempMatrix4\r\n         * @private\r\n         * @type {Phaser.GameObjects.Components.TransformMatrix}\r\n         * @since 3.12.0\r\n         */\r\n        this._tempMatrix4 = new TransformMatrix();\r\n\r\n        this.init();\r\n    },\r\n\r\n    /**\r\n     * Prepares the game canvas for rendering.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#init\r\n     * @since 3.0.0\r\n     */\r\n    init: function ()\r\n    {\r\n        this.game.scale.on('resize', this.onResize, this);\r\n\r\n        var baseSize = this.game.scale.baseSize;\r\n\r\n        this.resize(baseSize.width, baseSize.height);\r\n    },\r\n\r\n    /**\r\n     * The event handler that manages the `resize` event dispatched by the Scale Manager.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#onResize\r\n     * @since 3.16.0\r\n     *\r\n     * @param {Phaser.Structs.Size} gameSize - The default Game Size object. This is the un-modified game dimensions.\r\n     * @param {Phaser.Structs.Size} baseSize - The base Size object. The game dimensions multiplied by the resolution. The canvas width / height values match this.\r\n     * @param {Phaser.Structs.Size} displaySize - The display Size object. The size of the canvas style width / height attributes.\r\n     * @param {number} [resolution] - The Scale Manager resolution setting.\r\n     */\r\n    onResize: function (gameSize, baseSize)\r\n    {\r\n        //  Has the underlying canvas size changed?\r\n        if (baseSize.width !== this.width || baseSize.height !== this.height)\r\n        {\r\n            this.resize(baseSize.width, baseSize.height);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Resize the main game canvas.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#resize\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} [width] - The new width of the renderer.\r\n     * @param {number} [height] - The new height of the renderer.\r\n     */\r\n    resize: function (width, height)\r\n    {\r\n        this.width = width;\r\n        this.height = height;\r\n\r\n        //  Resizing a canvas will reset imageSmoothingEnabled (and probably other properties)\r\n        if (this.scaleMode === ScaleModes.NEAREST)\r\n        {\r\n            Smoothing.disable(this.gameContext);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * A NOOP method for handling lost context. Intentionally empty.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#onContextLost\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} callback - Ignored parameter.\r\n     */\r\n    onContextLost: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * A NOOP method for handling restored context. Intentionally empty.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#onContextRestored\r\n     * @since 3.0.0\r\n     *\r\n     * @param {function} callback - Ignored parameter.\r\n     */\r\n    onContextRestored: function ()\r\n    {\r\n    },\r\n\r\n    /**\r\n     * Resets the transformation matrix of the current context to the identity matrix, thus resetting any transformation.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#resetTransform\r\n     * @since 3.0.0\r\n     */\r\n    resetTransform: function ()\r\n    {\r\n        this.currentContext.setTransform(1, 0, 0, 1, 0, 0);\r\n    },\r\n\r\n    /**\r\n     * Sets the blend mode (compositing operation) of the current context.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#setBlendMode\r\n     * @since 3.0.0\r\n     *\r\n     * @param {string} blendMode - The new blend mode which should be used.\r\n     *\r\n     * @return {this} This CanvasRenderer object.\r\n     */\r\n    setBlendMode: function (blendMode)\r\n    {\r\n        this.currentContext.globalCompositeOperation = blendMode;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Changes the Canvas Rendering Context that all draw operations are performed against.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#setContext\r\n     * @since 3.12.0\r\n     *\r\n     * @param {?CanvasRenderingContext2D} [ctx] - The new Canvas Rendering Context to draw everything to. Leave empty to reset to the Game Canvas.\r\n     *\r\n     * @return {this} The Canvas Renderer instance.\r\n     */\r\n    setContext: function (ctx)\r\n    {\r\n        this.currentContext = (ctx) ? ctx : this.gameContext;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Sets the global alpha of the current context.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#setAlpha\r\n     * @since 3.0.0\r\n     *\r\n     * @param {number} alpha - The new alpha to use, where 0 is fully transparent and 1 is fully opaque.\r\n     *\r\n     * @return {this} This CanvasRenderer object.\r\n     */\r\n    setAlpha: function (alpha)\r\n    {\r\n        this.currentContext.globalAlpha = alpha;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Called at the start of the render loop.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#preRender\r\n     * @since 3.0.0\r\n     */\r\n    preRender: function ()\r\n    {\r\n        var ctx = this.gameContext;\r\n        var config = this.config;\r\n\r\n        var width = this.width;\r\n        var height = this.height;\r\n\r\n        ctx.globalAlpha = 1;\r\n        ctx.globalCompositeOperation = 'source-over';\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n\r\n        if (config.clearBeforeRender)\r\n        {\r\n            ctx.clearRect(0, 0, width, height);\r\n        }\r\n\r\n        if (!config.transparent)\r\n        {\r\n            ctx.fillStyle = config.backgroundColor.rgba;\r\n            ctx.fillRect(0, 0, width, height);\r\n        }\r\n\r\n        ctx.save();\r\n\r\n        this.drawCount = 0;\r\n    },\r\n\r\n    /**\r\n     * Renders the Scene to the given Camera.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#render\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Scene} scene - The Scene to render.\r\n     * @param {Phaser.GameObjects.DisplayList} children - The Game Objects within the Scene to be rendered.\r\n     * @param {number} interpolationPercentage - The interpolation percentage to apply. Currently unused.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Scene Camera to render with.\r\n     */\r\n    render: function (scene, children, interpolationPercentage, camera)\r\n    {\r\n        var list = children.list;\r\n        var childCount = list.length;\r\n\r\n        var cx = camera._cx;\r\n        var cy = camera._cy;\r\n        var cw = camera._cw;\r\n        var ch = camera._ch;\r\n\r\n        var ctx = (camera.renderToTexture) ? camera.context : scene.sys.context;\r\n\r\n        //  Save context pre-clip\r\n        ctx.save();\r\n\r\n        if (this.game.scene.customViewports)\r\n        {\r\n            ctx.beginPath();\r\n            ctx.rect(cx, cy, cw, ch);\r\n            ctx.clip();\r\n        }\r\n\r\n        this.currentContext = ctx;\r\n\r\n        var mask = camera.mask;\r\n\r\n        if (mask)\r\n        {\r\n            mask.preRenderCanvas(this, null, camera._maskCamera);\r\n        }\r\n\r\n        if (!camera.transparent)\r\n        {\r\n            ctx.fillStyle = camera.backgroundColor.rgba;\r\n            ctx.fillRect(cx, cy, cw, ch);\r\n        }\r\n\r\n        ctx.globalAlpha = camera.alpha;\r\n\r\n        ctx.globalCompositeOperation = 'source-over';\r\n\r\n        this.drawCount += list.length;\r\n\r\n        if (camera.renderToTexture)\r\n        {\r\n            camera.emit(CameraEvents.PRE_RENDER, camera);\r\n        }\r\n\r\n        camera.matrix.copyToContext(ctx);\r\n\r\n        for (var i = 0; i < childCount; i++)\r\n        {\r\n            var child = list[i];\r\n\r\n            if (!child.willRender(camera))\r\n            {\r\n                continue;\r\n            }\r\n\r\n            if (child.mask)\r\n            {\r\n                child.mask.preRenderCanvas(this, child, camera);\r\n            }\r\n\r\n            child.renderCanvas(this, child, interpolationPercentage, camera);\r\n\r\n            if (child.mask)\r\n            {\r\n                child.mask.postRenderCanvas(this, child, camera);\r\n            }\r\n        }\r\n\r\n        ctx.setTransform(1, 0, 0, 1, 0, 0);\r\n        ctx.globalCompositeOperation = 'source-over';\r\n        ctx.globalAlpha = 1;\r\n\r\n        camera.flashEffect.postRenderCanvas(ctx);\r\n        camera.fadeEffect.postRenderCanvas(ctx);\r\n\r\n        camera.dirty = false;\r\n\r\n        if (mask)\r\n        {\r\n            mask.postRenderCanvas(this);\r\n        }\r\n\r\n        //  Restore pre-clip context\r\n        ctx.restore();\r\n\r\n        if (camera.renderToTexture)\r\n        {\r\n            camera.emit(CameraEvents.POST_RENDER, camera);\r\n\r\n            scene.sys.context.drawImage(camera.canvas, cx, cy);\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Restores the game context's global settings and takes a snapshot if one is scheduled.\r\n     *\r\n     * The post-render step happens after all Cameras in all Scenes have been rendered.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#postRender\r\n     * @since 3.0.0\r\n     */\r\n    postRender: function ()\r\n    {\r\n        var ctx = this.gameContext;\r\n\r\n        ctx.restore();\r\n\r\n        var state = this.snapshotState;\r\n\r\n        if (state.callback)\r\n        {\r\n            CanvasSnapshot(this.gameCanvas, state);\r\n\r\n            state.callback = null;\r\n        }\r\n    },\r\n\r\n    /**\r\n     * Schedules a snapshot of the entire game viewport to be taken after the current frame is rendered.\r\n     * \r\n     * To capture a specific area see the `snapshotArea` method. To capture a specific pixel, see `snapshotPixel`.\r\n     * \r\n     * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then\r\n     * calling this method will override it.\r\n     * \r\n     * Snapshots work by creating an Image object from the canvas data, this is a blocking process, which gets\r\n     * more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#snapshot\r\n     * @since 3.0.0\r\n     *\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n     *\r\n     * @return {this} This WebGL Renderer.\r\n     */\r\n    snapshot: function (callback, type, encoderOptions)\r\n    {\r\n        return this.snapshotArea(0, 0, this.gameCanvas.width, this.gameCanvas.height, callback, type, encoderOptions);\r\n    },\r\n\r\n    /**\r\n     * Schedules a snapshot of the given area of the game viewport to be taken after the current frame is rendered.\r\n     * \r\n     * To capture the whole game viewport see the `snapshot` method. To capture a specific pixel, see `snapshotPixel`.\r\n     * \r\n     * Only one snapshot can be active _per frame_. If you have already called `snapshotPixel`, for example, then\r\n     * calling this method will override it.\r\n     * \r\n     * Snapshots work by creating an Image object from the canvas data, this is a blocking process, which gets\r\n     * more expensive the larger the canvas size gets, so please be careful how you employ this in your game.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#snapshotArea\r\n     * @since 3.16.0\r\n     *\r\n     * @param {integer} x - The x coordinate to grab from.\r\n     * @param {integer} y - The y coordinate to grab from.\r\n     * @param {integer} width - The width of the area to grab.\r\n     * @param {integer} height - The height of the area to grab.\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot image is created.\r\n     * @param {string} [type='image/png'] - The format of the image to create, usually `image/png` or `image/jpeg`.\r\n     * @param {number} [encoderOptions=0.92] - The image quality, between 0 and 1. Used for image formats with lossy compression, such as `image/jpeg`.\r\n     *\r\n     * @return {this} This WebGL Renderer.\r\n     */\r\n    snapshotArea: function (x, y, width, height, callback, type, encoderOptions)\r\n    {\r\n        var state = this.snapshotState;\r\n\r\n        state.callback = callback;\r\n        state.type = type;\r\n        state.encoder = encoderOptions;\r\n        state.getPixel = false;\r\n        state.x = x;\r\n        state.y = y;\r\n        state.width = Math.min(width, this.gameCanvas.width);\r\n        state.height = Math.min(height, this.gameCanvas.height);\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Schedules a snapshot of the given pixel from the game viewport to be taken after the current frame is rendered.\r\n     * \r\n     * To capture the whole game viewport see the `snapshot` method. To capture a specific area, see `snapshotArea`.\r\n     * \r\n     * Only one snapshot can be active _per frame_. If you have already called `snapshotArea`, for example, then\r\n     * calling this method will override it.\r\n     * \r\n     * Unlike the other two snapshot methods, this one will return a `Color` object containing the color data for\r\n     * the requested pixel. It doesn't need to create an internal Canvas or Image object, so is a lot faster to execute,\r\n     * using less memory.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#snapshotPixel\r\n     * @since 3.16.0\r\n     *\r\n     * @param {integer} x - The x coordinate of the pixel to get.\r\n     * @param {integer} y - The y coordinate of the pixel to get.\r\n     * @param {Phaser.Types.Renderer.Snapshot.SnapshotCallback} callback - The Function to invoke after the snapshot pixel data is extracted.\r\n     *\r\n     * @return {this} This WebGL Renderer.\r\n     */\r\n    snapshotPixel: function (x, y, callback)\r\n    {\r\n        this.snapshotArea(x, y, 1, 1, callback);\r\n\r\n        this.snapshotState.getPixel = true;\r\n\r\n        return this;\r\n    },\r\n\r\n    /**\r\n     * Takes a Sprite Game Object, or any object that extends it, and draws it to the current context.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#batchSprite\r\n     * @since 3.12.0\r\n     *\r\n     * @param {Phaser.GameObjects.GameObject} sprite - The texture based Game Object to draw.\r\n     * @param {Phaser.Textures.Frame} frame - The frame to draw, doesn't have to be that owned by the Game Object.\r\n     * @param {Phaser.Cameras.Scene2D.Camera} camera - The Camera to use for the rendering transform.\r\n     * @param {Phaser.GameObjects.Components.TransformMatrix} [parentTransformMatrix] - The transform matrix of the parent container, if set.\r\n     */\r\n    batchSprite: function (sprite, frame, camera, parentTransformMatrix)\r\n    {\r\n        var alpha = camera.alpha * sprite.alpha;\r\n\r\n        if (alpha === 0)\r\n        {\r\n            //  Nothing to see, so abort early\r\n            return;\r\n        }\r\n    \r\n        var ctx = this.currentContext;\r\n\r\n        var camMatrix = this._tempMatrix1;\r\n        var spriteMatrix = this._tempMatrix2;\r\n        var calcMatrix = this._tempMatrix3;\r\n\r\n        var cd = frame.canvasData;\r\n\r\n        var frameX = cd.x;\r\n        var frameY = cd.y;\r\n        var frameWidth = frame.cutWidth;\r\n        var frameHeight = frame.cutHeight;\r\n        var res = frame.source.resolution;\r\n\r\n        var x = -sprite.displayOriginX + frame.x;\r\n        var y = -sprite.displayOriginY + frame.y;\r\n\r\n        var fx = (sprite.flipX) ? -1 : 1;\r\n        var fy = (sprite.flipY) ? -1 : 1;\r\n    \r\n        if (sprite.isCropped)\r\n        {\r\n            var crop = sprite._crop;\r\n\r\n            if (crop.flipX !== sprite.flipX || crop.flipY !== sprite.flipY)\r\n            {\r\n                frame.updateCropUVs(crop, sprite.flipX, sprite.flipY);\r\n            }\r\n\r\n            frameWidth = crop.cw;\r\n            frameHeight = crop.ch;\r\n    \r\n            frameX = crop.cx;\r\n            frameY = crop.cy;\r\n\r\n            x = -sprite.displayOriginX + crop.x;\r\n            y = -sprite.displayOriginY + crop.y;\r\n\r\n            if (fx === -1)\r\n            {\r\n                if (x >= 0)\r\n                {\r\n                    x = -(x + frameWidth);\r\n                }\r\n                else if (x < 0)\r\n                {\r\n                    x = (Math.abs(x) - frameWidth);\r\n                }\r\n            }\r\n        \r\n            if (fy === -1)\r\n            {\r\n                if (y >= 0)\r\n                {\r\n                    y = -(y + frameHeight);\r\n                }\r\n                else if (y < 0)\r\n                {\r\n                    y = (Math.abs(y) - frameHeight);\r\n                }\r\n            }\r\n        }\r\n\r\n        spriteMatrix.applyITRS(sprite.x, sprite.y, sprite.rotation, sprite.scaleX, sprite.scaleY);\r\n\r\n        camMatrix.copyFrom(camera.matrix);\r\n\r\n        if (parentTransformMatrix)\r\n        {\r\n            //  Multiply the camera by the parent matrix\r\n            camMatrix.multiplyWithOffset(parentTransformMatrix, -camera.scrollX * sprite.scrollFactorX, -camera.scrollY * sprite.scrollFactorY);\r\n\r\n            //  Undo the camera scroll\r\n            spriteMatrix.e = sprite.x;\r\n            spriteMatrix.f = sprite.y;\r\n\r\n            //  Multiply by the Sprite matrix, store result in calcMatrix\r\n            camMatrix.multiply(spriteMatrix, calcMatrix);\r\n        }\r\n        else\r\n        {\r\n            spriteMatrix.e -= camera.scrollX * sprite.scrollFactorX;\r\n            spriteMatrix.f -= camera.scrollY * sprite.scrollFactorY;\r\n    \r\n            //  Multiply by the Sprite matrix, store result in calcMatrix\r\n            camMatrix.multiply(spriteMatrix, calcMatrix);\r\n        }\r\n\r\n        ctx.save();\r\n       \r\n        calcMatrix.setToContext(ctx);\r\n\r\n        ctx.scale(fx, fy);\r\n\r\n        ctx.globalCompositeOperation = this.blendModes[sprite.blendMode];\r\n\r\n        ctx.globalAlpha = alpha;\r\n\r\n        ctx.drawImage(frame.source.image, frameX, frameY, frameWidth, frameHeight, x, y, frameWidth / res, frameHeight / res);\r\n\r\n        ctx.restore();\r\n    },\r\n\r\n    /**\r\n     * Destroys all object references in the Canvas Renderer.\r\n     *\r\n     * @method Phaser.Renderer.Canvas.CanvasRenderer#destroy\r\n     * @since 3.0.0\r\n     */\r\n    destroy: function ()\r\n    {\r\n        this.gameCanvas = null;\r\n        this.gameContext = null;\r\n\r\n        this.game = null;\r\n    }\r\n\r\n});\r\n\r\nmodule.exports = CanvasRenderer;\r\n"},"sourceMaps":null,"error":null,"hash":"05e00182882b7659c0cacca175c0793c","cacheData":{"env":{}}}