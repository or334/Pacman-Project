{"id":"../../node_modules/phaser/src/physics/arcade/ArcadePhysics.js","dependencies":[{"name":"C:\\Users\\דור\\Desktop\\pmm\\package.json","includedInParent":true,"mtime":1560952935180},{"name":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\package.json","includedInParent":true,"mtime":1561396619369},{"name":"../../utils/Class","loc":{"line":7,"column":20},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\ArcadePhysics.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\Class.js"},{"name":"../../math/DegToRad","loc":{"line":8,"column":23},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\ArcadePhysics.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\math\\DegToRad.js"},{"name":"../../math/distance/DistanceBetween","loc":{"line":9,"column":30},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\ArcadePhysics.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\math\\distance\\DistanceBetween.js"},{"name":"../../math/distance/DistanceSquared","loc":{"line":10,"column":30},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\ArcadePhysics.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\math\\distance\\DistanceSquared.js"},{"name":"./Factory","loc":{"line":11,"column":22},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\ArcadePhysics.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\Factory.js"},{"name":"../../utils/object/GetFastValue","loc":{"line":12,"column":27},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\ArcadePhysics.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\object\\GetFastValue.js"},{"name":"../../utils/object/Merge","loc":{"line":13,"column":20},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\ArcadePhysics.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\object\\Merge.js"},{"name":"./components/OverlapRect","loc":{"line":14,"column":26},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\ArcadePhysics.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\components\\OverlapRect.js"},{"name":"../../plugins/PluginCache","loc":{"line":15,"column":26},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\ArcadePhysics.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\plugins\\PluginCache.js"},{"name":"../../scene/events","loc":{"line":16,"column":26},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\ArcadePhysics.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\scene\\events\\index.js"},{"name":"../../math/Vector2","loc":{"line":17,"column":22},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\ArcadePhysics.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\math\\Vector2.js"},{"name":"./World","loc":{"line":18,"column":20},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\ArcadePhysics.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\World.js"}],"generated":{"js":"/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar Class = require('../../utils/Class');\nvar DegToRad = require('../../math/DegToRad');\nvar DistanceBetween = require('../../math/distance/DistanceBetween');\nvar DistanceSquared = require('../../math/distance/DistanceSquared');\nvar Factory = require('./Factory');\nvar GetFastValue = require('../../utils/object/GetFastValue');\nvar Merge = require('../../utils/object/Merge');\nvar OverlapRect = require('./components/OverlapRect');\nvar PluginCache = require('../../plugins/PluginCache');\nvar SceneEvents = require('../../scene/events');\nvar Vector2 = require('../../math/Vector2');\nvar World = require('./World');\n\n/**\n * @classdesc\n * The Arcade Physics Plugin belongs to a Scene and sets up and manages the Scene's physics simulation.\n * It also holds some useful methods for moving and rotating Arcade Physics Bodies.\n *\n * You can access it from within a Scene using `this.physics`.\n * \n * Arcade Physics uses the Projection Method of collision resolution and separation. While it's fast and suitable\n * for 'arcade' style games it lacks stability when multiple objects are in close proximity or resting upon each other.\n * The separation that stops two objects penetrating may create a new penetration against a different object. If you\n * require a high level of stability please consider using an alternative physics system, such as Matter.js.\n *\n * @class ArcadePhysics\n * @memberof Phaser.Physics.Arcade\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.Scene} scene - The Scene that this Plugin belongs to.\n */\nvar ArcadePhysics = new Class({\n\n    initialize:\n\n    function ArcadePhysics (scene)\n    {\n        /**\n         * The Scene that this Plugin belongs to.\n         *\n         * @name Phaser.Physics.Arcade.ArcadePhysics#scene\n         * @type {Phaser.Scene}\n         * @since 3.0.0\n         */\n        this.scene = scene;\n\n        /**\n         * The Scene's Systems.\n         *\n         * @name Phaser.Physics.Arcade.ArcadePhysics#systems\n         * @type {Phaser.Scenes.Systems}\n         * @since 3.0.0\n         */\n        this.systems = scene.sys;\n\n        /**\n         * A configuration object. Union of the `physics.arcade.*` properties of the GameConfig and SceneConfig objects.\n         *\n         * @name Phaser.Physics.Arcade.ArcadePhysics#config\n         * @type {object}\n         * @since 3.0.0\n         */\n        this.config = this.getConfig();\n\n        /**\n         * The physics simulation.\n         *\n         * @name Phaser.Physics.Arcade.ArcadePhysics#world\n         * @type {Phaser.Physics.Arcade.World}\n         * @since 3.0.0\n         */\n        this.world;\n\n        /**\n         * An object holding the Arcade Physics factory methods.\n         *\n         * @name Phaser.Physics.Arcade.ArcadePhysics#add\n         * @type {Phaser.Physics.Arcade.Factory}\n         * @since 3.0.0\n         */\n        this.add;\n\n        scene.sys.events.once(SceneEvents.BOOT, this.boot, this);\n        scene.sys.events.on(SceneEvents.START, this.start, this);\n    },\n\n    /**\n     * This method is called automatically, only once, when the Scene is first created.\n     * Do not invoke it directly.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#boot\n     * @private\n     * @since 3.5.1\n     */\n    boot: function ()\n    {\n        this.world = new World(this.scene, this.config);\n        this.add = new Factory(this.world);\n\n        this.systems.events.once(SceneEvents.DESTROY, this.destroy, this);\n    },\n\n    /**\n     * This method is called automatically by the Scene when it is starting up.\n     * It is responsible for creating local systems, properties and listening for Scene events.\n     * Do not invoke it directly.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#start\n     * @private\n     * @since 3.5.0\n     */\n    start: function ()\n    {\n        if (!this.world)\n        {\n            this.world = new World(this.scene, this.config);\n            this.add = new Factory(this.world);\n        }\n\n        var eventEmitter = this.systems.events;\n\n        eventEmitter.on(SceneEvents.UPDATE, this.world.update, this.world);\n        eventEmitter.on(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);\n        eventEmitter.once(SceneEvents.SHUTDOWN, this.shutdown, this);\n    },\n\n    /**\n     * Creates the physics configuration for the current Scene.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#getConfig\n     * @since 3.0.0\n     *\n     * @return {object} The physics configuration.\n     */\n    getConfig: function ()\n    {\n        var gameConfig = this.systems.game.config.physics;\n        var sceneConfig = this.systems.settings.physics;\n\n        var config = Merge(\n            GetFastValue(sceneConfig, 'arcade', {}),\n            GetFastValue(gameConfig, 'arcade', {})\n        );\n\n        return config;\n    },\n\n    /**\n     * Tests if Game Objects overlap. See {@link Phaser.Physics.Arcade.World#overlap}\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#overlap\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they overlap. If this is set then `collideCallback` will only be called if this callback returns `true`.\n     * @param {*} [callbackContext] - The context in which to run the callbacks.\n     *\n     * @return {boolean} True if at least one Game Object overlaps another.\n     *\n     * @see Phaser.Physics.Arcade.World#overlap\n     */\n    overlap: function (object1, object2, overlapCallback, processCallback, callbackContext)\n    {\n        if (overlapCallback === undefined) { overlapCallback = null; }\n        if (processCallback === undefined) { processCallback = null; }\n        if (callbackContext === undefined) { callbackContext = overlapCallback; }\n\n        return this.world.collideObjects(object1, object2, overlapCallback, processCallback, callbackContext, true);\n    },\n\n    /**\n     * Performs a collision check and separation between the two physics enabled objects given, which can be single\n     * Game Objects, arrays of Game Objects, Physics Groups, arrays of Physics Groups or normal Groups.\n     *\n     * If you don't require separation then use {@link #overlap} instead.\n     *\n     * If two Groups or arrays are passed, each member of one will be tested against each member of the other.\n     *\n     * If **only** one Group is passed (as `object1`), each member of the Group will be collided against the other members.\n     * \n     * If **only** one Array is passed, the array is iterated and every element in it is tested against the others.\n     *\n     * Two callbacks can be provided. The `collideCallback` is invoked if a collision occurs and the two colliding\n     * objects are passed to it.\n     *\n     * Arcade Physics uses the Projection Method of collision resolution and separation. While it's fast and suitable\n     * for 'arcade' style games it lacks stability when multiple objects are in close proximity or resting upon each other.\n     * The separation that stops two objects penetrating may create a new penetration against a different object. If you\n     * require a high level of stability please consider using an alternative physics system, such as Matter.js.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#collide\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} object1 - The first object or array of objects to check.\n     * @param {Phaser.Types.Physics.Arcade.ArcadeColliderType} [object2] - The second object or array of objects to check, or `undefined`.\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\n     * @param {*} [callbackContext] - The context in which to run the callbacks.\n     *\n     * @return {boolean} True if any overlapping Game Objects were separated, otherwise false.\n     *\n     * @see Phaser.Physics.Arcade.World#collide\n     */\n    collide: function (object1, object2, collideCallback, processCallback, callbackContext)\n    {\n        if (collideCallback === undefined) { collideCallback = null; }\n        if (processCallback === undefined) { processCallback = null; }\n        if (callbackContext === undefined) { callbackContext = collideCallback; }\n\n        return this.world.collideObjects(object1, object2, collideCallback, processCallback, callbackContext, false);\n    },\n\n    /**\n     * This advanced method is specifically for testing for collision between a single Sprite and an array of Tile objects.\n     * \n     * You should generally use the `collide` method instead, with a Sprite vs. a Tilemap Layer, as that will perform\n     * tile filtering and culling for you, as well as handle the interesting face collision automatically.\n     * \n     * This method is offered for those who would like to check for collision with specific Tiles in a layer, without\n     * having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic collisions\n     * on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,\n     * you should filter them before passing them to this method.\n     * \n     * Important: Use of this method skips the `interesting faces` system that Tilemap Layers use. This means if you have\n     * say a row or column of tiles, and you jump into, or walk over them, it's possible to get stuck on the edges of the\n     * tiles as the interesting face calculations are skipped. However, for quick-fire small collision set tests on\n     * dynamic maps, this method can prove very useful.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#collideTiles\n     * @fires Phaser.Physics.Arcade.Events#TILE_COLLIDE\n     * @since 3.17.0\n     *\n     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\n     * @param {Phaser.Tilemaps.Tile[]} tiles - An array of Tiles to check for collision against.\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects collide.\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\n     *\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\n     */\n    collideTiles: function (sprite, tiles, collideCallback, processCallback, callbackContext)\n    {\n        return this.world.collideTiles(sprite, tiles, collideCallback, processCallback, callbackContext);\n    },\n\n    /**\n     * This advanced method is specifically for testing for overlaps between a single Sprite and an array of Tile objects.\n     * \n     * You should generally use the `overlap` method instead, with a Sprite vs. a Tilemap Layer, as that will perform\n     * tile filtering and culling for you, as well as handle the interesting face collision automatically.\n     * \n     * This method is offered for those who would like to check for overlaps with specific Tiles in a layer, without\n     * having to set any collision attributes on the tiles in question. This allows you to perform quick dynamic overlap\n     * tests on small sets of Tiles. As such, no culling or checks are made to the array of Tiles given to this method,\n     * you should filter them before passing them to this method.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#overlapTiles\n     * @fires Phaser.Physics.Arcade.Events#TILE_OVERLAP\n     * @since 3.17.0\n     *\n     * @param {Phaser.GameObjects.GameObject} sprite - The first object to check for collision.\n     * @param {Phaser.Tilemaps.Tile[]} tiles - An array of Tiles to check for collision against.\n     * @param {ArcadePhysicsCallback} [collideCallback] - An optional callback function that is called if the objects overlap.\n     * @param {ArcadePhysicsCallback} [processCallback] - An optional callback function that lets you perform additional checks against the two objects if they collide. If this is set then `collideCallback` will only be called if this callback returns `true`.\n     * @param {any} [callbackContext] - The context in which to run the callbacks.\n     *\n     * @return {boolean} True if any objects overlap (with `overlapOnly`); or true if any overlapping objects were separated.\n     */\n    overlapTiles: function (sprite, tiles, collideCallback, processCallback, callbackContext)\n    {\n        return this.world.overlapTiles(sprite, tiles, collideCallback, processCallback, callbackContext);\n    },\n\n    /**\n     * Pauses the simulation.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#pause\n     * @since 3.0.0\n     *\n     * @return {Phaser.Physics.Arcade.World} The simulation.\n     */\n    pause: function ()\n    {\n        return this.world.pause();\n    },\n\n    /**\n     * Resumes the simulation (if paused).\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#resume\n     * @since 3.0.0\n     *\n     * @return {Phaser.Physics.Arcade.World} The simulation.\n     */\n    resume: function ()\n    {\n        return this.world.resume();\n    },\n\n    /**\n     * Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given rate (in pixels per second squared)\n     *\n     * You must give a maximum speed value, beyond which the game object won't go any faster.\n     *\n     * Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course.\n     * Note: The game object doesn't stop moving once it reaches the destination coordinates.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#accelerateTo\n     * @since 3.0.0\n     *\n     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\n     * @param {number} x - The x coordinate to accelerate towards.\n     * @param {number} y - The y coordinate to accelerate towards.\n     * @param {number} [speed=60] - The acceleration (change in speed) in pixels per second squared.\n     * @param {number} [xSpeedMax=500] - The maximum x velocity the game object can reach.\n     * @param {number} [ySpeedMax=500] - The maximum y velocity the game object can reach.\n     *\n     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\n     */\n    accelerateTo: function (gameObject, x, y, speed, xSpeedMax, ySpeedMax)\n    {\n        if (speed === undefined) { speed = 60; }\n\n        var angle = Math.atan2(y - gameObject.y, x - gameObject.x);\n\n        gameObject.body.acceleration.setToPolar(angle, speed);\n\n        if (xSpeedMax !== undefined && ySpeedMax !== undefined)\n        {\n            gameObject.body.maxVelocity.set(xSpeedMax, ySpeedMax);\n        }\n\n        return angle;\n    },\n\n    /**\n     * Sets the acceleration.x/y property on the game object so it will move towards the x/y coordinates at the given rate (in pixels per second squared)\n     *\n     * You must give a maximum speed value, beyond which the game object won't go any faster.\n     *\n     * Note: The game object does not continuously track the target. If the target changes location during transit the game object will not modify its course.\n     * Note: The game object doesn't stop moving once it reaches the destination coordinates.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#accelerateToObject\n     * @since 3.0.0\n     *\n     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\n     * @param {Phaser.GameObjects.GameObject} destination - The Game Object to move towards. Can be any object but must have visible x/y properties.\n     * @param {number} [speed=60] - The acceleration (change in speed) in pixels per second squared.\n     * @param {number} [xSpeedMax=500] - The maximum x velocity the game object can reach.\n     * @param {number} [ySpeedMax=500] - The maximum y velocity the game object can reach.\n     *\n     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\n     */\n    accelerateToObject: function (gameObject, destination, speed, xSpeedMax, ySpeedMax)\n    {\n        return this.accelerateTo(gameObject, destination.x, destination.y, speed, xSpeedMax, ySpeedMax);\n    },\n\n    /**\n     * Finds the Dynamic Body closest to a source point or object.\n     * \n     * If two or more bodies are the exact same distance from the source point, only the first body\n     * is returned.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#closest\n     * @since 3.0.0\n     *\n     * @param {any} source - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\n     *\n     * @return {Phaser.Physics.Arcade.Body} The closest Dynamic Body to the given source point.\n     */\n    closest: function (source)\n    {\n        var bodies = this.world.bodies;\n\n        var min = Number.MAX_VALUE;\n        var closest = null;\n        var x = source.x;\n        var y = source.y;\n\n        bodies.iterate(function (target)\n        {\n            var distance = DistanceSquared(x, y, target.x, target.y);\n\n            if (distance < min)\n            {\n                closest = target;\n                min = distance;\n            }\n\n        });\n\n        return closest;\n    },\n\n    /**\n     * Finds the Dynamic Body farthest from a source point or object.\n     * \n     * If two or more bodies are the exact same distance from the source point, only the first body\n     * is returned.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#furthest\n     * @since 3.0.0\n     *\n     * @param {any} source - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\n     *\n     * @return {Phaser.Physics.Arcade.Body} The Dynamic Body furthest away from the given source point.\n     */\n    furthest: function (source)\n    {\n        var bodies = this.world.bodies;\n\n        var max = -1;\n        var farthest = null;\n        var x = source.x;\n        var y = source.y;\n\n        bodies.iterate(function (target)\n        {\n            var distance = DistanceSquared(x, y, target.x, target.y);\n\n            if (distance > max)\n            {\n                farthest = target;\n                max = distance;\n            }\n\n        });\n\n        return farthest;\n    },\n\n    /**\n     * Move the given display object towards the x/y coordinates at a steady velocity.\n     * If you specify a maxTime then it will adjust the speed (over-writing what you set) so it arrives at the destination in that number of seconds.\n     * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\n     * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\n     * Note: The display object doesn't stop moving once it reaches the destination coordinates.\n     * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#moveTo\n     * @since 3.0.0\n     *\n     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\n     * @param {number} x - The x coordinate to move towards.\n     * @param {number} y - The y coordinate to move towards.\n     * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)\n     * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.\n     *\n     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\n     */\n    moveTo: function (gameObject, x, y, speed, maxTime)\n    {\n        if (speed === undefined) { speed = 60; }\n        if (maxTime === undefined) { maxTime = 0; }\n\n        var angle = Math.atan2(y - gameObject.y, x - gameObject.x);\n\n        if (maxTime > 0)\n        {\n            //  We know how many pixels we need to move, but how fast?\n            speed = DistanceBetween(gameObject.x, gameObject.y, x, y) / (maxTime / 1000);\n        }\n\n        gameObject.body.velocity.setToPolar(angle, speed);\n\n        return angle;\n    },\n\n    /**\n     * Move the given display object towards the destination object at a steady velocity.\n     * If you specify a maxTime then it will adjust the speed (overwriting what you set) so it arrives at the destination in that number of seconds.\n     * Timings are approximate due to the way browser timers work. Allow for a variance of +- 50ms.\n     * Note: The display object does not continuously track the target. If the target changes location during transit the display object will not modify its course.\n     * Note: The display object doesn't stop moving once it reaches the destination coordinates.\n     * Note: Doesn't take into account acceleration, maxVelocity or drag (if you've set drag or acceleration too high this object may not move at all)\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#moveToObject\n     * @since 3.0.0\n     *\n     * @param {Phaser.GameObjects.GameObject} gameObject - Any Game Object with an Arcade Physics body.\n     * @param {object} destination - Any object with public `x` and `y` properties, such as a Game Object or Geometry object.\n     * @param {number} [speed=60] - The speed it will move, in pixels per second (default is 60 pixels/sec)\n     * @param {number} [maxTime=0] - Time given in milliseconds (1000 = 1 sec). If set the speed is adjusted so the object will arrive at destination in the given number of ms.\n     *\n     * @return {number} The angle (in radians) that the object should be visually set to in order to match its new velocity.\n     */\n    moveToObject: function (gameObject, destination, speed, maxTime)\n    {\n        return this.moveTo(gameObject, destination.x, destination.y, speed, maxTime);\n    },\n\n    /**\n     * Given the angle (in degrees) and speed calculate the velocity and return it as a vector, or set it to the given vector object.\n     * One way to use this is: velocityFromAngle(angle, 200, sprite.body.velocity) which will set the values directly to the sprite's velocity and not create a new vector object.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#velocityFromAngle\n     * @since 3.0.0\n     *\n     * @param {number} angle - The angle in degrees calculated in clockwise positive direction (down = 90 degrees positive, right = 0 degrees positive, up = 90 degrees negative)\n     * @param {number} [speed=60] - The speed it will move, in pixels per second squared.\n     * @param {Phaser.Math.Vector2} [vec2] - The Vector2 in which the x and y properties will be set to the calculated velocity.\n     *\n     * @return {Phaser.Math.Vector2} The Vector2 that stores the velocity.\n     */\n    velocityFromAngle: function (angle, speed, vec2)\n    {\n        if (speed === undefined) { speed = 60; }\n        if (vec2 === undefined) { vec2 = new Vector2(); }\n\n        return vec2.setToPolar(DegToRad(angle), speed);\n    },\n\n    /**\n     * Given the rotation (in radians) and speed calculate the velocity and return it as a vector, or set it to the given vector object.\n     * One way to use this is: velocityFromRotation(rotation, 200, sprite.body.velocity) which will set the values directly to the sprite's velocity and not create a new vector object.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#velocityFromRotation\n     * @since 3.0.0\n     *\n     * @param {number} rotation - The angle in radians.\n     * @param {number} [speed=60] - The speed it will move, in pixels per second squared\n     * @param {Phaser.Math.Vector2} [vec2] - The Vector2 in which the x and y properties will be set to the calculated velocity.\n     *\n     * @return {Phaser.Math.Vector2} The Vector2 that stores the velocity.\n     */\n    velocityFromRotation: function (rotation, speed, vec2)\n    {\n        if (speed === undefined) { speed = 60; }\n        if (vec2 === undefined) { vec2 = new Vector2(); }\n\n        return vec2.setToPolar(rotation, speed);\n    },\n\n    /**\n     * This method will search the given rectangular area and return an array of all physics bodies that\n     * overlap with it. It can return either Dynamic, Static bodies or a mixture of both.\n     * \n     * A body only has to intersect with the search area to be considered, it doesn't have to be fully\n     * contained within it.\n     * \n     * If Arcade Physics is set to use the RTree (which it is by default) then the search for is extremely fast,\n     * otherwise the search is O(N) for Dynamic Bodies.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#overlapRect\n     * @since 3.17.0\n     *\n     * @param {number} x - The top-left x coordinate of the area to search within.\n     * @param {number} y - The top-left y coordinate of the area to search within.\n     * @param {number} width - The width of the area to search within.\n     * @param {number} height - The height of the area to search within.\n     * @param {boolean} [includeDynamic=true] - Should the search include Dynamic Bodies?\n     * @param {boolean} [includeStatic=false] - Should the search include Static Bodies?\n     *\n     * @return {(Phaser.Physics.Arcade.Body[]|Phaser.Physics.Arcade.StaticBody[])} An array of bodies that overlap with the given area.\n     */\n    overlapRect: function (x, y, width, height, includeDynamic, includeStatic)\n    {\n        return OverlapRect(this.world, x, y, width, height, includeDynamic, includeStatic);\n    },\n    \n    /**\n     * The Scene that owns this plugin is shutting down.\n     * We need to kill and reset all internal properties as well as stop listening to Scene events.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#shutdown\n     * @since 3.0.0\n     */\n    shutdown: function ()\n    {\n        if (!this.world)\n        {\n            //  Already destroyed\n            return;\n        }\n\n        var eventEmitter = this.systems.events;\n\n        eventEmitter.off(SceneEvents.UPDATE, this.world.update, this.world);\n        eventEmitter.off(SceneEvents.POST_UPDATE, this.world.postUpdate, this.world);\n        eventEmitter.off(SceneEvents.SHUTDOWN, this.shutdown, this);\n\n        this.add.destroy();\n        this.world.destroy();\n\n        this.add = null;\n        this.world = null;\n    },\n\n    /**\n     * The Scene that owns this plugin is being destroyed.\n     * We need to shutdown and then kill off all external references.\n     *\n     * @method Phaser.Physics.Arcade.ArcadePhysics#destroy\n     * @since 3.0.0\n     */\n    destroy: function ()\n    {\n        this.shutdown();\n\n        this.scene.sys.events.off(SceneEvents.START, this.start, this);\n\n        this.scene = null;\n        this.systems = null;\n    }\n\n});\n\nPluginCache.register('ArcadePhysics', ArcadePhysics, 'arcadePhysics');\n\nmodule.exports = ArcadePhysics;\n"},"sourceMaps":null,"error":null,"hash":"fa315e8283b8746aa5966c72e0717fcc","cacheData":{"env":{}}}