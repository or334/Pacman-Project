{"id":"../../node_modules/phaser/src/physics/arcade/Body.js","dependencies":[{"name":"C:\\Users\\דור\\Desktop\\pmm\\package.json","includedInParent":true,"mtime":1560952935180},{"name":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\package.json","includedInParent":true,"mtime":1561396619369},{"name":"../../geom/circle/Contains","loc":{"line":7,"column":29},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\Body.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\geom\\circle\\Contains.js"},{"name":"../../utils/Class","loc":{"line":8,"column":20},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\Body.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\utils\\Class.js"},{"name":"./const","loc":{"line":9,"column":20},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\Body.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\const.js"},{"name":"./events","loc":{"line":10,"column":21},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\Body.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\events\\index.js"},{"name":"../../math/RadToDeg","loc":{"line":11,"column":23},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\Body.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\math\\RadToDeg.js"},{"name":"../../geom/rectangle/Rectangle","loc":{"line":12,"column":24},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\Body.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\geom\\rectangle\\Rectangle.js"},{"name":"../../geom/rectangle/Contains","loc":{"line":13,"column":32},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\Body.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\geom\\rectangle\\Contains.js"},{"name":"../../math/Vector2","loc":{"line":14,"column":22},"parent":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\physics\\arcade\\Body.js","resolved":"C:\\Users\\דור\\Desktop\\pmm\\node_modules\\phaser\\src\\math\\Vector2.js"}],"generated":{"js":"/**\n * @author       Richard Davey <rich@photonstorm.com>\n * @copyright    2019 Photon Storm Ltd.\n * @license      {@link https://opensource.org/licenses/MIT|MIT License}\n */\n\nvar CircleContains = require('../../geom/circle/Contains');\nvar Class = require('../../utils/Class');\nvar CONST = require('./const');\nvar Events = require('./events');\nvar RadToDeg = require('../../math/RadToDeg');\nvar Rectangle = require('../../geom/rectangle/Rectangle');\nvar RectangleContains = require('../../geom/rectangle/Contains');\nvar Vector2 = require('../../math/Vector2');\n\n/**\n * @classdesc\n * A Dynamic Arcade Body.\n *\n * Its static counterpart is {@link Phaser.Physics.Arcade.StaticBody}.\n *\n * @class Body\n * @memberof Phaser.Physics.Arcade\n * @constructor\n * @since 3.0.0\n *\n * @param {Phaser.Physics.Arcade.World} world - The Arcade Physics simulation this Body belongs to.\n * @param {Phaser.GameObjects.GameObject} gameObject - The Game Object this Body belongs to.\n */\nvar Body = new Class({\n\n    initialize:\n\n    function Body (world, gameObject)\n    {\n        var width = (gameObject.width) ? gameObject.width : 64;\n        var height = (gameObject.height) ? gameObject.height : 64;\n\n        /**\n         * The Arcade Physics simulation this Body belongs to.\n         *\n         * @name Phaser.Physics.Arcade.Body#world\n         * @type {Phaser.Physics.Arcade.World}\n         * @since 3.0.0\n         */\n        this.world = world;\n\n        /**\n         * The Game Object this Body belongs to.\n         *\n         * @name Phaser.Physics.Arcade.Body#gameObject\n         * @type {Phaser.GameObjects.GameObject}\n         * @since 3.0.0\n         */\n        this.gameObject = gameObject;\n\n        /**\n         * Transformations applied to this Body.\n         *\n         * @name Phaser.Physics.Arcade.Body#transform\n         * @type {object}\n         * @since 3.4.0\n         */\n        this.transform = {\n            x: gameObject.x,\n            y: gameObject.y,\n            rotation: gameObject.angle,\n            scaleX: gameObject.scaleX,\n            scaleY: gameObject.scaleY,\n            displayOriginX: gameObject.displayOriginX,\n            displayOriginY: gameObject.displayOriginY\n        };\n\n        /**\n         * Whether the Body's boundary is drawn to the debug display.\n         *\n         * @name Phaser.Physics.Arcade.Body#debugShowBody\n         * @type {boolean}\n         * @since 3.0.0\n         */\n        this.debugShowBody = world.defaults.debugShowBody;\n\n        /**\n         * Whether the Body's velocity is drawn to the debug display.\n         *\n         * @name Phaser.Physics.Arcade.Body#debugShowVelocity\n         * @type {boolean}\n         * @since 3.0.0\n         */\n        this.debugShowVelocity = world.defaults.debugShowVelocity;\n\n        /**\n         * The color of this Body on the debug display.\n         *\n         * @name Phaser.Physics.Arcade.Body#debugBodyColor\n         * @type {integer}\n         * @since 3.0.0\n         */\n        this.debugBodyColor = world.defaults.bodyDebugColor;\n\n        /**\n         * Whether this Body is updated by the physics simulation.\n         *\n         * @name Phaser.Physics.Arcade.Body#enable\n         * @type {boolean}\n         * @default true\n         * @since 3.0.0\n         */\n        this.enable = true;\n\n        /**\n         * Whether this Body's boundary is circular (true) or rectangular (false).\n         *\n         * @name Phaser.Physics.Arcade.Body#isCircle\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         * @see Phaser.Physics.Arcade.Body#setCircle\n         */\n        this.isCircle = false;\n\n        /**\n         * If this Body is circular, this is the unscaled radius of the Body's boundary, as set by setCircle(), in source pixels.\n         * The true radius is equal to `halfWidth`.\n         *\n         * @name Phaser.Physics.Arcade.Body#radius\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         * @see Phaser.Physics.Arcade.Body#setCircle\n         */\n        this.radius = 0;\n\n        /**\n         * The offset of this Body's position from its Game Object's position, in source pixels.\n         *\n         * @name Phaser.Physics.Arcade.Body#offset\n         * @type {Phaser.Math.Vector2}\n         * @since 3.0.0\n         * @see Phaser.Physics.Arcade.Body#setOffset\n         */\n        this.offset = new Vector2();\n\n        /**\n         * The position of this Body within the simulation.\n         *\n         * @name Phaser.Physics.Arcade.Body#position\n         * @type {Phaser.Math.Vector2}\n         * @since 3.0.0\n         */\n        this.position = new Vector2(gameObject.x, gameObject.y);\n\n        /**\n         * The position of this Body during the previous step.\n         *\n         * @name Phaser.Physics.Arcade.Body#prev\n         * @type {Phaser.Math.Vector2}\n         * @since 3.0.0\n         */\n        this.prev = new Vector2(gameObject.x, gameObject.y);\n\n        /**\n         * Whether this Body's `rotation` is affected by its angular acceleration and angular velocity.\n         *\n         * @name Phaser.Physics.Arcade.Body#allowRotation\n         * @type {boolean}\n         * @default true\n         * @since 3.0.0\n         */\n        this.allowRotation = true;\n\n        /**\n         * This body's rotation, in degrees, based on its angular acceleration and angular velocity.\n         * The Body's rotation controls the `angle` of its Game Object.\n         * It doesn't rotate the Body's boundary, which is always an axis-aligned rectangle or a circle.\n         *\n         * @name Phaser.Physics.Arcade.Body#rotation\n         * @type {number}\n         * @since 3.0.0\n         */\n        this.rotation = gameObject.angle;\n\n        /**\n         * The Body's rotation, in degrees, during the previous step.\n         *\n         * @name Phaser.Physics.Arcade.Body#preRotation\n         * @type {number}\n         * @since 3.0.0\n         */\n        this.preRotation = gameObject.angle;\n\n        /**\n         * The width of the Body's boundary, in pixels.\n         * If the Body is circular, this is also the Body's diameter.\n         *\n         * @name Phaser.Physics.Arcade.Body#width\n         * @type {number}\n         * @default 64\n         * @since 3.0.0\n         */\n        this.width = width;\n\n        /**\n         * The height of the Body's boundary, in pixels.\n         * If the Body is circular, this is also the Body's diameter.\n         *\n         * @name Phaser.Physics.Arcade.Body#height\n         * @type {number}\n         * @default 64\n         * @since 3.0.0\n         */\n        this.height = height;\n\n        /**\n         * The unscaled width of the Body, in source pixels, as set by setSize().\n         * The default is the width of the Body's Game Object's texture frame.\n         *\n         * @name Phaser.Physics.Arcade.Body#sourceWidth\n         * @type {number}\n         * @since 3.0.0\n         * @see Phaser.Physics.Arcade.Body#setSize\n         */\n        this.sourceWidth = width;\n\n        /**\n         * The unscaled height of the Body, in source pixels, as set by setSize().\n         * The default is the height of the Body's Game Object's texture frame.\n         *\n         * @name Phaser.Physics.Arcade.Body#sourceHeight\n         * @type {number}\n         * @since 3.0.0\n         * @see Phaser.Physics.Arcade.Body#setSize\n         */\n        this.sourceHeight = height;\n\n        if (gameObject.frame)\n        {\n            this.sourceWidth = gameObject.frame.realWidth;\n            this.sourceHeight = gameObject.frame.realHeight;\n        }\n\n        /**\n         * Half the Body's width, in pixels.\n         *\n         * @name Phaser.Physics.Arcade.Body#halfWidth\n         * @type {number}\n         * @since 3.0.0\n         */\n        this.halfWidth = Math.abs(width / 2);\n\n        /**\n         * Half the Body's height, in pixels.\n         *\n         * @name Phaser.Physics.Arcade.Body#halfHeight\n         * @type {number}\n         * @since 3.0.0\n         */\n        this.halfHeight = Math.abs(height / 2);\n\n        /**\n         * The center of the Body's boundary.\n         * The midpoint of its `position` (top-left corner) and its bottom-right corner.\n         *\n         * @name Phaser.Physics.Arcade.Body#center\n         * @type {Phaser.Math.Vector2}\n         * @since 3.0.0\n         */\n        this.center = new Vector2(gameObject.x + this.halfWidth, gameObject.y + this.halfHeight);\n\n        /**\n         * The Body's velocity, in pixels per second.\n         *\n         * @name Phaser.Physics.Arcade.Body#velocity\n         * @type {Phaser.Math.Vector2}\n         * @since 3.0.0\n         */\n        this.velocity = new Vector2();\n\n        /**\n         * The Body's calculated velocity, in pixels per second, at the last step.\n         *\n         * @name Phaser.Physics.Arcade.Body#newVelocity\n         * @type {Phaser.Math.Vector2}\n         * @readonly\n         * @since 3.0.0\n         */\n        this.newVelocity = new Vector2();\n\n        /**\n         * The Body's absolute maximum change in position, in pixels per step.\n         *\n         * @name Phaser.Physics.Arcade.Body#deltaMax\n         * @type {Phaser.Math.Vector2}\n         * @since 3.0.0\n         */\n        this.deltaMax = new Vector2();\n\n        /**\n         * The Body's change in velocity, in pixels per second squared.\n         *\n         * @name Phaser.Physics.Arcade.Body#acceleration\n         * @type {Phaser.Math.Vector2}\n         * @since 3.0.0\n         */\n        this.acceleration = new Vector2();\n\n        /**\n         * Whether this Body's velocity is affected by its `drag`.\n         *\n         * @name Phaser.Physics.Arcade.Body#allowDrag\n         * @type {boolean}\n         * @default true\n         * @since 3.0.0\n         */\n        this.allowDrag = true;\n\n        /**\n         * Absolute loss of velocity due to movement, in pixels per second squared.\n         * The x and y components are applied separately.\n         *\n         * When `useDamping` is true, this is 1 minus the damping factor.\n         * A value of 1 means the Body loses no velocity.\n         * A value of 0.95 means the Body loses 5% of its velocity per step.\n         * A value of 0.5 means the Body loses 50% of its velocity per step.\n         *\n         * Drag is applied only when `acceleration` is zero.\n         *\n         * @name Phaser.Physics.Arcade.Body#drag\n         * @type {(Phaser.Math.Vector2|number)}\n         * @since 3.0.0\n         */\n        this.drag = new Vector2();\n\n        /**\n         * Whether this Body's position is affected by gravity (local or world).\n         *\n         * @name Phaser.Physics.Arcade.Body#allowGravity\n         * @type {boolean}\n         * @default true\n         * @since 3.0.0\n         * @see Phaser.Physics.Arcade.Body#gravity\n         * @see Phaser.Physics.Arcade.World#gravity\n         */\n        this.allowGravity = true;\n\n        /**\n         * Acceleration due to gravity (specific to this Body), in pixels per second squared.\n         * Total gravity is the sum of this vector and the simulation's `gravity`.\n         *\n         * @name Phaser.Physics.Arcade.Body#gravity\n         * @type {Phaser.Math.Vector2}\n         * @since 3.0.0\n         * @see Phaser.Physics.Arcade.World#gravity\n         */\n        this.gravity = new Vector2();\n\n        /**\n         * Rebound following a collision, relative to 1.\n         *\n         * @name Phaser.Physics.Arcade.Body#bounce\n         * @type {Phaser.Math.Vector2}\n         * @since 3.0.0\n         */\n        this.bounce = new Vector2();\n\n        /**\n         * Rebound following a collision with the world boundary, relative to 1.\n         * If null, `bounce` is used instead.\n         *\n         * @name Phaser.Physics.Arcade.Body#worldBounce\n         * @type {?Phaser.Math.Vector2}\n         * @default null\n         * @since 3.0.0\n         */\n        this.worldBounce = null;\n\n        //  If true this Body will dispatch events\n\n        /**\n         * Whether the simulation emits a `worldbounds` event when this Body collides with the world boundary (and `collideWorldBounds` is also true).\n         *\n         * @name Phaser.Physics.Arcade.Body#onWorldBounds\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         * @see Phaser.Physics.Arcade.World#worldboundsEvent\n         */\n        this.onWorldBounds = false;\n\n        /**\n         * Whether the simulation emits a `collide` event when this Body collides with another.\n         *\n         * @name Phaser.Physics.Arcade.Body#onCollide\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         * @see Phaser.Physics.Arcade.World#collideEvent\n         */\n        this.onCollide = false;\n\n        /**\n         * Whether the simulation emits an `overlap` event when this Body overlaps with another.\n         *\n         * @name Phaser.Physics.Arcade.Body#onOverlap\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         * @see Phaser.Physics.Arcade.World#overlapEvent\n         */\n        this.onOverlap = false;\n\n        /**\n         * The Body's absolute maximum velocity, in pixels per second.\n         * The horizontal and vertical components are applied separately.\n         *\n         * @name Phaser.Physics.Arcade.Body#maxVelocity\n         * @type {Phaser.Math.Vector2}\n         * @since 3.0.0\n         */\n        this.maxVelocity = new Vector2(10000, 10000);\n\n        /**\n         * The maximum speed this Body is allowed to reach.\n         * \n         * If not negative it limits the scalar value of speed.\n         * \n         * Any negative value means no maximum is being applied.\n         * \n         * @name Phaser.Physics.Arcade.Body#maxSpeed\n         * @type {number}\n         * @since 3.16.0 \n         */\n        this.maxSpeed = -1;\n\n        /**\n         * If this Body is `immovable` and in motion, `friction` is the proportion of this Body's motion received by the riding Body on each axis, relative to 1.\n         * The default value (1, 0) moves the riding Body horizontally in equal proportion to this Body and vertically not at all.\n         * The horizontal component (x) is applied only when two colliding Bodies are separated vertically.\n         * The vertical component (y) is applied only when two colliding Bodies are separated horizontally.\n         *\n         * @name Phaser.Physics.Arcade.Body#friction\n         * @type {Phaser.Math.Vector2}\n         * @since 3.0.0\n         */\n        this.friction = new Vector2(1, 0);\n\n        /**\n         * If this Body is using `drag` for deceleration this property controls how the drag is applied.\n         * If set to `true` drag will use a damping effect rather than a linear approach. If you are\n         * creating a game where the Body moves freely at any angle (i.e. like the way the ship moves in\n         * the game Asteroids) then you will get a far smoother and more visually correct deceleration\n         * by using damping, avoiding the axis-drift that is prone with linear deceleration.\n         *\n         * If you enable this property then you should use far smaller `drag` values than with linear, as\n         * they are used as a multiplier on the velocity. Values such as 0.95 will give a nice slow\n         * deceleration, where-as smaller values, such as 0.5 will stop an object almost immediately.\n         *\n         * @name Phaser.Physics.Arcade.Body#useDamping\n         * @type {boolean}\n         * @default false\n         * @since 3.10.0\n         */\n        this.useDamping = false;\n\n        /**\n         * The rate of change of this Body's `rotation`, in degrees per second.\n         *\n         * @name Phaser.Physics.Arcade.Body#angularVelocity\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.angularVelocity = 0;\n\n        /**\n         * The Body's angular acceleration (change in angular velocity), in degrees per second squared.\n         *\n         * @name Phaser.Physics.Arcade.Body#angularAcceleration\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.angularAcceleration = 0;\n\n        /**\n         * Loss of angular velocity due to angular movement, in degrees per second.\n         *\n         * Angular drag is applied only when angular acceleration is zero.\n         *\n         * @name Phaser.Physics.Arcade.Body#angularDrag\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.angularDrag = 0;\n\n        /**\n         * The Body's maximum angular velocity, in degrees per second.\n         *\n         * @name Phaser.Physics.Arcade.Body#maxAngular\n         * @type {number}\n         * @default 1000\n         * @since 3.0.0\n         */\n        this.maxAngular = 1000;\n\n        /**\n         * The Body's inertia, relative to a default unit (1).\n         * With `bounce`, this affects the exchange of momentum (velocities) during collisions.\n         *\n         * @name Phaser.Physics.Arcade.Body#mass\n         * @type {number}\n         * @default 1\n         * @since 3.0.0\n         */\n        this.mass = 1;\n\n        /**\n         * The calculated angle of this Body's velocity vector, in degrees, during the last step.\n         *\n         * @name Phaser.Physics.Arcade.Body#angle\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.angle = 0;\n\n        /**\n         * The calculated magnitude of the Body's velocity, in pixels per second, during the last step.\n         *\n         * @name Phaser.Physics.Arcade.Body#speed\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.speed = 0;\n\n        /**\n         * The direction of the Body's velocity, as calculated during the last step.\n         * If the Body is moving on both axes (diagonally), this describes motion on the vertical axis only.\n         *\n         * @name Phaser.Physics.Arcade.Body#facing\n         * @type {integer}\n         * @since 3.0.0\n         */\n        this.facing = CONST.FACING_NONE;\n\n        /**\n         * Whether this Body can be moved by collisions with another Body.\n         *\n         * @name Phaser.Physics.Arcade.Body#immovable\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         */\n        this.immovable = false;\n\n        /**\n         * Whether the Body's position and rotation are affected by its velocity, acceleration, drag, and gravity.\n         *\n         * @name Phaser.Physics.Arcade.Body#moves\n         * @type {boolean}\n         * @default true\n         * @since 3.0.0\n         */\n        this.moves = true;\n\n        /**\n         * A flag disabling the default horizontal separation of colliding bodies.\n         * Pass your own `collideCallback` to the collider.\n         *\n         * @name Phaser.Physics.Arcade.Body#customSeparateX\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         */\n        this.customSeparateX = false;\n\n        /**\n         * A flag disabling the default vertical separation of colliding bodies.\n         * Pass your own `collideCallback` to the collider.\n         *\n         * @name Phaser.Physics.Arcade.Body#customSeparateY\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         */\n        this.customSeparateY = false;\n\n        /**\n         * The amount of horizontal overlap (before separation), if this Body is colliding with another.\n         *\n         * @name Phaser.Physics.Arcade.Body#overlapX\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.overlapX = 0;\n\n        /**\n         * The amount of vertical overlap (before separation), if this Body is colliding with another.\n         *\n         * @name Phaser.Physics.Arcade.Body#overlapY\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.overlapY = 0;\n\n        /**\n         * The amount of overlap (before separation), if this Body is circular and colliding with another circular body.\n         *\n         * @name Phaser.Physics.Arcade.Body#overlapR\n         * @type {number}\n         * @default 0\n         * @since 3.0.0\n         */\n        this.overlapR = 0;\n\n        /**\n         * Whether this Body is overlapped with another and both are not moving.\n         *\n         * @name Phaser.Physics.Arcade.Body#embedded\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         */\n        this.embedded = false;\n\n        /**\n         * Whether this Body interacts with the world boundary.\n         *\n         * @name Phaser.Physics.Arcade.Body#collideWorldBounds\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         */\n        this.collideWorldBounds = false;\n\n        /**\n         * Whether this Body is checked for collisions and for which directions.\n         * You can set `checkCollision.none = true` to disable collision checks.\n         *\n         * @name Phaser.Physics.Arcade.Body#checkCollision\n         * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}\n         * @since 3.0.0\n         */\n        this.checkCollision = { none: false, up: true, down: true, left: true, right: true };\n\n        /**\n         * Whether this Body is colliding with another and in which direction.\n         *\n         * @name Phaser.Physics.Arcade.Body#touching\n         * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}\n         * @since 3.0.0\n         */\n        this.touching = { none: true, up: false, down: false, left: false, right: false };\n\n        /**\n         * Whether this Body was colliding with another during the last step, and in which direction.\n         *\n         * @name Phaser.Physics.Arcade.Body#wasTouching\n         * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}\n         * @since 3.0.0\n         */\n        this.wasTouching = { none: true, up: false, down: false, left: false, right: false };\n\n        /**\n         * Whether this Body is colliding with a tile or the world boundary.\n         *\n         * @name Phaser.Physics.Arcade.Body#blocked\n         * @type {Phaser.Types.Physics.Arcade.ArcadeBodyCollision}\n         * @since 3.0.0\n         */\n        this.blocked = { none: true, up: false, down: false, left: false, right: false };\n\n        /**\n         * Whether to automatically synchronize this Body's dimensions to the dimensions of its Game Object's visual bounds.\n         *\n         * @name Phaser.Physics.Arcade.Body#syncBounds\n         * @type {boolean}\n         * @default false\n         * @since 3.0.0\n         * @see Phaser.GameObjects.Components.GetBounds#getBounds\n         */\n        this.syncBounds = false;\n\n        /**\n         * The Body's physics type (dynamic or static).\n         *\n         * @name Phaser.Physics.Arcade.Body#physicsType\n         * @type {integer}\n         * @readonly\n         * @default Phaser.Physics.Arcade.DYNAMIC_BODY\n         * @since 3.0.0\n         */\n        this.physicsType = CONST.DYNAMIC_BODY;\n\n        /**\n         * Whether the Body's position needs updating from its Game Object.\n         *\n         * @name Phaser.Physics.Arcade.Body#_reset\n         * @type {boolean}\n         * @private\n         * @default true\n         * @since 3.0.0\n         */\n        this._reset = true;\n\n        /**\n         * Cached horizontal scale of the Body's Game Object.\n         *\n         * @name Phaser.Physics.Arcade.Body#_sx\n         * @type {number}\n         * @private\n         * @since 3.0.0\n         */\n        this._sx = gameObject.scaleX;\n\n        /**\n         * Cached vertical scale of the Body's Game Object.\n         *\n         * @name Phaser.Physics.Arcade.Body#_sy\n         * @type {number}\n         * @private\n         * @since 3.0.0\n         */\n        this._sy = gameObject.scaleY;\n\n        /**\n         * The calculated change in the Body's horizontal position during the last step.\n         *\n         * @name Phaser.Physics.Arcade.Body#_dx\n         * @type {number}\n         * @private\n         * @default 0\n         * @since 3.0.0\n         */\n        this._dx = 0;\n\n        /**\n         * The calculated change in the Body's vertical position during the last step.\n         *\n         * @name Phaser.Physics.Arcade.Body#_dy\n         * @type {number}\n         * @private\n         * @default 0\n         * @since 3.0.0\n         */\n        this._dy = 0;\n\n        /**\n         * Stores the Game Object's bounds.\n         *\n         * @name Phaser.Physics.Arcade.Body#_bounds\n         * @type {Phaser.Geom.Rectangle}\n         * @private\n         * @since 3.0.0\n         */\n        this._bounds = new Rectangle();\n    },\n\n    /**\n     * Updates the Body's `transform`, `width`, `height`, and `center` from its Game Object.\n     * The Body's `position` isn't changed.\n     *\n     * @method Phaser.Physics.Arcade.Body#updateBounds\n     * @since 3.0.0\n     */\n    updateBounds: function ()\n    {\n        var sprite = this.gameObject;\n\n        //  Container?\n\n        var transform = this.transform;\n\n        if (sprite.parentContainer)\n        {\n            var matrix = sprite.getWorldTransformMatrix(this.world._tempMatrix, this.world._tempMatrix2);\n\n            transform.x = matrix.tx;\n            transform.y = matrix.ty;\n            transform.rotation = RadToDeg(matrix.rotation);\n            transform.scaleX = matrix.scaleX;\n            transform.scaleY = matrix.scaleY;\n            transform.displayOriginX = sprite.displayOriginX;\n            transform.displayOriginY = sprite.displayOriginY;\n        }\n        else\n        {\n            transform.x = sprite.x;\n            transform.y = sprite.y;\n            transform.rotation = sprite.angle;\n            transform.scaleX = sprite.scaleX;\n            transform.scaleY = sprite.scaleY;\n            transform.displayOriginX = sprite.displayOriginX;\n            transform.displayOriginY = sprite.displayOriginY;\n        }\n\n        var recalc = false;\n\n        if (this.syncBounds)\n        {\n            var b = sprite.getBounds(this._bounds);\n\n            this.width = b.width;\n            this.height = b.height;\n            recalc = true;\n        }\n        else\n        {\n            var asx = Math.abs(transform.scaleX);\n            var asy = Math.abs(transform.scaleY);\n\n            if (this._sx !== asx || this._sy !== asy)\n            {\n                this.width = this.sourceWidth * asx;\n                this.height = this.sourceHeight * asy;\n                this._sx = asx;\n                this._sy = asy;\n                recalc = true;\n            }\n        }\n\n        if (recalc)\n        {\n            this.halfWidth = Math.floor(this.width / 2);\n            this.halfHeight = Math.floor(this.height / 2);\n            this.updateCenter();\n        }\n    },\n\n    /**\n     * Updates the Body's `center` from its `position`, `width`, and `height`.\n     *\n     * @method Phaser.Physics.Arcade.Body#updateCenter\n     * @since 3.0.0\n     */\n    updateCenter: function ()\n    {\n        this.center.set(this.position.x + this.halfWidth, this.position.y + this.halfHeight);\n    },\n\n    /**\n     * Prepares the Body for a physics step by resetting all the states and syncing the position\n     * with the parent Game Object.\n     * \n     * This method is only ever called once per game step.\n     *\n     * @method Phaser.Physics.Arcade.Body#preUpdate\n     * @since 3.17.0\n     */\n    preUpdate: function ()\n    {\n        //  Store and reset collision flags\n        this.wasTouching.none = this.touching.none;\n        this.wasTouching.up = this.touching.up;\n        this.wasTouching.down = this.touching.down;\n        this.wasTouching.left = this.touching.left;\n        this.wasTouching.right = this.touching.right;\n\n        this.touching.none = true;\n        this.touching.up = false;\n        this.touching.down = false;\n        this.touching.left = false;\n        this.touching.right = false;\n\n        this.blocked.none = true;\n        this.blocked.up = false;\n        this.blocked.down = false;\n        this.blocked.left = false;\n        this.blocked.right = false;\n\n        this.overlapR = 0;\n        this.overlapX = 0;\n        this.overlapY = 0;\n\n        this.embedded = false;\n\n        //  Updates the transform values\n        this.updateBounds();\n\n        var sprite = this.transform;\n\n        this.position.x = sprite.x + sprite.scaleX * (this.offset.x - sprite.displayOriginX);\n        this.position.y = sprite.y + sprite.scaleY * (this.offset.y - sprite.displayOriginY);\n\n        this.updateCenter();\n\n        this.rotation = sprite.rotation;\n\n        this.preRotation = this.rotation;\n\n        if (this._reset)\n        {\n            this.prev.x = this.position.x;\n            this.prev.y = this.position.y;\n        }\n    },\n\n    /**\n     * Performs a single physics step and updates the body velocity, angle, speed and other\n     * properties.\n     * \n     * This method can be called multiple times per game step.\n     * \n     * The results are synced back to the Game Object in `postUpdate`.\n     *\n     * @method Phaser.Physics.Arcade.Body#update\n     * @fires Phaser.Physics.Arcade.World#worldbounds\n     * @since 3.0.0\n     *\n     * @param {number} delta - The delta time, in seconds, elapsed since the last frame.\n     */\n    update: function (delta)\n    {\n        if (this.moves)\n        {\n            this.world.updateMotion(this, delta);\n\n            var vx = this.velocity.x;\n            var vy = this.velocity.y;\n\n            this.newVelocity.set(vx * delta, vy * delta);\n\n            this.position.add(this.newVelocity);\n\n            this.updateCenter();\n\n            this.angle = Math.atan2(vy, vx);\n            this.speed = Math.sqrt(vx * vx + vy * vy);\n\n            //  Now the update will throw collision checks at the Body\n            //  And finally we'll integrate the new position back to the Sprite in postUpdate\n\n            if (this.collideWorldBounds && this.checkWorldBounds() && this.onWorldBounds)\n            {\n                this.world.emit(Events.WORLD_BOUNDS, this, this.blocked.up, this.blocked.down, this.blocked.left, this.blocked.right);\n            }\n        }\n\n        this._dx = this.position.x - this.prev.x;\n        this._dy = this.position.y - this.prev.y;\n    },\n\n    /**\n     * Feeds the Body results back into the parent Game Object.\n     * \n     * This method is only ever called once per game step.\n     *\n     * @method Phaser.Physics.Arcade.Body#postUpdate\n     * @since 3.0.0\n     */\n    postUpdate: function ()\n    {\n        var dx = this.position.x - this.prev.x;\n        var dy = this.position.y - this.prev.y;\n\n        if (this.moves)\n        {\n            var mx = this.deltaMax.x;\n            var my = this.deltaMax.y;\n\n            if (mx !== 0 && dx !== 0)\n            {\n                if (dx < 0 && dx < -mx)\n                {\n                    dx = -mx;\n                }\n                else if (dx > 0 && dx > mx)\n                {\n                    dx = mx;\n                }\n            }\n\n            if (my !== 0 && dy !== 0)\n            {\n                if (dy < 0 && dy < -my)\n                {\n                    dy = -my;\n                }\n                else if (dy > 0 && dy > my)\n                {\n                    dy = my;\n                }\n            }\n\n            this.gameObject.x += dx;\n            this.gameObject.y += dy;\n\n            this._reset = true;\n        }\n\n        if (dx < 0)\n        {\n            this.facing = CONST.FACING_LEFT;\n        }\n        else if (dx > 0)\n        {\n            this.facing = CONST.FACING_RIGHT;\n        }\n\n        if (dy < 0)\n        {\n            this.facing = CONST.FACING_UP;\n        }\n        else if (dy > 0)\n        {\n            this.facing = CONST.FACING_DOWN;\n        }\n\n        this._dx = dx;\n        this._dy = dy;\n\n        if (this.allowRotation)\n        {\n            this.gameObject.angle += this.deltaZ();\n        }\n\n        this.prev.x = this.position.x;\n        this.prev.y = this.position.y;\n    },\n\n    /**\n     * Checks for collisions between this Body and the world boundary and separates them.\n     *\n     * @method Phaser.Physics.Arcade.Body#checkWorldBounds\n     * @since 3.0.0\n     *\n     * @return {boolean} True if this Body is colliding with the world boundary.\n     */\n    checkWorldBounds: function ()\n    {\n        var pos = this.position;\n        var bounds = this.world.bounds;\n        var check = this.world.checkCollision;\n\n        var bx = (this.worldBounce) ? -this.worldBounce.x : -this.bounce.x;\n        var by = (this.worldBounce) ? -this.worldBounce.y : -this.bounce.y;\n\n        if (pos.x < bounds.x && check.left)\n        {\n            pos.x = bounds.x;\n            this.velocity.x *= bx;\n            this.blocked.left = true;\n            this.blocked.none = false;\n        }\n        else if (this.right > bounds.right && check.right)\n        {\n            pos.x = bounds.right - this.width;\n            this.velocity.x *= bx;\n            this.blocked.right = true;\n            this.blocked.none = false;\n        }\n\n        if (pos.y < bounds.y && check.up)\n        {\n            pos.y = bounds.y;\n            this.velocity.y *= by;\n            this.blocked.up = true;\n            this.blocked.none = false;\n        }\n        else if (this.bottom > bounds.bottom && check.down)\n        {\n            pos.y = bounds.bottom - this.height;\n            this.velocity.y *= by;\n            this.blocked.down = true;\n            this.blocked.none = false;\n        }\n\n        return !this.blocked.none;\n    },\n\n    /**\n     * Sets the offset of the Body's position from its Game Object's position.\n     *\n     * @method Phaser.Physics.Arcade.Body#setOffset\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal offset, in source pixels.\n     * @param {number} [y=x] - The vertical offset, in source pixels.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setOffset: function (x, y)\n    {\n        if (y === undefined) { y = x; }\n\n        this.offset.set(x, y);\n\n        return this;\n    },\n\n    /**\n     * Sizes and positions this Body's boundary, as a rectangle.\n     * Modifies the Body `offset` if `center` is true (the default).\n     * Resets the width and height to match current frame, if no width and height provided and a frame is found.\n     *\n     * @method Phaser.Physics.Arcade.Body#setSize\n     * @since 3.0.0\n     *\n     * @param {integer} [width] - The width of the Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame width.\n     * @param {integer} [height] - The height of the Body in pixels. Cannot be zero. If not given, and the parent Game Object has a frame, it will use the frame height.\n     * @param {boolean} [center=true] - Modify the Body's `offset`, placing the Body's center on its Game Object's center. Only works if the Game Object has the `getCenter` method.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setSize: function (width, height, center)\n    {\n        if (center === undefined) { center = true; }\n\n        var gameObject = this.gameObject;\n\n        if (!width && gameObject.frame)\n        {\n            width = gameObject.frame.realWidth;\n        }\n\n        if (!height && gameObject.frame)\n        {\n            height = gameObject.frame.realHeight;\n        }\n\n        this.sourceWidth = width;\n        this.sourceHeight = height;\n\n        this.width = this.sourceWidth * this._sx;\n        this.height = this.sourceHeight * this._sy;\n\n        this.halfWidth = Math.floor(this.width / 2);\n        this.halfHeight = Math.floor(this.height / 2);\n\n        this.updateCenter();\n\n        if (center && gameObject.getCenter)\n        {\n            var ox = gameObject.displayWidth / 2;\n            var oy = gameObject.displayHeight / 2;\n\n            this.offset.set(ox - this.halfWidth, oy - this.halfHeight);\n        }\n\n        this.isCircle = false;\n        this.radius = 0;\n\n        return this;\n    },\n\n    /**\n     * Sizes and positions this Body's boundary, as a circle.\n     *\n     * @method Phaser.Physics.Arcade.Body#setCircle\n     * @since 3.0.0\n     *\n     * @param {number} radius - The radius of the Body, in source pixels.\n     * @param {number} [offsetX] - The horizontal offset of the Body from its Game Object, in source pixels.\n     * @param {number} [offsetY] - The vertical offset of the Body from its Game Object, in source pixels.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setCircle: function (radius, offsetX, offsetY)\n    {\n        if (offsetX === undefined) { offsetX = this.offset.x; }\n        if (offsetY === undefined) { offsetY = this.offset.y; }\n\n        if (radius > 0)\n        {\n            this.isCircle = true;\n            this.radius = radius;\n\n            this.sourceWidth = radius * 2;\n            this.sourceHeight = radius * 2;\n\n            this.width = this.sourceWidth * this._sx;\n            this.height = this.sourceHeight * this._sy;\n\n            this.halfWidth = Math.floor(this.width / 2);\n            this.halfHeight = Math.floor(this.height / 2);\n\n            this.offset.set(offsetX, offsetY);\n\n            this.updateCenter();\n        }\n        else\n        {\n            this.isCircle = false;\n        }\n\n        return this;\n    },\n\n    /**\n     * Resets this Body to the given coordinates. Also positions its parent Game Object to the same coordinates.\n     * If the Body had any velocity or acceleration it is lost as a result of calling this.\n     *\n     * @method Phaser.Physics.Arcade.Body#reset\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal position to place the Game Object and Body.\n     * @param {number} y - The vertical position to place the Game Object and Body.\n     */\n    reset: function (x, y)\n    {\n        this.stop();\n\n        var gameObject = this.gameObject;\n\n        gameObject.setPosition(x, y);\n\n        gameObject.getTopLeft(this.position);\n\n        this.prev.copy(this.position);\n\n        this.rotation = gameObject.angle;\n        this.preRotation = gameObject.angle;\n\n        this.updateBounds();\n        this.updateCenter();\n    },\n\n    /**\n     * Sets acceleration, velocity, and speed to zero.\n     *\n     * @method Phaser.Physics.Arcade.Body#stop\n     * @since 3.0.0\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    stop: function ()\n    {\n        this.velocity.set(0);\n        this.acceleration.set(0);\n        this.speed = 0;\n        this.angularVelocity = 0;\n        this.angularAcceleration = 0;\n\n        return this;\n    },\n\n    /**\n     * Copies the coordinates of this Body's edges into an object.\n     *\n     * @method Phaser.Physics.Arcade.Body#getBounds\n     * @since 3.0.0\n     *\n     * @param {Phaser.Types.Physics.Arcade.ArcadeBodyBounds} obj - An object to copy the values into.\n     *\n     * @return {Phaser.Types.Physics.Arcade.ArcadeBodyBounds} - An object with {x, y, right, bottom}.\n     */\n    getBounds: function (obj)\n    {\n        obj.x = this.x;\n        obj.y = this.y;\n        obj.right = this.right;\n        obj.bottom = this.bottom;\n\n        return obj;\n    },\n\n    /**\n     * Tests if the coordinates are within this Body's boundary.\n     *\n     * @method Phaser.Physics.Arcade.Body#hitTest\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal coordinate.\n     * @param {number} y - The vertical coordinate.\n     *\n     * @return {boolean} True if (x, y) is within this Body.\n     */\n    hitTest: function (x, y)\n    {\n        return (this.isCircle) ? CircleContains(this, x, y) : RectangleContains(this, x, y);\n    },\n\n    /**\n     * Whether this Body is touching a tile or the world boundary while moving down.\n     *\n     * @method Phaser.Physics.Arcade.Body#onFloor\n     * @since 3.0.0\n     * @see Phaser.Physics.Arcade.Body#blocked\n     *\n     * @return {boolean} True if touching.\n     */\n    onFloor: function ()\n    {\n        return this.blocked.down;\n    },\n\n    /**\n     * Whether this Body is touching a tile or the world boundary while moving up.\n     *\n     * @method Phaser.Physics.Arcade.Body#onCeiling\n     * @since 3.0.0\n     * @see Phaser.Physics.Arcade.Body#blocked\n     *\n     * @return {boolean} True if touching.\n     */\n    onCeiling: function ()\n    {\n        return this.blocked.up;\n    },\n\n    /**\n     * Whether this Body is touching a tile or the world boundary while moving left or right.\n     *\n     * @method Phaser.Physics.Arcade.Body#onWall\n     * @since 3.0.0\n     * @see Phaser.Physics.Arcade.Body#blocked\n     *\n     * @return {boolean} True if touching.\n     */\n    onWall: function ()\n    {\n        return (this.blocked.left || this.blocked.right);\n    },\n\n    /**\n     * The absolute (non-negative) change in this Body's horizontal position from the previous step.\n     *\n     * @method Phaser.Physics.Arcade.Body#deltaAbsX\n     * @since 3.0.0\n     *\n     * @return {number} The delta value.\n     */\n    deltaAbsX: function ()\n    {\n        return (this._dx > 0) ? this._dx : -this._dx;\n    },\n\n    /**\n     * The absolute (non-negative) change in this Body's vertical position from the previous step.\n     *\n     * @method Phaser.Physics.Arcade.Body#deltaAbsY\n     * @since 3.0.0\n     *\n     * @return {number} The delta value.\n     */\n    deltaAbsY: function ()\n    {\n        return (this._dy > 0) ? this._dy : -this._dy;\n    },\n\n    /**\n     * The change in this Body's horizontal position from the previous step.\n     * This value is set during the Body's update phase.\n     *\n     * @method Phaser.Physics.Arcade.Body#deltaX\n     * @since 3.0.0\n     *\n     * @return {number} The delta value.\n     */\n    deltaX: function ()\n    {\n        return this._dx;\n    },\n\n    /**\n     * The change in this Body's vertical position from the previous step.\n     * This value is set during the Body's update phase.\n     *\n     * @method Phaser.Physics.Arcade.Body#deltaY\n     * @since 3.0.0\n     *\n     * @return {number} The delta value.\n     */\n    deltaY: function ()\n    {\n        return this._dy;\n    },\n\n    /**\n     * The change in this Body's rotation from the previous step, in degrees.\n     *\n     * @method Phaser.Physics.Arcade.Body#deltaZ\n     * @since 3.0.0\n     *\n     * @return {number} The delta value.\n     */\n    deltaZ: function ()\n    {\n        return this.rotation - this.preRotation;\n    },\n\n    /**\n     * Disables this Body and marks it for deletion by the simulation.\n     *\n     * @method Phaser.Physics.Arcade.Body#destroy\n     * @since 3.0.0\n     */\n    destroy: function ()\n    {\n        this.enable = false;\n\n        if (this.world)\n        {\n            this.world.pendingDestroy.set(this);\n        }\n    },\n\n    /**\n     * Draws this Body's boundary and velocity, if enabled.\n     *\n     * @method Phaser.Physics.Arcade.Body#drawDebug\n     * @since 3.0.0\n     *\n     * @param {Phaser.GameObjects.Graphics} graphic - The Graphics object to draw on.\n     */\n    drawDebug: function (graphic)\n    {\n        var pos = this.position;\n\n        var x = pos.x + this.halfWidth;\n        var y = pos.y + this.halfHeight;\n\n        if (this.debugShowBody)\n        {\n            graphic.lineStyle(graphic.defaultStrokeWidth, this.debugBodyColor);\n\n            if (this.isCircle)\n            {\n                graphic.strokeCircle(x, y, this.width / 2);\n            }\n            else\n            {\n                graphic.strokeRect(pos.x, pos.y, this.width, this.height);\n            }\n        }\n\n        if (this.debugShowVelocity)\n        {\n            graphic.lineStyle(graphic.defaultStrokeWidth, this.world.defaults.velocityDebugColor, 1);\n            graphic.lineBetween(x, y, x + this.velocity.x / 2, y + this.velocity.y / 2);\n        }\n    },\n\n    /**\n     * Whether this Body will be drawn to the debug display.\n     *\n     * @method Phaser.Physics.Arcade.Body#willDrawDebug\n     * @since 3.0.0\n     *\n     * @return {boolean} True if either `debugShowBody` or `debugShowVelocity` are enabled.\n     */\n    willDrawDebug: function ()\n    {\n        return (this.debugShowBody || this.debugShowVelocity);\n    },\n\n    /**\n     * Sets whether this Body collides with the world boundary.\n     * \n     * Optionally also sets the World Bounce values. If the `Body.worldBounce` is null, it's set to a new Vec2 first.\n     *\n     * @method Phaser.Physics.Arcade.Body#setCollideWorldBounds\n     * @since 3.0.0\n     *\n     * @param {boolean} [value=true] - `true` if this body should collide with the world bounds, otherwise `false`.\n     * @param {number} [bounceX] - If given this will be replace the `worldBounce.x` value.\n     * @param {number} [bounceY] - If given this will be replace the `worldBounce.y` value.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setCollideWorldBounds: function (value, bounceX, bounceY)\n    {\n        if (value === undefined) { value = true; }\n\n        this.collideWorldBounds = value;\n\n        var setBounceX = (bounceX !== undefined);\n        var setBounceY = (bounceY !== undefined);\n\n        if (setBounceX || setBounceY)\n        {\n            if (!this.worldBounce)\n            {\n                this.worldBounce = new Vector2();\n            }\n\n            if (setBounceX)\n            {\n                this.worldBounce.x = bounceX;\n            }\n\n            if (setBounceY)\n            {\n                this.worldBounce.y = bounceY;\n            }\n        }\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's velocity.\n     *\n     * @method Phaser.Physics.Arcade.Body#setVelocity\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal velocity, in pixels per second.\n     * @param {number} [y=x] - The vertical velocity, in pixels per second.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setVelocity: function (x, y)\n    {\n        this.velocity.set(x, y);\n\n        x = this.velocity.x;\n        y = this.velocity.y;\n\n        this.speed = Math.sqrt(x * x + y * y);\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's horizontal velocity.\n     *\n     * @method Phaser.Physics.Arcade.Body#setVelocityX\n     * @since 3.0.0\n     *\n     * @param {number} value - The velocity, in pixels per second.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setVelocityX: function (value)\n    {\n        this.velocity.x = value;\n\n        var x = value;\n        var y = this.velocity.y;\n\n        this.speed = Math.sqrt(x * x + y * y);\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's vertical velocity.\n     *\n     * @method Phaser.Physics.Arcade.Body#setVelocityY\n     * @since 3.0.0\n     *\n     * @param {number} value - The velocity, in pixels per second.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setVelocityY: function (value)\n    {\n        this.velocity.y = value;\n\n        var x = this.velocity.x;\n        var y = value;\n\n        this.speed = Math.sqrt(x * x + y * y);\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's maximum velocity.\n     *\n     * @method Phaser.Physics.Arcade.Body#setMaxVelocity\n     * @since 3.10.0\n     *\n     * @param {number} x - The horizontal velocity, in pixels per second.\n     * @param {number} [y=x] - The vertical velocity, in pixels per second.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setMaxVelocity: function (x, y)\n    {\n        this.maxVelocity.set(x, y);\n\n        return this;\n    },\n\n    /**\n     * Sets the maximum speed the Body can move.\n     *\n     * @method Phaser.Physics.Arcade.Body#setMaxSpeed\n     * @since 3.16.0\n     *\n     * @param {number} value - The maximum speed value, in pixels per second. Set to a negative value to disable.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setMaxSpeed: function (value)\n    {\n        this.maxSpeed = value;\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's bounce.\n     *\n     * @method Phaser.Physics.Arcade.Body#setBounce\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal bounce, relative to 1.\n     * @param {number} y - The vertical bounce, relative to 1.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setBounce: function (x, y)\n    {\n        this.bounce.set(x, y);\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's horizontal bounce.\n     *\n     * @method Phaser.Physics.Arcade.Body#setBounceX\n     * @since 3.0.0\n     *\n     * @param {number} value - The bounce, relative to 1.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setBounceX: function (value)\n    {\n        this.bounce.x = value;\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's vertical bounce.\n     *\n     * @method Phaser.Physics.Arcade.Body#setBounceY\n     * @since 3.0.0\n     *\n     * @param {number} value - The bounce, relative to 1.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setBounceY: function (value)\n    {\n        this.bounce.y = value;\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's acceleration.\n     *\n     * @method Phaser.Physics.Arcade.Body#setAcceleration\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal component, in pixels per second squared.\n     * @param {number} y - The vertical component, in pixels per second squared.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setAcceleration: function (x, y)\n    {\n        this.acceleration.set(x, y);\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's horizontal acceleration.\n     *\n     * @method Phaser.Physics.Arcade.Body#setAccelerationX\n     * @since 3.0.0\n     *\n     * @param {number} value - The acceleration, in pixels per second squared.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setAccelerationX: function (value)\n    {\n        this.acceleration.x = value;\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's vertical acceleration.\n     *\n     * @method Phaser.Physics.Arcade.Body#setAccelerationY\n     * @since 3.0.0\n     *\n     * @param {number} value - The acceleration, in pixels per second squared.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setAccelerationY: function (value)\n    {\n        this.acceleration.y = value;\n\n        return this;\n    },\n\n    /**\n     * Enables or disables drag.\n     *\n     * @method Phaser.Physics.Arcade.Body#setAllowDrag\n     * @since 3.9.0\n     * @see Phaser.Physics.Arcade.Body#allowDrag\n     *\n     * @param {boolean} [value=true] - `true` to allow drag on this body, or `false` to disable it.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setAllowDrag: function (value)\n    {\n        if (value === undefined) { value = true; }\n\n        this.allowDrag = value;\n\n        return this;\n    },\n\n    /**\n     * Enables or disables gravity's effect on this Body.\n     *\n     * @method Phaser.Physics.Arcade.Body#setAllowGravity\n     * @since 3.9.0\n     * @see Phaser.Physics.Arcade.Body#allowGravity\n     *\n     * @param {boolean} [value=true] - `true` to allow gravity on this body, or `false` to disable it.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setAllowGravity: function (value)\n    {\n        if (value === undefined) { value = true; }\n\n        this.allowGravity = value;\n\n        return this;\n    },\n\n    /**\n     * Enables or disables rotation.\n     *\n     * @method Phaser.Physics.Arcade.Body#setAllowRotation\n     * @since 3.9.0\n     * @see Phaser.Physics.Arcade.Body#allowRotation\n     *\n     * @param {boolean} [value=true] - `true` to allow rotation on this body, or `false` to disable it.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setAllowRotation: function (value)\n    {\n        if (value === undefined) { value = true; }\n\n        this.allowRotation = value;\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's drag.\n     *\n     * @method Phaser.Physics.Arcade.Body#setDrag\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal component, in pixels per second squared.\n     * @param {number} y - The vertical component, in pixels per second squared.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setDrag: function (x, y)\n    {\n        this.drag.set(x, y);\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's horizontal drag.\n     *\n     * @method Phaser.Physics.Arcade.Body#setDragX\n     * @since 3.0.0\n     *\n     * @param {number} value - The drag, in pixels per second squared.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setDragX: function (value)\n    {\n        this.drag.x = value;\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's vertical drag.\n     *\n     * @method Phaser.Physics.Arcade.Body#setDragY\n     * @since 3.0.0\n     *\n     * @param {number} value - The drag, in pixels per second squared.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setDragY: function (value)\n    {\n        this.drag.y = value;\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's gravity.\n     *\n     * @method Phaser.Physics.Arcade.Body#setGravity\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal component, in pixels per second squared.\n     * @param {number} y - The vertical component, in pixels per second squared.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setGravity: function (x, y)\n    {\n        this.gravity.set(x, y);\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's horizontal gravity.\n     *\n     * @method Phaser.Physics.Arcade.Body#setGravityX\n     * @since 3.0.0\n     *\n     * @param {number} value - The gravity, in pixels per second squared.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setGravityX: function (value)\n    {\n        this.gravity.x = value;\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's vertical gravity.\n     *\n     * @method Phaser.Physics.Arcade.Body#setGravityY\n     * @since 3.0.0\n     *\n     * @param {number} value - The gravity, in pixels per second squared.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setGravityY: function (value)\n    {\n        this.gravity.y = value;\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's friction.\n     *\n     * @method Phaser.Physics.Arcade.Body#setFriction\n     * @since 3.0.0\n     *\n     * @param {number} x - The horizontal component, relative to 1.\n     * @param {number} y - The vertical component, relative to 1.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setFriction: function (x, y)\n    {\n        this.friction.set(x, y);\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's horizontal friction.\n     *\n     * @method Phaser.Physics.Arcade.Body#setFrictionX\n     * @since 3.0.0\n     *\n     * @param {number} value - The friction value, relative to 1.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setFrictionX: function (value)\n    {\n        this.friction.x = value;\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's vertical friction.\n     *\n     * @method Phaser.Physics.Arcade.Body#setFrictionY\n     * @since 3.0.0\n     *\n     * @param {number} value - The friction value, relative to 1.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setFrictionY: function (value)\n    {\n        this.friction.y = value;\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's angular velocity.\n     *\n     * @method Phaser.Physics.Arcade.Body#setAngularVelocity\n     * @since 3.0.0\n     *\n     * @param {number} value - The velocity, in degrees per second.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setAngularVelocity: function (value)\n    {\n        this.angularVelocity = value;\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's angular acceleration.\n     *\n     * @method Phaser.Physics.Arcade.Body#setAngularAcceleration\n     * @since 3.0.0\n     *\n     * @param {number} value - The acceleration, in degrees per second squared.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setAngularAcceleration: function (value)\n    {\n        this.angularAcceleration = value;\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's angular drag.\n     *\n     * @method Phaser.Physics.Arcade.Body#setAngularDrag\n     * @since 3.0.0\n     *\n     * @param {number} value - The drag, in degrees per second squared.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setAngularDrag: function (value)\n    {\n        this.angularDrag = value;\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's mass.\n     *\n     * @method Phaser.Physics.Arcade.Body#setMass\n     * @since 3.0.0\n     *\n     * @param {number} value - The mass value, relative to 1.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setMass: function (value)\n    {\n        this.mass = value;\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's `immovable` property.\n     *\n     * @method Phaser.Physics.Arcade.Body#setImmovable\n     * @since 3.0.0\n     *\n     * @param {boolean} [value=true] - The value to assign to `immovable`.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setImmovable: function (value)\n    {\n        if (value === undefined) { value = true; }\n\n        this.immovable = value;\n\n        return this;\n    },\n\n    /**\n     * Sets the Body's `enable` property.\n     *\n     * @method Phaser.Physics.Arcade.Body#setEnable\n     * @since 3.15.0\n     *\n     * @param {boolean} [value=true] - The value to assign to `enable`.\n     *\n     * @return {Phaser.Physics.Arcade.Body} This Body object.\n     */\n    setEnable: function (value)\n    {\n        if (value === undefined) { value = true; }\n\n        this.enable = value;\n\n        return this;\n    },\n\n    /**\n     * The Body's horizontal position (left edge).\n     *\n     * @name Phaser.Physics.Arcade.Body#x\n     * @type {number}\n     * @since 3.0.0\n     */\n    x: {\n\n        get: function ()\n        {\n            return this.position.x;\n        },\n\n        set: function (value)\n        {\n            this.position.x = value;\n        }\n\n    },\n\n    /**\n     * The Body's vertical position (top edge).\n     *\n     * @name Phaser.Physics.Arcade.Body#y\n     * @type {number}\n     * @since 3.0.0\n     */\n    y: {\n\n        get: function ()\n        {\n            return this.position.y;\n        },\n\n        set: function (value)\n        {\n            this.position.y = value;\n        }\n\n    },\n\n    /**\n     * The left edge of the Body's boundary. Identical to x.\n     *\n     * @name Phaser.Physics.Arcade.Body#left\n     * @type {number}\n     * @readonly\n     * @since 3.0.0\n     */\n    left: {\n\n        get: function ()\n        {\n            return this.position.x;\n        }\n\n    },\n\n    /**\n     * The right edge of the Body's boundary.\n     *\n     * @name Phaser.Physics.Arcade.Body#right\n     * @type {number}\n     * @readonly\n     * @since 3.0.0\n     */\n    right: {\n\n        get: function ()\n        {\n            return this.position.x + this.width;\n        }\n\n    },\n\n    /**\n     * The top edge of the Body's boundary. Identical to y.\n     *\n     * @name Phaser.Physics.Arcade.Body#top\n     * @type {number}\n     * @readonly\n     * @since 3.0.0\n     */\n    top: {\n\n        get: function ()\n        {\n            return this.position.y;\n        }\n\n    },\n\n    /**\n     * The bottom edge of this Body's boundary.\n     *\n     * @name Phaser.Physics.Arcade.Body#bottom\n     * @type {number}\n     * @readonly\n     * @since 3.0.0\n     */\n    bottom: {\n\n        get: function ()\n        {\n            return this.position.y + this.height;\n        }\n\n    }\n\n});\n\nmodule.exports = Body;\n"},"sourceMaps":null,"error":null,"hash":"9f376f28cbceadd543d8e804aa84e895","cacheData":{"env":{}}}